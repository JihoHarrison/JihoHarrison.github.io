<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="👾 LiveData란 무엇인가?Android Architecuture 포스팅 을 통해 안드로이드 권장 Architecture 에 대해 공부해보니 LiveData라는 것의 역할이 크다는 것을 알게 되었다.이 포스팅에서는 위 목록처럼 안드로이드 jetpack 라이브러리 중 Archit...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[안드로이드] 👾 LiveData | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[안드로이드] 👾 LiveData | choheeis">
  <meta name="twitter:description" content="👾 LiveData란 무엇인가?Android Architecuture 포스팅 을 통해 안드로이드 권장 Architecture 에 대해 공부해보니 LiveData라는 것의 역할이 크다는 것을 알게 되었다.이 포스팅에서는 위 목록처럼 안드로이드 jetpack 라이브러리 중 Archit...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-06/LiveData">
  <meta property="og:title" content="[안드로이드] 👾 LiveData | choheeis">
  <meta property="og:description" content="👾 LiveData란 무엇인가?Android Architecuture 포스팅 을 통해 안드로이드 권장 Architecture 에 대해 공부해보니 LiveData라는 것의 역할이 크다는 것을 알게 되었다.이 포스팅에서는 위 목록처럼 안드로이드 jetpack 라이브러리 중 Archit...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[안드로이드] 👾 LiveData | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-06/LiveData">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[안드로이드] 👾 LiveData">[안드로이드] 👾 LiveData</h1>
    <span class="post-meta">
      <span class="post-date">
        8 JUN 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    5 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <p><br /></p>

<h2 id="-livedata란-무엇인가">👾 LiveData란 무엇인가?</h2>
<hr />

<p><a href="https://choheeis.github.io/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/2020/05/28/AndroidArchitecture.html">Android Architecuture 포스팅</a> 을 통해 안드로이드 권장 Architecture 에 대해 공부해보니 LiveData라는 것의 역할이 크다는 것을 알게 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/84024161-53a18580-a9c4-11ea-8220-70e15ccfb34d.PNG" alt="01" /></p>

<p>이 포스팅에서는 위 목록처럼 안드로이드 jetpack 라이브러리 중 Architecture 부분에 속하는 라이브러리들 중 하나인 <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> 에 대해서 알아보자!</p>

<p><br /></p>

<h2 id="-livedata-개요">👾 LiveData 개요</h2>
<hr />

<p>LiveData는 관찰 가능한 데이터 홀더 클래스이다. 즉 데이터 클래스를 잡고 있는 클래스라는 것이다.</p>

<p>LiveData의 가장 큰 특징은 Activity나 Fragment, Service 등의 수명 주기를 자체적으로 인식한다는 점이다.</p>

<p>이렇게 수명 주기 인식을 함으로써 LiveData는 
active한 상태에 있는 앱 컴포넌트 관찰자에만 데이터를 업데이트하게 된다.</p>

<blockquote>
  <p>앱 컴포넌트 관찰자는 Activity, Fragment, Service 등을 의미한다.</p>
</blockquote>

<p>즉, activity나 fragment가 LiveData를 관찰하고 있는 관찰자(Observer)인 것이다.</p>

<blockquote>
  <p>LiveData를 Android 프로젝트에서 사용하려면 먼저 <a href="https://developer.android.com/topic/libraries/architecture/adding-components#lifecycle">여기</a> 를 참고하자.</p>
</blockquote>

<p><br /></p>

<p>Observer 클래스(=관찰자)의 수명 주기가 STARTED 또는 RESUMED 상태이면 LiveData는 관찰자를 active 상태로 간주한다.</p>

<p>LiveData는 active 상태인 관찰자에게만 업데이트 정보를 알린다는 것을 꼭 알아두자.</p>

<p>만약 관찰자의 Lifecycle 상태가 DESTROYED 로 변경된다면 LiveData는 자동으로 자신을 관찰하는 관찰자를 삭제해준다.</p>

<p>따라서 activity와 fragment의 수명 주기가 끝나는 즉시 업데이트된 데이터의 수신이 거부되기 때문에 데이터 누출을 걱정할 필요가 없다.</p>

<p><br /></p>

<h2 id="-livedata-를-사용하면-좋은-점">👾 LiveData 를 사용하면 좋은 점</h2>
<hr />

<ol>
  <li>
    <p><strong>UI와 데이터 상태의 일치를 보장할 수 있다.</strong></p>

    <p>LiveData는 observer 패턴을 따르기 때문에 자신을 관찰하고 있는 Observer의 수명 주기 상태가 변경될 때마다 적합한 방식으로 데이터를 업데이트 해주기 때문이다.</p>
  </li>
  <li>
    <p><strong>메모리 누출을 없앨 수 있다.</strong></p>

    <p>관찰자의 수명 주기가 비활성 상태(activity가 다른 activity에 가려서 back stack에 있는 경우)이면 관찰자는 LiveData의 어떠한 이벤트도 수신하지 않기 때문이다.</p>
  </li>
  <li>
    <p><strong>수명 주기를 더 이상 수동으로 처리하지 않을 수 있다.</strong></p>

    <p>UI 컴포넌트는 관련 데이터를 관찰하기만 할 뿐 직접 관찰을 중지하거나 시작할 수는 없다.</p>

    <p>대신 LiveData가 관련 수명 주기 상태의 변경을 인식하여 이 모든 것을 자동으로 관리한다.</p>
  </li>
  <li>
    <p><strong>최신 데이터를 유지할 수 있다.</strong></p>

    <p>수명 주기가 비활성화되면 다시 활성화될 때 최신 데이터를 수신하기 때문이다.</p>
  </li>
  <li>
    <p><strong>리소스 공유</strong></p>

    <p>앱에서 싱글톤 패턴을 사용하는 LiveData 객체를 확장하여 시스템 서비스를 래핑할 수 있다.</p>

    <p>LiveData가 시스템 서비스에 한 번 연결되면 리소스가 필요한 모든 관찰자가 LiveData를 관찰할 수 있기 때문이다.</p>

    <p><br /></p>
  </li>
</ol>

<h2 id="-livedata-사용하기">👾 LiveData 사용하기</h2>
<hr />

<p>LiveData를 사용하려면 다음과 같은 단계를 따라야 한다.</p>

<p>1️⃣ 특정 유형의 데이터를 홀드할(잡고있을) LiveData의 인스턴스를 생성한다.</p>

<p>일반적으로 이 작업은 ViewModel 클래스 내에서 이루어진다.</p>

<p>2️⃣ onChanged() 메소드를 정의하는 Observer 객체를 생성한다. 이 메소드는 LiveData가 보유한 데이터가 변경할 시 발생하는 작업을 제어하는 메소드이다.</p>

<p>일반적으로 이 작업은 activity나 fragment 같은 UI 컨트롤러에 Observer 객체를 생성함으로써 행해진다.</p>

<p>3️⃣ observe() 메소드를 사용하여 LiveData에 Observer를 연결한다.</p>

<p>observe() 메소드는 LifecycleOwner를 사용하고, 이로 인해 Observer 가 LiveData를 구독하여 변경사항에 관한 알람을 받을 수 있다.</p>

<p>일반적으로 이 작업은 activity나 fragment 같은 UI 컨트롤러에 Observer 객체를 연결함으로써 행해진다.</p>

<blockquote>
  <p>observeForever(Observer) 메소드를 사용하면 LifecycleOwner가 연결되지 않은 관찰자도 관찰자로 등록할 수 있다.</p>

  <p>하지만 이 경우에는 관찰자가 항상 active 상태로 간주되어 항상 데이터 업데이트 알림을 받게 된다.</p>

  <p>removeObserver(Observer) 메소드를 호출하면 이러한 관찰자를 삭제할 수도 있다.</p>
</blockquote>

<p><br /></p>

<p>LiveData 에 저장된 데이터 값이 업데이트되면 연결된 LifecycleOwner 가 active 상태에 있는 모든 등록된 관찰자를 트리거한다.</p>

<p>이로 인해 LiveData 에서 보유한 데이터가 변경되면 UI가 자동 업데이트 된다.</p>

<p>그럼 이제 위 3가지 단계를 하나하나 알아보자!</p>

<p><br /></p>

<h2 id="1️⃣-livedata-객체-인스턴스-생성하기">1️⃣ LiveData 객체 인스턴스 생성하기</h2>
<hr />

<p>LiveData는 List같은 Collections 를 구현하는 객체를 비롯한 모든 데이터와 함께 사용할 수 있는 홀드 클래스이다.</p>

<p>LiveData 객체는 일반적으로 ViewModel 내에 저장되며 다음과 같이 getter 메소드를 통해 엑세스 된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">NameViewModel</span> <span class="p">:</span> <span class="n">ViewModel</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// Create a LiveData with a String
</span>    <span class="kd">val</span> <span class="py">currentName</span><span class="p">:</span> <span class="n">MutableLiveData</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">lazy</span> <span class="p">{</span>
        <span class="n">MutableLiveData</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;()</span>
    <span class="p">}</span>

    <span class="c1">// Rest of the ViewModel...
</span><span class="p">}</span>
</code></pre></div></div>

<p>위 코드에서 LiveData는 string형의 어떠한 데이터 하나를 홀드하고 있다.</p>

<p><br /></p>

<h2 id="2️⃣--3️⃣-livedata-관찰하기">2️⃣ + 3️⃣ LiveData 관찰하기</h2>
<hr />

<p>activity나 fragment의 onResume() 메소드에서 중복 호출을 하지 않도록 하기 위해서 대부분의 경우 onCreate() 메소드에서 LiveData를 관찰한다.</p>

<p>또한, activity나 fragment가 active 상태가 되는 즉시 표시할 수 있는 데이터를 보유하도록 하기 위함이다.</p>

<p>앱 컴포넌트는 STARTED 상태가 되는 즉시 관찰하고 있던 LiveData의 가장 최신 값을 받게 된다. 이는 관찰할 LiveData 객체가 설정된 경우에만 발생한다.</p>

<p>다음 코드와 같이 LiveData를 관찰해보자.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">NameActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// Use the 'by viewModels()' Kotlin property delegate
</span>    <span class="c1">// from the activity-ktx artifact
</span>    <span class="k">private</span> <span class="kd">val</span> <span class="py">model</span><span class="p">:</span> <span class="n">NameViewModel</span> <span class="k">by</span> <span class="n">viewModels</span><span class="p">()</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>

        <span class="c1">// Other code to setup the activity...
</span>
        <span class="c1">// Create the observer which updates the UI.
</span>        <span class="kd">val</span> <span class="py">nameObserver</span> <span class="p">=</span> <span class="n">Observer</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">newName</span> <span class="p">-&gt;</span>
            <span class="c1">// Update the UI, in this case, a TextView.
</span>            <span class="n">nameTextView</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">newName</span>
        <span class="p">}</span>

        <span class="c1">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.
</span>        <span class="n">model</span><span class="p">.</span><span class="n">currentName</span><span class="p">.</span><span class="n">observe</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">nameObserver</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="4️⃣-livedata-업데이트하기">4️⃣ LiveData 업데이트하기</h2>
<hr />

<p>LiveData에는 저장된 데이터를 수동으로 업데이트할 수 있는 메소드가 없다.</p>

<p>하지만 MutableLiveData 라는 클래스를 사용하면 setValue(), postValue() 메소드를 통해 LiveData 에 저장된 값을 수정할 수 있다.</p>

<p>일반적으로 MutableLiveData도 ViewModel에서 사용한다.</p>

<p>MutableLiveData와의 관찰자 관계를 설정한 후에는 아래 코드와 같이 사용자가 버튼을 탭했을 때 모든 관찰자를 트리거하는 LiveData 값을 수정할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">button</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">anotherName</span> <span class="p">=</span> <span class="s">"John Doe"</span>
    <span class="n">model</span><span class="p">.</span><span class="n">currentName</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">anotherName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<blockquote>
  <p>여기까지 기본적으로 LiveData를 사용하는 방법에 대해 알아보았다!</p>
</blockquote>

  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

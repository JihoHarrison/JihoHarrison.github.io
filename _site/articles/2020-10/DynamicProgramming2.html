<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="0️⃣ 다이나믹 프로그래밍의 개념에 대해 알고 싶다면?이 블로그의 다른 포스팅 - Dynamic Programming 을 보고 오자!1️⃣ 문제 풀이 - 1로 만들기백준 문제 - 1로 만들기 를 DP로 풀어보자!이 문제는 큰 문제를 작은 문제로 쪼개어 풀 수 있는 문제이다.그럼 큰...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[알고리즘] 😎 Dynamic Programming 문제 풀이 | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[알고리즘] 😎 Dynamic Programming 문제 풀이 | choheeis">
  <meta name="twitter:description" content="0️⃣ 다이나믹 프로그래밍의 개념에 대해 알고 싶다면?이 블로그의 다른 포스팅 - Dynamic Programming 을 보고 오자!1️⃣ 문제 풀이 - 1로 만들기백준 문제 - 1로 만들기 를 DP로 풀어보자!이 문제는 큰 문제를 작은 문제로 쪼개어 풀 수 있는 문제이다.그럼 큰...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-10/DynamicProgramming2">
  <meta property="og:title" content="[알고리즘] 😎 Dynamic Programming 문제 풀이 | choheeis">
  <meta property="og:description" content="0️⃣ 다이나믹 프로그래밍의 개념에 대해 알고 싶다면?이 블로그의 다른 포스팅 - Dynamic Programming 을 보고 오자!1️⃣ 문제 풀이 - 1로 만들기백준 문제 - 1로 만들기 를 DP로 풀어보자!이 문제는 큰 문제를 작은 문제로 쪼개어 풀 수 있는 문제이다.그럼 큰...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[알고리즘] 😎 Dynamic Programming 문제 풀이 | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-10/DynamicProgramming2">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[알고리즘] 😎 Dynamic Programming 문제 풀이">[알고리즘] 😎 Dynamic Programming 문제 풀이</h1>
    <span class="post-meta">
      <span class="post-date">
        28 OCT 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    13 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <h2 id="0️⃣-다이나믹-프로그래밍의-개념에-대해-알고-싶다면">0️⃣ 다이나믹 프로그래밍의 개념에 대해 알고 싶다면?</h2>

<p><a href="https://choheeis.github.io/newblog//articles/2020-05/DynamicProgramming">이 블로그의 다른 포스팅 - Dynamic Programming</a> 을 보고 오자!</p>

<h2 id="1️⃣-문제-풀이---1로-만들기">1️⃣ 문제 풀이 - 1로 만들기</h2>

<p><a href="https://www.acmicpc.net/problem/1463">백준 문제 - 1로 만들기</a> 를 DP로 풀어보자!</p>

<p>이 문제는 큰 문제를 작은 문제로 쪼개어 풀 수 있는 문제이다.</p>

<p>그럼 큰 문제(<strong>D[N]</strong>)는 무엇일까? 큰 문제는 최종 정답을 도출할 수 있는 문제로 생각하면 된다.</p>

<p><strong>D[N] = N을 1로 만드는 최소 횟수</strong> 가 이 문제의 가장 큰 문제라고 볼 수 있다.</p>

<p>그렇다면 이 큰 문제를 작은 문제들로 쪼갤 수 있을까?</p>

<p>작은 문제들은 이 문제의 본문에 이미 다 나와있다.</p>

<p><img width="302" alt="09" src="https://user-images.githubusercontent.com/31889335/97393344-6fcba200-1926-11eb-8a94-70fff3c31f39.png" /></p>

<p>문제의 조건이였던 위 3가지 항목들이 바로 작은 문제들이라고 볼 수 있다.</p>

<p>예를 들어 N을 1로 만드는 최소 횟수를 구하기 위해 1번 조건인 X가 3으로 나누어 떨어지면, 3으로 나눈다를 N에 가장 먼저 적용했다고 해보자.</p>

<p>이 경우에, <strong>D[N] = (N/3 의 횟수) + (N/3을 1로 만드는 최소 횟수)</strong> 라고 정의할 수 있다.</p>

<p>이 때, N/3은 1번 만에 할 수 있고, N/3을 1로 만드는 최소 횟수는 기존의 큰 문제로 정의했던 N 자리에 N/3을 대입하면 되므로 D[N/3] 으로 표현할 수 있다.</p>

<p>정리하면 조건 1번을 적용했을 때 큰 문제 D[N] 은 <strong>D[N] = D[N/3] + 1</strong> 이라는 점화식으로 나타내질 수 있다는 것이다!</p>

<p>그렇다면 N에 가장 먼저 조건 2번을 적용했을 때의 점화식은 <strong>D[N] = D[N/2] + 1</strong> 이 될 것이라는 것을 유추할 수 있다.</p>

<p>또 마지막으로 N에 가장 먼저 조건 3번을 적용했을 때의 점화식은 <strong>D[N] = D[N-1] + 1</strong> 이 될 것이라는 것도 유추할 수 있다.</p>

<p>즉, 이 문제에서 큰 문제 D[N]을 작게 만들 수 있는 방법은 총 아래와 같은 3가지 인 것이다!</p>

<ul>
  <li>
    <p><strong>D[N] = D[N/3] + 1</strong></p>
  </li>
  <li>
    <p><strong>D[N] = D[N/2] + 1</strong></p>
  </li>
  <li>
    <p><strong>D[N] = D[N-1] + 1</strong></p>
  </li>
</ul>

<p>따라서 위 3가지 방법을 모두 구해본 후, D[N]의 값이 가장 최소가 되는 경우가 정답이 된다.</p>

<p>위 과정을 따라 정답을 구하는 코드를 작성해보자. 아래 코드는 bottom-top 방식으로 구현하였다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 언어 : kotlin
</span><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">N</span> <span class="p">=</span> <span class="n">readLine</span><span class="p">()</span><span class="o">!!</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span>

    <span class="c1">// bottom - top 방식
</span>    <span class="kd">var</span> <span class="py">memo</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="n">N</span><span class="p">+</span><span class="m">1</span><span class="p">){</span><span class="n">i</span> <span class="p">-&gt;</span> <span class="m">0</span><span class="p">}</span>
    <span class="n">memo</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span> <span class="c1">// index 0 안씀 처리
</span>    <span class="n">memo</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">0</span> <span class="c1">// 1로 만드는 방법은 0이니까 초기화 처리
</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">2</span><span class="o">..</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">min</span> <span class="p">=</span> <span class="n">N</span><span class="p">+</span><span class="m">1</span> <span class="c1">// 최솟값 저장을 위한 초기화 
</span>
        <span class="c1">// 조건 1 - 3으로 나누어 떨어지면, 3으로 나눈다.
</span>        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">%</span><span class="m">3</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span> <span class="p">+</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">/</span><span class="m">3</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">min</span> <span class="p">&gt;</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">min</span> <span class="p">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">// 최솟값 저장
</span>            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 조건 2 - 2로 나누어 떨어지면, 2로 나눈다.
</span>        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">%</span><span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span> <span class="p">+</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">/</span><span class="m">2</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">min</span> <span class="p">&gt;</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">min</span> <span class="p">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">// 최솟값 저장
</span>            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 조건 3 - 1을 뺀다.
</span>        <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span> <span class="p">+</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="m">1</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="n">min</span> <span class="p">&gt;</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">min</span> <span class="p">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">// 최솟값 저장
</span>        <span class="p">}</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">min</span> <span class="c1">// 이 때의 min이 가장 최소가 된다.
</span>    <span class="p">}</span>
    <span class="n">print</span><span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>DP는 어떻게 큰 문제를 작은 문제들로 나눌 것인지가 어렵고 중요한 것 같다.</p>

<h2 id="2️⃣-문제-풀이---2-x-n-타일링">2️⃣ 문제 풀이 - 2 X n 타일링</h2>

<p><a href="https://www.acmicpc.net/problem/11726">백준 문제 - 2 X n 타일링</a> 문제를 풀어보자.</p>

<p>DP 문제는 스스로 큰 문제에 대한 점화식을 찾을 수 있는 능력이 중요하다.</p>

<p>이 문제에서 구해야 하는 큰 문제의 점화식은 <strong>D[N] = 2 X N 크기의 직사각형을 채우는 방법의 수</strong> 이다. 이 큰 문제를 작은 문제들로 쪼갤 수 있다면? 그건 DP로 풀 수 있는 문제이다.</p>

<p>위에서 언급했던 1로 만들기 문제 풀이에서 큰 문제 D[N]을 작은 문제들로 쪼갤 때, 일단 가능한 경우 3가지가 존재했고, 각 경우마다 D[N] 을 재활용하여 D[N/3] 등과 같이 작은 문제를 정의했었다.</p>

<p>이 과정처럼 2 X n 타일링 문제도 <strong>일단 가능한 경우가 존재하는지 확인</strong> 해보자.</p>

<p><img width="511" alt="10" src="https://user-images.githubusercontent.com/31889335/97878090-7e202080-1d61-11eb-8b93-d38b5c92251e.png" /></p>

<p>위 그림처럼 가장 오른쪽에 타일을 놓을 수 있는 각각 서로 다른 경우 2가지가 존재한다!</p>

<ul>
  <li>
    <p>가장 오른쪽에 가로 형태의 2 X 1 타일이 2개 오는 경우</p>
  </li>
  <li>
    <p>가장 오른쪽에 세로 형태의 2 X 1 타일이 1개 오는 경우</p>
  </li>
</ul>

<p>따라서 이 문제의 정답은 위 두 경우에 구해지는 방법의 수를 합한 것이라는 것을 알 수 있을 것이다.</p>

<p>그렇다면 각 경우마다 큰 문제 D[N]은 어떻게 작은 문제로 쪼개질 수 있을까?</p>

<p><img width="502" alt="11" src="https://user-images.githubusercontent.com/31889335/97878705-52ea0100-1d62-11eb-855e-144737758d3a.png" /></p>

<p><img width="507" alt="12" src="https://user-images.githubusercontent.com/31889335/97878809-74e38380-1d62-11eb-8112-ac36314b899b.png" /></p>

<p>먼저 위의 첫 번째 그림을 보면 가장 오른쪽에 가로 형태의 2 X 1 타일이 2개 배치되었으므로 그 앞 공간들은 2 X n-2 크기의 직사각형을 채우는 방법의 수를 구하면 된다!</p>

<p>또 두 번째 그림을 보면 가장 오른쪽에 세로 형태의 2 X 1 타일이 1개 배치되었으므로 그 앞 공간들은 2 X n-1 크기의 직사각형을 채우는 방법의 수를 구하면 된다!</p>

<p>따라서 각 경우마다 큰 문제 D[N] 은 다음과 같이 작은 문제로 쪼개질 수 있게 된다.</p>

<ul>
  <li>
    <p>가장 오른쪽에 가로 형태의 2 X 1 타일이 2개 오는 경우 : <strong>D[N] = D[N-2]</strong></p>
  </li>
  <li>
    <p>가장 오른쪽에 세로 형태의 2 X 1 타일이 1개 오는 경우 : <strong>D[N] = D[N-1]</strong></p>
  </li>
</ul>

<p>즉, 이 문제의 큰 문제는 <strong>D[N] = D[N-1] + D[N-2]</strong> 가 되는 것이다!</p>

<p>그럼 이제 위 큰 문제의 점화식을 가지고 bottom - top 방식으로 문제를 풀어보자!</p>

<p>bottom - top 방식으로 문제를 풀려면 먼저 메모를 위한 배열을 선언해야 하고, 이 배열의 첫 번째 또는 두 번째 원소까지의 값이 초기화되어야 한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 언어 : kotlin
</span><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">n</span> <span class="p">=</span> <span class="n">readLine</span><span class="p">()</span><span class="o">!!</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span>
    <span class="n">print</span><span class="p">(</span><span class="n">BJ_11726</span><span class="p">().</span><span class="n">solution</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">BJ_11726</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">D</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">1001</span><span class="p">){</span><span class="m">0</span><span class="p">}</span> <span class="c1">// memoization을 위한 배열(점화식 표현과 맞추려고 D라고 이름 지음)
</span>        <span class="n">D</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// 아래 for문에서 i가 2일 때 D[0]이 되는데 2 X 2 크기의 직사각형의 가장 오른쪽에 가로 형태의 2 X 1 직사각형 2개가 들어가는 경우에도 방법의 수는 1임
</span>        <span class="n">D</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// 아래 for문에서 i가 1일 때 D[1]이 되는데 2 X 2 크기의 직사각형의 가장 오른쪽에 세 형태의 2 X 1 직사각형 1개가 들어가는 경우에도 방법의 수는 1임
</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">2</span><span class="o">..</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="m">2</span><span class="p">]</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">%</span> <span class="m">10007</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="py">answer</span> <span class="p">=</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">answer</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3️⃣-문제-풀이---1-2-3-더하기">3️⃣ 문제 풀이 - 1, 2, 3 더하기</h2>

<p><a href="https://www.acmicpc.net/problem/9095">백준 문제 - 1, 2, 3 더하기</a> 문제를 풀어보자.</p>

<p>이 문제에서 구해야 하는 큰 문제는 <strong>D[N] = N을 1, 2, 3의 합으로 만드는 방법의 수</strong> 라고 볼 수 있다.</p>

<p>그럼 큰 문제 D[N] 을 작은 문제로 쪼갤 수 있도록 하는 특정 경우들이 존재할까?</p>

<p>문제에서 예시로 n이 4일 때는 1, 2, 3의 합으로 나타낼 수 있는 방법이 아래와 같이 총 7개의 방법이라 나와있다.</p>

<p><img width="105" alt="13" src="https://user-images.githubusercontent.com/31889335/97889303-9008c000-1d6f-11eb-8bbe-6f3469007fcf.png" /></p>

<p>그럼 위 예시를 보고 특정 경우들을 찾아내보자.</p>

<ul>
  <li>
    <p>1 + X 로 나타낼 수 있는 경우</p>
  </li>
  <li>
    <p>2 + X 로 나타낼 수 있는 경우</p>
  </li>
  <li>
    <p>3 + X 로 나타낼 수 있는 경우</p>
  </li>
</ul>

<p>위 3가지 경우는 수식의 맨 앞에 놓이는 수에 따라 경우를 나눈 것이다.</p>

<p>n이 4일 때의 예시를 보면 수식의 맨 앞에 놓이는 수가 1인 경우, 1 + 1 + 1 + 1, 1 + 1 + 2, 1 + 2 + 1, 1 + 3 으로 총 4개의 방법이 존재한다.</p>

<p>이와 같이 수식의 맨 앞에 놓이는 수가 2인 경우, 2 + 1 + 1, 2 + 2 로 총 2개의 방법이 존재한다.</p>

<p>마지막으로 수식의 맨 앞에 놓이는 수가 3인 경우, 3 + 1 로 총 1개의 방법이 존재한다.</p>

<p>따라서 n이 4일 경우, D[4] =  1, 2, 3의 합으로 만드는 방법의 수 = 4 + 2 + 1 = 7 이다.</p>

<p>그럼 이제 각 경우를 어떻게 점화식으로 나타낼 수 있을까?</p>

<p>각 경우에서 X는 N에서 맨 앞자리 수를 뺀 값이다. 예를 들어, N이 4일 때 1 + X 경우에서의 X는 3이고, 이는 다시 3을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수를 구하면 되는 것과 같다.</p>

<ul>
  <li>
    <p>1 + X 로 나타낼 수 있는 경우 = <strong>D[N] = D[N-1]</strong></p>
  </li>
  <li>
    <p>2 + X 로 나타낼 수 있는 경우 = <strong>D[N] = D[N-2]</strong></p>
  </li>
  <li>
    <p>3 + X 로 나타낼 수 있는 경우 = <strong>D[N] = D[N-3]</strong></p>
  </li>
</ul>

<p>따라서 최종 큰 문제인 <strong>D[N] = D[N-1] + D[N-2] + D[N-3]</strong> 인 것이다.</p>

<p>그럼 이제 위 큰 문제의 점화식을 가지고 bottom - top 방식으로 문제를 풀어보자!</p>

<p>이 때 구해놓은 점화식은 N이 4 이상일 때만 항상 적용되는 식이므로, 아래 코드의 memo 배열에서 index 0, 1, 2, 3은 직접 값을 생각하여 초기화 해줘야 한다!</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 언어 : kotlin
</span><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">T</span> <span class="p">=</span> <span class="n">readLine</span><span class="p">()</span><span class="o">!!</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span>
    <span class="n">BJ_9095</span><span class="p">().</span><span class="n">solution</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">BJ_9095</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">solution</span><span class="p">(</span><span class="n">T</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">memo</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">11</span><span class="p">){</span><span class="m">0</span><span class="p">}</span>
        <span class="n">memo</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span> <span class="c1">// index 0은 안씀 처리
</span>        <span class="n">memo</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span>
        <span class="n">memo</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">2</span>
        <span class="n">memo</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">=</span> <span class="m">4</span>

        <span class="c1">// 문제에서 n은 1 ~ 10까지라고 했으므로 10까지 memo값을 다 구해놓고, 테스트 케이스를 돌려야 시간 효율성이 높아짐 
</span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4</span><span class="o">..</span><span class="m">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="n">i</span><span class="p">-</span><span class="m">1</span> <span class="n">downTo</span> <span class="n">i</span><span class="p">-</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+=</span> <span class="n">memo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// input
</span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">val</span> <span class="py">n</span> <span class="p">=</span> <span class="n">readLine</span><span class="p">()</span><span class="o">!!</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span>
            <span class="n">println</span><span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>bottom - top 방식으로 문제를 풀 때 팁은 점화식이 N이 몇 이상부터 항상 만족하는 식인지를 생각하고, 만족하지 못하는 N을 index로 갖는 배열의 원소은 직접 값을 생각하여 초기화 시켜주면 된다!</p>

<h2 id="4️⃣-문제풀이---카드-구매하기">4️⃣ 문제풀이 - 카드 구매하기</h2>

<p><a href="https://www.acmicpc.net/problem/11052">백준 문제 - 카드 구매하기</a> 문제를 풀어보자.</p>

<p>이 문제에서 구해야 하는 큰 문제는 <strong>D[N] = N개의 카드를 구매하기 위해 지불해야 하는 금액의 최댓값</strong> 라고 볼 수 있다.</p>

<p>그럼 큰 문제 D[N] 을 작은 문제로 쪼갤 수 있도록 하는 특정 경우들이 존재할까?</p>

<p>문제에서 예시로 든 N = 4일 때 카드팩을 골라 총 4개의 카드를 만들 수 있는 경우는 다음과 같다.</p>

<p><img width="308" alt="14" src="https://user-images.githubusercontent.com/31889335/98335742-e2383280-2048-11eb-9fb1-1bacf766e55e.png" /></p>

<p>위 경우들을 자세히 보면 맨 마지막으로 선택하는 카드가 p1인지, p2인지, p3인지, p4인지에 따라 경우가 달라진다는 것을 확인할 수 있다.</p>

<p>즉, 만약 맨 마지막으로 선택하는 카드가 p1인 경우는 다음과 같은데</p>

<p><img width="589" alt="15" src="https://user-images.githubusercontent.com/31889335/98336073-8ae69200-2049-11eb-8d30-520a221816bc.png" /></p>

<p>자세히 보면 p1을 제외한 앞 부분은 N=3일 때와 같은 경우라는 것을 알 수 있다.</p>

<p>즉, 맨 마지막 카드로 p1을 뽑았을 때의 D[4]은 D[4] = D[3] + p1 이 된다.</p>

<p>이와 마찬가지로 맨 마지막 카드가 p2, p3, p4일 경우 각각은</p>

<ul>
  <li>
    <p>D[4] = D[3] + p1</p>
  </li>
  <li>
    <p>D[4] = D[2] + p2</p>
  </li>
  <li>
    <p>D[4] = D[1] + p3</p>
  </li>
  <li>
    <p>D[4] = D[0] + p4 (식의 일관성을 위해 D[0]을 추가했고, D[0] = 0 이라고 생각하자.)</p>
  </li>
</ul>

<p>가 된다.</p>

<p>따라서 최종 답인 D[N] 은 Max((D[3] + p1), (D[2] + p2), (D[1] + p3), (D[0] + p4)) 이다!</p>

<p>즉, 이것을 일반화시켜 점화식 형태로 나타내면 뽑아야 하는 카드의 개수가 N 일 때,</p>

<p><img width="350" alt="16" src="https://user-images.githubusercontent.com/31889335/98338079-f120e400-204c-11eb-86aa-4547f2260ec1.png" /></p>

<p>이렇게 나타낼 수 있다!</p>

<p>이 문제를 맨 처음부터 위와 같이 마지막에 뽑히는 카드에 따라 경우가 나뉘어지는 것을 빨리 생각해내지 못할 수도 있다.</p>

<p>이런 경우 dp 문제인지 빠르게 확인하는 방법은(나 스스로 내린 방법이다,,,😂) D[1], D[2] 등의 값을 구해보고 이 값들을 계속 사용해도 그 다음 값인 D[3], D[4]… 의 값을 구하는데 그대로 사용되는지 먼저 확인해보는 것! (아직 dp 문제를 많이 풀어보지 않아서 이 방법이 먹히는지는 잘 모르겠다ㅠ)</p>

<p>그럼 위에서 알아본 점화식을 가지고 bottom - top 방식으로 코드를 작성해보자.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 언어 : kotlin
</span><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">T</span> <span class="p">=</span> <span class="n">readLine</span><span class="p">()</span><span class="o">!!</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">ps</span> <span class="p">=</span> <span class="n">arrayListOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;()</span>
    <span class="n">ps</span><span class="p">.</span><span class="n">add</span><span class="p">(-</span><span class="m">1</span><span class="p">)</span> <span class="c1">// index 1부터 사용하기 위해 index 0 은 안씀 처리
</span>    <span class="n">ps</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">readLine</span><span class="p">()</span><span class="o">!!</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">" "</span><span class="p">).</span><span class="n">map</span><span class="p">{</span><span class="n">it</span><span class="p">.</span><span class="n">toInt</span><span class="p">()})</span>
    <span class="n">BJ_11052</span><span class="p">().</span><span class="n">solution</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">BJ_11052</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">solution</span><span class="p">(</span><span class="n">ps</span><span class="p">:</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">d</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">1001</span><span class="p">){</span><span class="m">0</span><span class="p">}</span>
        <span class="n">d</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">0</span>
        <span class="n">d</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">ps</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>

        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">2</span><span class="o">..</span><span class="n">ps</span><span class="p">.</span><span class="n">size</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="py">max</span> <span class="p">=</span> <span class="m">0</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="m">1</span><span class="o">..</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">val</span> <span class="py">tmp</span> <span class="p">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span><span class="p">(</span><span class="n">max</span> <span class="p">&lt;</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">max</span> <span class="p">=</span> <span class="n">tmp</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">max</span>
        <span class="p">}</span>

        <span class="n">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">ps</span><span class="p">.</span><span class="n">size</span><span class="p">-</span><span class="m">1</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

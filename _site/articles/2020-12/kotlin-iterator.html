<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  🙋🏻‍♀️ 프롤로그  자료구조 Linked List에 대해 공부한 후, 백준 - 1406 에디터 문제를 풀어봤다.  그런데 계속 시간초과가 나서 다른 사람들 코드를 보았더니 Stack으로 풀거나 Iterator를 사용해야 시간 안에 풀린다는 것을 알게 되었다!  나도 한 번 I...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[Kotlin] 코틀린의 Iterator | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[Kotlin] 코틀린의 Iterator | choheeis">
  <meta name="twitter:description" content="  🙋🏻‍♀️ 프롤로그  자료구조 Linked List에 대해 공부한 후, 백준 - 1406 에디터 문제를 풀어봤다.  그런데 계속 시간초과가 나서 다른 사람들 코드를 보았더니 Stack으로 풀거나 Iterator를 사용해야 시간 안에 풀린다는 것을 알게 되었다!  나도 한 번 I...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-12/kotlin-iterator">
  <meta property="og:title" content="[Kotlin] 코틀린의 Iterator | choheeis">
  <meta property="og:description" content="  🙋🏻‍♀️ 프롤로그  자료구조 Linked List에 대해 공부한 후, 백준 - 1406 에디터 문제를 풀어봤다.  그런데 계속 시간초과가 나서 다른 사람들 코드를 보았더니 Stack으로 풀거나 Iterator를 사용해야 시간 안에 풀린다는 것을 알게 되었다!  나도 한 번 I...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[Kotlin] 코틀린의 Iterator | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-12/kotlin-iterator">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[Kotlin] 코틀린의 Iterator">[Kotlin] 코틀린의 Iterator</h1>
    <span class="post-meta">
      <span class="post-date">
        12 DEC 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    8 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p><strong>🙋🏻‍♀️ 프롤로그</strong></p>

  <p>자료구조 Linked List에 대해 공부한 후, <a href="https://www.acmicpc.net/problem/1406">백준 - 1406 에디터</a> 문제를 풀어봤다.</p>

  <p>그런데 계속 시간초과가 나서 다른 사람들 코드를 보았더니 Stack으로 풀거나 Iterator를 사용해야 시간 안에 풀린다는 것을 알게 되었다!</p>

  <p>나도 한 번 Iterator를 사용해서 풀어보기 위해 코틀린의 Iterator에 대해 공부하게 되었다.</p>
</blockquote>

<h2 id="0️⃣-collection에-대해서-먼저-알아오세요">0️⃣ Collection에 대해서 먼저 알아오세요~!</h2>

<p>Iterator 라는 것을 알아보기 위해서는 <a href="https://choheeis.github.io/newblog//articles/2020-10/kotlinCollection">코틀린의 Collection</a> 에 대한 이해가 필요하다!</p>

<h2 id="1️⃣-iterator이-무엇인가">1️⃣ Iterator이 무엇인가?!</h2>

<p>✍🏻 <a href="https://choheeis.github.io/newblog//articles/2020-10/kotlinCollection">kotlin 도큐먼트 - Iterators</a> 를 참고하여 작성합니다.</p>

<p>Iterator은 Collection 개념에 속하는 자료구조들의 원소들을 순회할 때 공통적으로 사용할 수 있는 녀석이다.</p>

<p>다시 말해 Collection 개념에 속하는 자료구조들은 ArrayList, Map, Set 등 다양한데 이 자료구조들의 원소를 순회할 때 공통적으로 사용할 수 있는게 Iterator 라는 것이다!</p>

<p>따라서 Collection 개념에 속하는 자료구조들의 원소를 각각 하나 하나 탐색하거나 출력해야 할 때, 원소들의 값을 업데이트 해야 할 때 사용하면 유용하다.</p>

<p>Iterator는 <a href="https://choheeis.github.io/newblog//articles/2020-12/kotlin-stdlib">코틀린 Standard Library</a> 에서 제공하고 있어서 필요할 때 가져다 사용하면 된다.</p>

<p>Iterator의 개념적인 부분을 알아보았으니 좀 더 코드적인(?) 부분을 알아보자!</p>

<h2 id="2️⃣-iterator-사용법">2️⃣ Iterator 사용법</h2>

<p>Collection 자료구조의 원소 순회에 사용할 수 있는 Iterator를 사용하려면 어떻게 해야할까?</p>

<p>먼저 Iterator가 어디에 구현되어 있는지 알아야 한다.</p>

<p>Iterator는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/">Iterable 인터페이스</a> 를 구현하고 있는 자료구조 클래스에 구현되어 있다.</p>

<p><a href="https://choheeis.github.io/newblog//articles/2020-10/kotlinCollection">코틀린의 Collection</a> 을 읽어보고 왔다면 위 말이 이해될 것이다.</p>

<p><img width="652" alt="06" src="https://user-images.githubusercontent.com/31889335/102019594-c9ddd500-3db7-11eb-8c78-6da60c20b0b9.png" /></p>

<p>위 다이얼로그를 보면 Iterable 인터페이스를 상속하는 인터페이스는 List 인터페이스와 Set 인터페이스이다.</p>

<p>따라서 Collection 개념에 속하는 자료구조 중 List 인터페이스와 Set 인터페이스를 구현하고 있는 자료구조는 대부분 Iterator를 구현하고 있을 것이다.</p>

<p>구현되어 있는 Iterator는 <strong><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator.html">iterator()</a></strong> 라는 함수를 호출함으로써 사용할 수 있다.</p>

<p>iterator()를 호출하면 Iterator가 생성되고 해당 자료구조의 첫 번째 원소를 가리키게 된다.</p>

<p><img width="651" alt="07" src="https://user-images.githubusercontent.com/31889335/102019845-05c56a00-3db9-11eb-94cd-18cac4f3be07.png" /></p>

<p>이 상태에서 <strong><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/next.html">next()</a></strong> 라는 함수를 호출하면 Iterator가 가리키고 있던 원소의 값을 return 하고, Iterator는 그 다음 원소를 가리키게 된다.</p>

<p><img width="614" alt="08" src="https://user-images.githubusercontent.com/31889335/102019878-3ad1bc80-3db9-11eb-9e80-149ea14eaa39.png" /></p>

<p>next() 함수를 호출하기 전에 Iterator가 가리킬 다음 원소가 존재하는지 여부를 체크해야 한다면 <strong>hasNext()</strong> 라는 함수를 사용하면 된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. 리스트 자료구조 생성
</span>    <span class="kd">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
    <span class="c1">// 2. Iterator 생성
</span>    <span class="kd">val</span> <span class="py">iterator</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">iterator</span><span class="p">()</span>
    <span class="c1">// 3. 각 원소 출력
</span>    <span class="k">while</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img width="28" alt="09" src="https://user-images.githubusercontent.com/31889335/102020446-a6695900-3dbc-11eb-969e-26165c502f3d.png" /></p>

<p>위 코드의 출력 결과는 위와 같다.</p>

<p>이렇게 Iterator를 사용해서 Collection 개념에 속하는 자료구조들의 원소를 순회할수도 있지만 코틀린에서는 이와 똑같은 다른 방법이 존재한다.</p>

<p>바로 <strong>for문</strong> 을 이용하는 것이다.</p>

<p>Collection 개념에 속하는 자료구조들에 for문을 사용하면 <strong>암묵적으로 Iterator</strong> 를 사용하는 것과 같다.</p>

<p>따라서 아래 코드는 위의 iterator() 를 사용한 코드와 동일하게 동작한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img width="28" alt="09" src="https://user-images.githubusercontent.com/31889335/102020446-a6695900-3dbc-11eb-969e-26165c502f3d.png" /></p>

<p>출력 결과는 위와 같다.</p>

<p>마지막으로 <strong>forEach()</strong>  함수를 사용하는 것도 Iterator를 사용하는 것과 동일하다.</p>

<p>forEach() 함수는 해당 자료구조의 원소를 처음부터 마지막 원소까지 자동으로 순회하고, forEach문에 작성된 코드를 각 원소에 적용시킨다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
    <span class="n">list</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> 
        <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img width="28" alt="09" src="https://user-images.githubusercontent.com/31889335/102020446-a6695900-3dbc-11eb-969e-26165c502f3d.png" /></p>

<p>출력 결과는 위와 같다.</p>

<h2 id="3️⃣-심화된-iterator인-listiterator">3️⃣ 심화된 Iterator인 ListIterator!</h2>

<p>코틀린에는 Collection 개념에 속하는 자료구조 중 특별히 <strong>List형 자료구조</strong> 에 사용할 수 있는 Iterator인 <strong><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list-iterator/">ListIterator</a></strong> 이 존재한다.</p>

<blockquote>
  <p>List형 자료구조에 대해서는 <a href="https://choheeis.github.io/newblog//articles/2020-10/kotlinList">이 블로그의 다른 포스팅 - 코틀린의 List형 자료구조</a> 를 읽어보면 알 수 있을 것이다.</p>
</blockquote>

<p>ListIterator는 List형 자료구조들이 구현하고 있는 인터페이스이기 때문에 List형 자료구조에서만 사용할 수 있다.</p>

<p>ListIterator는 <strong>listIterator()</strong> 함수 호출을 통해 생성할 수 있다.</p>

<p>ListIterator가 기존 Iterator와 다른 점에 대해 알아보자.</p>

<p>기존 Iterator는 next() 함수를 호출하면 첫 번째 원소부터 차례대로 그 다음 원소를 가리켰다. 즉, 한쪽으로만 순회하는 단방향이였지만, <strong>ListIterator</strong> 는 <strong>양쪽으로 순회가 가능한 양방향 Iterator</strong> 이다!</p>

<p>따라서 <strong>hasPrevious()</strong> 함수로 이전 원소가 존재하는지 확인할 수 있고, next() 함수와 같은 기능을 하지만 Iterator가 가리키는 방향이 반대인 <strong>previous()</strong> 함수가 존재한다.</p>

<p>또한 ListIterator는 <strong>nextIndex()</strong> 와 <strong>previousIndex()</strong> 라는 함수가 추가로 존재하여 index까지 확인할 수 있는 기능이 추가되었다.</p>

<p>기존의 Iterator는 인덱스를 확인할 수 없었다.</p>

<p>더불어 원칙은 listIterator() 함수를 호출해 ListIterator를 생성하면 가장 첫 번째 원소를 가리키게 되지만 <strong><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/list-iterator.html">listIterator(index)</a></strong> 를 호출하여 ListIterator를 생성하면 원하는 index부터 가리키도록 생성할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">listIterator</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">listIterator</span><span class="p">()</span>

    <span class="n">println</span><span class="p">(</span><span class="s">"Iterator이 증가하는 방향으로 출력하기!"</span><span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="n">listIterator</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">listIterator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="n">println</span><span class="p">(</span><span class="s">"Iterator이 감소하는 방향으로 출력하기!"</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">listIterator</span><span class="p">.</span><span class="n">hasPrevious</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">listIterator</span><span class="p">.</span><span class="n">previous</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드의 출력 결과는</p>

<p><img width="263" alt="10" src="https://user-images.githubusercontent.com/31889335/102021008-3066f100-3dc0-11eb-9900-b4c3259d98b2.png" /></p>

<p>이와 같다.</p>

<h2 id="4️⃣-심화된-iterator인-mutableiterator">4️⃣ 심화된 Iterator인 MutableIterator!</h2>

<p><a href="https://choheeis.github.io/newblog//articles/2020-10/kotlinCollection">이 블로그의 다른 포스팅 - 코틀린의 Collection</a> 을 읽어봤다면 mutable 특징을 가진 인터페이스에 대해서도 알게 되었을 것이다.</p>

<p>코틀린의 Iterator에는 Collection 개념에 속하는 자료구조 중 mutable 특징을 가진 인터페이스를 구현하는 자료구조에 특화된 <strong><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-iterator/">MutableIterator</a></strong> 라는 것도 존재한다!</p>

<p>MutableIterator은 위에서 알아본 다른 Iterator들과 다른 특징이 하나 있다.</p>

<p>바로 <strong>remove()</strong> 함수를 통해 해당 자료구조의 원소를 제거할 수도 있다는 점이다. (mutable 특징을 가진 인터페이스를 구현한 자료구조는 원소를 제거할 수 있기 때문!)</p>

<p>이 때, 알아두어야 할 것은 MutableIterator은 따로 생성하는 함수가 존재하는 것이 아니라 mutable한 자료구조의 iterator() 함수를 호출하면 자동으로 MutableIterator 이 호출되어 remove() 함수를 사용할 수 있게 된다는 것이다.</p>

<p><strong>remove() 함수</strong> 는 <strong>next() 함수에 의해 가장 마지막으로 반환된 원소를 삭제</strong> 한다.</p>

<p>이를 아래 코드를 통해 알아보자.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. mutable한 리스트 생성
</span>    <span class="kd">val</span> <span class="py">mutableList</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;()</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>

    <span class="c1">// 2. Iterator 생성(첫 번째 원소 가리킴)
</span>    <span class="kd">val</span> <span class="py">mutableIterator</span> <span class="p">=</span> <span class="n">mutableList</span><span class="p">.</span><span class="n">iterator</span><span class="p">()</span>
    <span class="n">mutableIterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">mutableIterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span>

    <span class="c1">// 3. 가장 마지막으로 반환된 두 번째 원소를 삭제
</span>    <span class="n">mutableIterator</span><span class="p">.</span><span class="n">remove</span><span class="p">()</span>

    <span class="c1">// 4. 새로운 Iterator를 생성하여 처음부터 순회하며 출력
</span>    <span class="kd">val</span> <span class="py">newIterator</span> <span class="p">=</span> <span class="n">mutableList</span><span class="p">.</span><span class="n">iterator</span><span class="p">()</span>
    <span class="k">while</span><span class="p">(</span><span class="n">newIterator</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">newIterator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드의 출력 결과는</p>

<p><img width="26" alt="11" src="https://user-images.githubusercontent.com/31889335/102022897-24cdf700-3dcd-11eb-836e-423b44e0ae24.png" /></p>

<p>위와 같다.</p>

<p>추가적으로 mutable한 자료 구조의 Iterator를 생성할 때 listIterator() 함수를 통해 ListIterator를 생성하면 remove() 함수 외에도 <strong>add()</strong> 함수를 통해 새로운 원소를 추가할 수 있고, <strong>set()</strong> 함수를 통해 기존의 원소 값을 변경할 수도 있게 된다.</p>

<p><strong>add()</strong> 함수는 Iterator가 add() 함수 호출 시 가리키고 있는 원소의 <strong>이전 위치에 새로운 원소를 추가 하고 Iterator가 추가한 원소를 가리키게</strong> 한다.</p>

<p><strong>set()</strong> 함수는 Iterator가 set() 함수 호출 시 가리키고 있는 원소의 <strong>데이터를 변경</strong> 한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. mutable한 리스트 생성 후 원소 추가
</span>    <span class="kd">val</span> <span class="py">mutableList</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;()</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>

    <span class="c1">// 2. listIterator 생성
</span>    <span class="kd">val</span> <span class="py">mutableIterator</span> <span class="p">=</span> <span class="n">mutableList</span><span class="p">.</span><span class="n">listIterator</span><span class="p">()</span>

    <span class="c1">// 3. Iterator가 두 번째 원소를 가리키도록 하기
</span>    <span class="n">mutableIterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span>

    <span class="c1">// 4. 두 번째 원소 앞에 새로운 원소 추가하고 Iterator가 추가한 원소 가리키게 하기
</span>    <span class="n">mutableIterator</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">4</span><span class="p">)</span>
    <span class="n">mutableIterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">mutableIterator</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>

    <span class="kd">val</span> <span class="py">newIterator</span> <span class="p">=</span> <span class="n">mutableList</span><span class="p">.</span><span class="n">iterator</span><span class="p">()</span>
    <span class="k">while</span><span class="p">(</span><span class="n">newIterator</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">newIterator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드의 출력 결과는</p>

<p><img width="32" alt="12" src="https://user-images.githubusercontent.com/31889335/102023201-1f71ac00-3dcf-11eb-9d32-a01bd1362710.png" /></p>

<p>위와 같다.</p>

<h2 id="5️⃣-iterator가-존재하는-이유">5️⃣ Iterator가 존재하는 이유?</h2>

<p><a href="https://choheeis.github.io/newblog//articles/2020-10/kotlinList">이 블로그의 다른 포스팅 - 코틀린의 List형 자료구조</a>를 읽어보고 오자.</p>

<p>읽어보고 왔다면 코틀린의 List 인터페이스를 구현하는 자료구조는 index를 통한 접근이 가능하다는 것을 알게 되었을 것이다.</p>

<p>따라서 사실 위에서 본 코드에 사용된 list, mutableList 자료구조들은 모두 List 인터페이스를 구현하고 있기 때문에 index를 통해 접근이 가능하다.</p>

<p>다음 코드가 가능하다는 것이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">mutableList</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;()</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
    <span class="n">mutableList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>

    <span class="c1">// 인덱스를 통한 접근 및 원소 변경 가능
</span>    <span class="n">println</span><span class="p">(</span><span class="n">mutableList</span><span class="p">[</span><span class="m">2</span><span class="p">])</span>
    <span class="n">mutableList</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">10</span>
    <span class="n">println</span><span class="p">(</span><span class="n">mutableList</span><span class="p">[</span><span class="m">2</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img width="32" alt="13" src="https://user-images.githubusercontent.com/31889335/102023599-16cda580-3dd0-11eb-853a-04e97c4d35f4.png" /></p>

<p>위 코드의 출력 결과는 위와 같다.</p>

<p>하지만 <a href="https://choheeis.github.io/newblog//articles/2020-12/data-structure-linked-list">이 블로그의 다른 포스팅 - 2. LinkedList</a> 에서 알 수 있듯이, List형 자료구조의 원소에 인덱스로 접근하게 되면 무조건 맨 첫 번째 원소부터 차례대로 방문해서 찾기 때문에 <strong>O(N)</strong> 의 시간복잡도가 걸리게 된다.</p>

<p>그러나 인덱스를 통한 접근 대신 <strong>Iterator</strong> 를 통한 접근을 하면 next(), previous() 함수를 통해 이전 원소 및 다음 원소에 바로 접근할 수 있게 된다.</p>

<p>즉, next(), previous() 함수는 맨 처음 원소부터 방문하지 않는다는 의미이다.</p>

<p>따라서 인덱스를 통한 접근보다 빠른 시간 내에 원소를 순회할 수 있게 된다!</p>

<h1 id="끝">끝!</h1>

  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

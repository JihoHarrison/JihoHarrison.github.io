<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="자료구조의 개념과 간략한 설명에 대해서는 이 블로그의 다른 포스팅 - 꼭 알아두어야 할 자료구조 에서 볼 수 있다.✍🏻 바킹독 실전 알고리즘 강의 - 4강 연결 리스트편 을 참고하여 작성합니다.1️⃣ Linked List(연결 리스트)의 형태이 블로그의 다른 포스팅 - 1. Arr...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[자료구조] 2. Linked List(연결 리스트) | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[자료구조] 2. Linked List(연결 리스트) | choheeis">
  <meta name="twitter:description" content="자료구조의 개념과 간략한 설명에 대해서는 이 블로그의 다른 포스팅 - 꼭 알아두어야 할 자료구조 에서 볼 수 있다.✍🏻 바킹독 실전 알고리즘 강의 - 4강 연결 리스트편 을 참고하여 작성합니다.1️⃣ Linked List(연결 리스트)의 형태이 블로그의 다른 포스팅 - 1. Arr...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-12/data-structure-linked-list">
  <meta property="og:title" content="[자료구조] 2. Linked List(연결 리스트) | choheeis">
  <meta property="og:description" content="자료구조의 개념과 간략한 설명에 대해서는 이 블로그의 다른 포스팅 - 꼭 알아두어야 할 자료구조 에서 볼 수 있다.✍🏻 바킹독 실전 알고리즘 강의 - 4강 연결 리스트편 을 참고하여 작성합니다.1️⃣ Linked List(연결 리스트)의 형태이 블로그의 다른 포스팅 - 1. Arr...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[자료구조] 2. Linked List(연결 리스트) | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-12/data-structure-linked-list">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[자료구조] 2. Linked List(연결 리스트)">[자료구조] 2. Linked List(연결 리스트)</h1>
    <span class="post-meta">
      <span class="post-date">
        9 DEC 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    5 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <p>자료구조의 개념과 간략한 설명에 대해서는 <a href="https://choheeis.github.io/newblog//articles/2019-07/BasicDataStructure">이 블로그의 다른 포스팅 - 꼭 알아두어야 할 자료구조</a> 에서 볼 수 있다.</p>

<p>✍🏻 <a href="https://blog.encrypted.gg/932?category=773649">바킹독 실전 알고리즘 강의 - 4강 연결 리스트편</a> 을 참고하여 작성합니다.</p>

<h2 id="1️⃣-linked-list연결-리스트의-형태">1️⃣ Linked List(연결 리스트)의 형태</h2>

<p><a href="https://choheeis.github.io/newblog//articles/2020-12/data-structure-array">이 블로그의 다른 포스팅 - 1. Array(배열)</a> 을 보고 왔다면 배열이 연속된 메모리 상에 데이터를 저장한다는 것을 알고 있을 것이다.</p>

<p>하지만 <strong>Linked List(연결 리스트)</strong> 는 배열과 다르게 <strong>데이터를 메모리 상의 이곳 저곳에 연속되지 않게 저장한다.</strong> 이 때, 각 원소는 다음 원소의 메모리 주소를 함께 저장하고 있다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/61359643-b8895400-a8b7-11e9-89bc-44f64bd6213d.PNG" alt="단방향리스트" /></p>

<p>Linked List(연결 리스트)의 맨 첫 번째 원소의 위치만 알고 있어도 나머지 원소들의 위치는 각 원소에 저장되어 있으므로 결국 모든 원소의 위치를 알 수 있게 되는 것이다.</p>

<p>따라서 Linked List(연결 리스트)는 메모리 상에 데이터가 연속적이지는 않지만 각 원소가 어디에 위치해 있는지 알 수 있다.</p>

<p>Linked List(연결 리스트)의 종류에는 단방향 연결 리스트(Singly Linked List), 이중 연결 리스트(Doubly Linked List), 원형 연결 리스트(Circular Linked List) 가 있다.</p>

<p>각각에 대해서는 이 포스팅을 끝까지 읽어보면 알게 될 것이다.</p>

<h2 id="2️⃣-linked-list연결-리스트의-특징">2️⃣ Linked List(연결 리스트)의 특징</h2>

<ol>
  <li><strong>원소들이 메모리 상에 연속되어 있지 않아 Cache hit rate가 낮지만 할당이 다소 쉽다.</strong></li>
</ol>

<blockquote>
  <p>위 성질은 다음에 알아보고 보충하자.</p>
</blockquote>

<h2 id="3️⃣-linked-list연결-리스트에서-사용할-수-있는-연산들">3️⃣ Linked List(연결 리스트)에서 사용할 수 있는 연산들</h2>

<ol>
  <li>
    <p><strong>임의의 위치에 있는 원소를 확인하거나 변경하는 연산 : O(N)의 시간이 걸림</strong></p>

    <p><img width="929" alt="01" src="https://user-images.githubusercontent.com/31889335/101609142-f2796e00-3a49-11eb-8f07-db9d06db913a.png" /></p>

    <p>만약 위 그림에서 20을 저장하고 있는 원소를 확인하고 싶다면 20을 저장하는 원소의 위치를 알아야 할 것이다.</p>

    <p>이 위치를 어떻게 알 수 있을까?</p>

    <p>가장 먼저 첫 번째 원소인 10을 저장하고 있는 원소를 방문해서 다음 원소인 5가 존재하는 위치를 확인해야 한다.(연결 리스트를 사용할 때는 가장 첫 번째 원소의 위치만 알고 있게 된다.)</p>

    <p>확인 후, 5를 저장하는 원소를 찾아가 방문한다.</p>

    <p>5를 저장하는 원소를 통해 4를 저장하는 원소의 위치를 알게 되고, 4를 저장하는 원소를 찾아가 방문한다.</p>

    <p>4를 저장하는 원소를 통해 비로소 20을 저장하는 원소의 위치를 알게 되어 20에 찾아갈 수 있다.</p>

    <p><a href="https://choheeis.github.io/newblog//articles/2020-12/data-structure-array">이 블로그의 다른 포스팅 - 1. Array(배열)</a> 를 보면 배열에서 k번째 원소를 확인하거나 변경하기 위해서는 간단한 주소값 관련 사칙연산 계산만 하면 되므로 O(1)이 걸린다는 것을 알 수 있을 것이다.</p>

    <p>하지만 Linked List(연결 리스트)는 배열과 다르게 k번째 원소의 위치를 알아내기 위해서는 원소를 타고 타고 방문해야 k번째 원소의 위치를 알 수 있기 때문에 O(k)의 시간이 걸린다.</p>

    <p>이 과정을 통해 k번째 원소가 있는 위치에 도착했다면 해당 원소의 data를 확인하거나 변경하면 된다.</p>
  </li>
  <li>
    <p><strong>임의의 위치에 원소를 추가하는 연산 : O(1)의 시간이 걸림</strong></p>

    <p>임의의 위치에 원소를 추가하려면 추가할 원소를 메모리의 어느 위치에 저장한 후, 이전 원소가 가지고 있던 다음 원소 주소를 방금 추가한 원소의 위치로 바꿔주면 된다.</p>

    <p><img width="925" alt="04" src="https://user-images.githubusercontent.com/31889335/101613779-81d55000-3a4f-11eb-825b-7e52f2aae199.png" /></p>

    <p>위 그림처럼 기존에 저장하고 있던 다음 원소 위치를 새로 추가한 원소의 위치로 업데이트 해주기만 하면 되므로 O(1)의 시간이 걸린다.</p>

    <p>단, O(1)이 시간이 걸린다는 것은 O(N)에 걸려 추가할 원소의 바로 이전 원소까지 방문된 상태에서 이 원소의 주소 값만 없데이트 하는데 O(1)이 걸린다는 것이다.</p>

    <p>따라서 Linked List에 사용되는 함수 중 add(임의의 위치) 함수는 결과적으로 O(N)이 걸릴 것이다.</p>
  </li>
  <li>
    <p><strong>임의의 위치에 있는 원소를 제거하는 연산 : O(1)의 시간이 걸림</strong></p>

    <p>임의의 위치에 있는 원소를 제거하려면 원소를 제거한 후, 이전 원소가 가지고 있던 다음 원소 주소를 제거한 원소의 다음 원소 주소로 업데이트 해주면 된다.</p>

    <p><img width="930" alt="05" src="https://user-images.githubusercontent.com/31889335/101614566-76365900-3a50-11eb-9c9b-af9917b98de3.png" /></p>

    <p>위 그림처럼 기존에 저장하고 있던 다음 원소 위치를 제거한 원소의 다음 원소 위치로 업데이트 해주기만 하면 되므로 O(1)의 시간이 걸린다.</p>

    <p>단, O(1)이 시간이 걸린다는 것은 O(N)에 걸려 제거할 원소의 바로 이전 원소까지 방문된 상태에서 이 원소의 주소 값만 없데이트 하는데 O(1)이 걸린다는 것이다.</p>

    <p>따라서 Linked List에 사용되는 함수 중 remove(임의의 위치) 함수는 결과적으로 O(N)이 걸릴 것이다.</p>
  </li>
</ol>

<h2 id="4️⃣-linked-list연결-리스트의-종류">4️⃣ Linked List(연결 리스트)의 종류</h2>

<ol>
  <li>
    <p><strong>단일 연결 리스트(Singly Linked List)</strong></p>

    <p>단일 연결 리스트는 <strong>각 원소가 자신의 다음 원소의 주소를 저장하고 있는 연결 리스트</strong> 이다.</p>

    <p><img width="929" alt="01" src="https://user-images.githubusercontent.com/31889335/101609142-f2796e00-3a49-11eb-8f07-db9d06db913a.png" /></p>
  </li>
  <li>
    <p><strong>이중 연결 리스트(Doubly Linked List)</strong></p>

    <p>이중 연결 리스트는 <strong>각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 저장하고 있는 연결 리스트</strong> 이다.</p>

    <p><img width="939" alt="02" src="https://user-images.githubusercontent.com/31889335/101610931-379e9f80-3a4c-11eb-9232-5f6f460c32ba.png" /></p>

    <p>단일 연결 리스트에서는 각 원소의 다음 위치만 알아낼 수 있지만 이중 연결 리스트를 사용하면 각 원소의 이전 위치까지 알아낼 수 있다.</p>

    <p>하지만 각 원소각 이전 위치까지 저장해야 하므로 메모리를 단일 연결 리스트보다 더 사용한다는 단점이 있다.</p>
  </li>
  <li>
    <p><strong>원형 연결 리스트(Circular Linked List)</strong></p>

    <p>원형 연결 리스트는 <strong>가장 마지막 원소가 맨 처음 원소의 주소를 저장하고 있는 연결 리스트</strong> 이다.</p>

    <p>즉, 맨 끝과 맨 처음이 연결되어 있는 형태이다.</p>

    <p><img width="935" alt="03" src="https://user-images.githubusercontent.com/31889335/101611405-cf9c8900-3a4c-11eb-9f64-1b25a0153e22.png" /></p>
  </li>
</ol>

<h2 id="5️⃣-array배열과-linked-list연결-리스트의-공통점과-차이점">5️⃣ Array(배열)과 Linked List(연결 리스트)의 공통점과 차이점</h2>

<ul>
  <li>
    <p><strong>공통점</strong></p>

    <p>배열과 연결 리스트는 원소들이 메모리 상에 저장되는 형태가 다르지만 어쨌든 둘 다 원소들 간의 선후 관계가 일대일로 명확한 자료구조이다.</p>

    <p>즉, 원소들 사이에서 첫 번째 원소, 두 번째 원소, … 등의 개념이 존재한다는 것이다.</p>

    <p>이러한 자료구조를 <strong>선형 자료구조</strong> 라고 부르고 배열과 연결 리스트는 둘 다 선형 자료구조이다.</p>
  </li>
  <li>
    <p><strong>차이점</strong></p>

    <ul>
      <li>
        <p>임의의 원소(k번째 원소)에 접근하여 데이터 확인 및 변경하는데 걸리는 시간복잡도</p>

        <ul>
          <li>
            <p>배열 : <strong>O(1)</strong></p>
          </li>
          <li>
            <p>연결 리스트 : <strong>O(k)</strong></p>
          </li>
        </ul>
      </li>
      <li>
        <p>임의의 위치에 원소를 추가하거나 임의의 위치에 있는 원소를 제거하는데 걸리는 시간복잡도</p>

        <ul>
          <li>
            <p>배열 : <strong>O(k)</strong></p>
          </li>
          <li>
            <p>연결 리스트 : <strong>O(1)</strong></p>
          </li>
        </ul>
      </li>
      <li>
        <p>메모리 상의 배치</p>

        <ul>
          <li>
            <p>배열 : 연속적으로 배치</p>
          </li>
          <li>
            <p>연결 리스트 : 비연속적으로 배치</p>
          </li>
        </ul>
      </li>
      <li>
        <p>추가 메모리 필요성</p>

        <ul>
          <li>
            <p>배열 : 추가 메모리 없음</p>
          </li>
          <li>
            <p>연결 리스트 : 이전/다음 원소의 위치 주소를 저장할 추가 메모리가 N(원소의 개수)에 비례한 만큼 필요함</p>
          </li>
        </ul>
      </li>
      <li>
        <p>언제 사용할까?</p>

        <ul>
          <li>
            <p>배열 : 배열에 저장된 원소를 빠르게 찾아야 하는 경우</p>
          </li>
          <li>
            <p>연결 리스트 : 중간 중간에 원소를 새로 추가하거나 제거해야 하는 작업이 많은 경우</p>

            <p>주로 메모장같은 에디터 프로그램에서 많이 사용된다. 사용자가 입력한 문자열은 언제든지 사용자가 커서를 옮겨 문자를 삭제하거나 추가할 수 있도록 해야하기 때문이다.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="6️⃣-linked-list연결-리스트의-장단점">6️⃣ Linked List(연결 리스트)의 장단점</h2>

<p>앞에서 알아본 내용들을 종합하여 Linked List(연결 리스트)의 장점 및 단점에 대해 정리해보자.</p>

<ul>
  <li>
    <p><strong>장점</strong></p>

    <ul>
      <li>
        <p>새로운 원소를 삽입/삭제하는데 시간이 빠르다.</p>
      </li>
      <li>
        <p>연속적인 메모리 할당이 필요하지 않다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>단점</strong></p>

    <ul>
      <li>
        <p>임의의 위치에 있는 원소를 확인하려면 첫 번째 원소부터 확인해야 하기 때문에 속도가 느리다.</p>
      </li>
      <li>
        <p>이전 노드 및 다음 노드의 위치를 저장하기 위한 추가 메모리 공간이 필요하다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>연결 리스트를 언제 사용해야 좋을까?</strong></p>

    <ul>
      <li>
        <p>삽입과 삭제 작업이 많을 때 사용하면 좋다.</p>
      </li>
      <li>
        <p>연결 리스트에 저장된 원소를 검색하는 작업이 적을 때 사용하면 좋다.</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="끝">끝!</h1>

  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

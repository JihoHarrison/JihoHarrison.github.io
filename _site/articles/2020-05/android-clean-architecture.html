<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="0️⃣ 안드로이드에서 권장하는 아키텍처가 있다?Android Jetpack이 뭐지?라는 포스팅에서 Jetpack을 이루는 4가지 컴포넌트 중 Architecture 컴포넌트가 있다는 것을 공부했었다.Jetpack에 속하는 컴포넌트 중 Architecture 컴포넌트로 분류되어 있는...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[안드로이드] 🔨 Android Clean Architecture(1탄) | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[안드로이드] 🔨 Android Clean Architecture(1탄) | choheeis">
  <meta name="twitter:description" content="0️⃣ 안드로이드에서 권장하는 아키텍처가 있다?Android Jetpack이 뭐지?라는 포스팅에서 Jetpack을 이루는 4가지 컴포넌트 중 Architecture 컴포넌트가 있다는 것을 공부했었다.Jetpack에 속하는 컴포넌트 중 Architecture 컴포넌트로 분류되어 있는...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-05/android-clean-architecture">
  <meta property="og:title" content="[안드로이드] 🔨 Android Clean Architecture(1탄) | choheeis">
  <meta property="og:description" content="0️⃣ 안드로이드에서 권장하는 아키텍처가 있다?Android Jetpack이 뭐지?라는 포스팅에서 Jetpack을 이루는 4가지 컴포넌트 중 Architecture 컴포넌트가 있다는 것을 공부했었다.Jetpack에 속하는 컴포넌트 중 Architecture 컴포넌트로 분류되어 있는...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[안드로이드] 🔨 Android Clean Architecture(1탄) | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-05/android-clean-architecture">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[안드로이드] 🔨 Android Clean Architecture(1탄)">[안드로이드] 🔨 Android Clean Architecture(1탄)</h1>
    <span class="post-meta">
      <span class="post-date">
        28 MAY 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    8 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <p><br /></p>

<h2 id="0️⃣-안드로이드에서-권장하는-아키텍처가-있다">0️⃣ 안드로이드에서 권장하는 아키텍처가 있다?</h2>

<p><a href="https://choheeis.github.io/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/2020/05/25/jetpack.html">Android Jetpack이 뭐지?</a>라는 포스팅에서 Jetpack을 이루는 4가지 컴포넌트 중 Architecture 컴포넌트가 있다는 것을 공부했었다.</p>

<p>Jetpack에 속하는 컴포넌트 중 Architecture 컴포넌트로 분류되어 있는 라이브러리들에는</p>

<p><img src="https://user-images.githubusercontent.com/31889335/83118033-c8dda280-a108-11ea-9e2e-201751a17ef1.PNG" alt="01" /></p>

<p>이런 것들이 있다!</p>

<p><strong>Jetpack에서 지원하는 이러한 라이브러리들을 사용하여 개발하면 구글에서 권장하는 안드로이드 앱 프로젝트 Architecture를 구성할 수 있다.</strong></p>

<p>구글에서 권장하는 아키텍처는 어떤 구조인지 <a href="https://developer.android.com/jetpack/docs/guide">Android Developer 도큐먼트 - 앱 아키텍처 가이드</a> 문서를 읽어보고 알아보자!</p>

<p>이 문서를 읽어보면 좋은 퀄리티의 강력한 앱을 개발하기 위한 권장 아키텍처가 무엇인지에 대해 알 수 있을 것이다.</p>

<h2 id="1️⃣-모바일-앱-사용자-환경이란">1️⃣ 모바일 앱 사용자 환경이란?</h2>

<p>안드로이드 권장 아키텍처를 본격적으로 살펴보기 전에 <strong>모바일 앱 사용자 환경</strong> 이라는 개념에 대해 살짝 알아보자.</p>

<p>일반적인 Android 앱은 <strong>Activity/Fragment, Service, Content Provider, Broadcast Receiver</strong> 등의 여러 App Component(앱 구성요소) 들로 구성되어 있다.</p>

<p>이것을 <strong>안드로이드 4대 컴포넌트</strong> 라고도 부른다.</p>

<p>개발자는 이러한 앱 구성요소 대부분을 manifest 파일에서 선언하고, Android OS가 이 manifest 파일을 사용하여 기기를 사용하는 사용자의 전반적인 작업 환경을 망가뜨리지 않으면서 앱을 이 환경에 자연스럽게 통합하는 방법을 결정한다.</p>

<p>여기서 말하는 <strong>사용자의 전반적인 작업 환경(모바일 앱 사용자 환경)</strong> 이란 무엇을 의미하는 것일까?</p>

<p>Android 앱을 사용하는 유저는 짧은 시간 내에 여러 앱을 실행할 때가 많다.</p>

<p><strong>따라서 앱이 사용자 중심의 다양한 workflow에 맞게 조정될 수 있어야 한다.</strong></p>

<p>예를 들어, 사용자가 SNS 앱에서 사진을 업로드 하는 과정에 대해 생각해보자.</p>

<p>SNS 앱은 가장 먼저 카메라 인텐트를 트리거할 것이다. 그러면 Android OS에서 이 요청에 따라 카메라 앱을 실행시킨다.</p>

<p>이 순간, 사용자는 카메라 앱으로 이동하게 되면서 SNS 앱에서는 나간 상황이 되지만 사용자의 작업 환경은 끊김없이 연결되어 있는 상태라고 볼 수 있다.</p>

<p>그 다음, 카메라 앱에서 앨범을 보기 위해 앨범 인텐트를 트리거할 수도 있다.</p>

<p>이 후에는 사용자가 다시 SNS 앱으로 돌아가서 앨범에서 선택한 사진이나 카메라 앱으로 직접 찍은 사진을 업로드할 것이다.</p>

<p>또 심지어는 <strong>이 과정에서 전화나 알림에 의해 사용 환경의 흐름이 끊어질 수도 있다.</strong></p>

<p>사용자는 이러한 흐름 중단에 대응하고 난 후, 다시 SNS 앱으로 돌아가 하고 있던 작업을 계속 이어서 하길 원할 것이다.</p>

<p>이와 같이 <strong>사용자는 모바일 환경에서 다양한 앱을 시도 때도 없이 바꾸기도 하고, 전화나 알림 등의 작업도 동시에 하기 때문에 앱에서 이러한 사용자 흐름이 중단되지 않고 자연스럽게 흘러가도록 올바르게 처리해야</strong> 한다.</p>

<p>이 뿐만 아니라 모바일 기기는 하드웨어 자원(메모리 등)이 제한되어 있으므로 메모리 부족으로 인한 사용자 흐름 중단이 발생할 수도 있다.</p>

<p>이에 대비하여 안드로이드 OS는 메모리 공간이 부족할 경우 ‘일시정지됨’ 상태에 있는 앱의 프로세스를 강제 종료함으로써 사용자 작업 흐름을 끊기지 않게 해야한다.</p>

<p>이러한 모바일 환경 조건을 고려해 볼 때 <strong>App Component(앱 구성요소)는 개별적이고 비순차적으로 실행될 수 있으며 Android OS나 사용자가 언제든지 앱 구성요소를 제거</strong> 할 수 있다는 것을 깨닫게 될 것이다!</p>

<p>하지만 개발자는 이러한 이벤트(앱 구성요소가 개별적, 비순차적으로 실행 / OS에 의한 앱 구성요소 제거)를 직접 제어할 수 없다.</p>

<p>따라서 이러한 이벤트가 발생할 것에 대비하여 <strong>앱 구성요소에 앱 데이터나 상태를 저장해서는 안 되며 앱 구성요소가 서로 종속되도록 개발하면 안된다.</strong></p>

<p>앱 구성요소에 앱 데이터나 상태를 저장할 경우, 앱의 강제 종료가 발생하거나 예상치 못한 전화 및 알람이 왔을 경우 저장하고 있던 데이터가 유실될 수 있기 때문이다.</p>

<p>또한 앱 구성요소가 서로 종속된다면 포그라운드에서 동작하는 Activity를 종료했을 경우 백그라운드에서 동작하는 Service도 함께 종료되기 때문이다.</p>

<h2 id="2️⃣-android-clean-architecture-두-가지-원칙">2️⃣ Android Clean Architecture 두 가지 원칙</h2>

<p>위 내용을 통해 <strong>‘앱 구성요소에 앱 데이터와 상태를 저장하면 안됨’</strong> 에 대해 깨닫게 되었을 것이다.</p>

<p><strong>앱 구성요소에 앱 데이터와 상태를 저장하지 않으려면 앱을 어떻게 설계해야 할까?</strong></p>

<p>이 질문에 대한 대답으로 앱을 설계하는데 필수적인 몇 가지 원칙들을 알아보자.</p>

<p><strong>🧚🏻‍♀️ 첫 번째 원칙! “UI 기반 클래스를 가볍게 하라”</strong></p>

<p>이 원칙은 안드로이드 앱 아키텍처 원칙 중 가장 중요한 원칙이다.</p>

<p>안드로이드 초기 개발자들은 Activity나 Fragment에 모든 코드를 작성하는 ‘실수’를 범하기도 한다.</p>

<p>Activity나 Fragment 클래스를 <strong>UI 기반 클래스</strong> 라고 하는데 원칙적으로 <strong>UI 기반 클래스는 UI를 핸들링하거나 안드로이드 OS와 앱의 상호작용을 처리하는 로직만 포함해야 한다.</strong></p>

<p>UI 기반 클래스를 최대한 가볍게 유지해야 많은 수명 주기 관련 문제를 피할 수 있을 것이다.</p>

<p>Activity와 Fragment 클래스는 Android 운영체제와 Application(앱) 사이의 계약을 나타내도록 이어주는 클래스일 뿐이다.</p>

<p><strong>즉, 여러 수명 주기를 제어함으로써 사용자가 어떤 동작을 하더라도 그 흐름이 끊어지지 않도록 해주는 것이 UI 기반 클래스</strong> 라고 생각하면 된다.</p>

<p><strong>따라서 UI 기반 클래스에서는 수명 주기에 따라 발생할 수 있는 상황에 대처하는 코드만 작성하는 것이 좋다.</strong></p>

<p><strong>🧚🏻‍♀️ 두 번째 원칙! “UI와 Model(모델)을 분리하라”</strong></p>

<p>안드로이드 앱 아키텍처 원칙 중 두 번째로 중요한 원칙은 모델과 UI를 분리해야 한다는 것이다.</p>

<p>이 말의 의미는 <strong>UI 기반 클래스에 데이터나 상태를 저장하지 말라</strong> 는 말과 같다.</p>

<p>모델은 <strong>앱의 데이터를 담당하는 구성요소</strong> 로, 앱의 View 객체 및 앱 구성요소와 독립되어 있는 존재여야 한다.</p>

<p>즉, 모델을 UI와 분리하여 앱의 수명 주기나 여러 사용자 환경 흐름에 영향을 받지 않도록 해야한다는 것이다.</p>

<h2 id="3️⃣-권장하는-android-clean-architecture">3️⃣ 권장하는 Android Clean Architecture</h2>

<p>위에서 알아본 두 가지 원칙을 지키려면 개발자는 어떻게 코딩해야 할까?</p>

<p>예를 들어, 사용자 프로필 UI를 제작한다고 상상해보자.</p>

<p>이 때, 사용자 프로필 관련 정보는 REST API를 사용해서 서버를 통해 가져온다.</p>

<p>위에서 알아본 두 가지 원칙(UI 기반 클래스 가볍게 하기, UI와 Model 분리하기)를 지키면서 사용자 프로필 기능을 제작하기 위해서는 개발자가 다음과 같은 아키텍처를 구성해야 한다.</p>

<p>아래 구조가 안드로이드에서 권장하는 아키텍처이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/83138586-fbe25f00-a125-11ea-9a82-be29de3fc4b0.PNG" alt="02" /></p>

<p>위 다이어그램을 보면 아키텍처의 각 구성요소는 <strong>Activity/Fragment</strong>, <strong>ViewModel</strong>, <strong>Repository</strong>, <strong>Remote Data Source</strong> 임을 알 수 있다.</p>

<p>또 이 구성요소들은 모두 딱 한 단계 아래의 구성요소에만 종속되어 있음을 알 수 있다.</p>

<p>예를 들어 Activity나 Fragment는 ViewModel에만 종속되어 있는 것이다.</p>

<p>하지만 특이하게도 Repository(저장소)는 여러 개의 다른 클래스에 종속되어 있는 유일한 요소임을 알 수 있다.(위 그림에서 Repository는 Model과 Remote Data Source에 종속되어 있다.)</p>

<p>이제 본격적으로 위와 같은 아키텍처 구조를 따르는 사용자 프로필 기능을 구현해보자! (코드 구현이 아니라 머리로 상상하며 구현해보자.)</p>

<ol>
  <li>
    <p><strong>사용자 프로필 UI 레이아웃 및 UI 클래스 만들기</strong></p>

    <p>사용자 프로필 UI를 위해 user_profile_layout.xml 이라는 xml 파일과 UserProfileFragment.kt 라는 Fragment 클래스를 만들었다고 가정하자.</p>

    <p>프로필 UI 안에 들어갈 정보들은 아래와 같이 총 두 가지라고 가정해보자.</p>

    <ul>
      <li>
        <p><strong>사용자 ID</strong> : 사용자 ID는 Android OS에서 이 앱의 프로세스를 제거해도 이 정보가 계속 유지되어 앱을 다시 시작할 때 ID를 재사용할 수 있도록 하는 역할이다.</p>

        <p>따라서 사용자 ID는 fragment argument 사용하여 프래그먼트에 전달하는 것이 좋다.</p>
      </li>
      <li>
        <p><strong>사용자 Object</strong> : 사용자 프로필에 관한 세부 정보를 가지고 있는 데이터 클래스이다. (예를 들어, 이 데이터 클래스에는 사용자 닉네임, 나이, 사진 등이 포함될 수 있다.)</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>ViewModel 클래스 만들기</strong></p>

    <p>위에서 본 안드로이드 아키텍처 다이어그램을 보면 Activity/Fragment 아래 단계에 ViewModel이 있는 것을 알 수 있다.</p>

    <p>그렇기 때문에 우리는 UI 기반 클래스를 구현하고 난 후 ViewModel 클래스를 생성해야 한다.</p>

    <p>UserProfileViewModel이라는 이름으로 ViewModel 클래스를 만들어보자.</p>

    <p>그렇다면 대체 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a>이 뭘까?</p>

    <p><strong>ViewModel은 Activity/Fragment와 같은 UI 구성요소에 데이터를 제공하고 Model과 커뮤니케이션하기 위한 데이터 처리 비즈니스 로직</strong> 이라고 할 수 있다.</p>

    <p>예를 들어, ViewModel은 UI 구성요소에 데이터를 업데이트하기 위해 ViewModel 하위 단계인 Repository를 호출하고 사용자 요청을 전달받아 데이터를 수정하는 작업을 할 수 있다.</p>

    <p>단, <strong>ViewModel은 UI 기반 클래스가 아닌 일반 클래스이므로 UI에 대해 전혀 알지 못한다. 따라서 Activity나 Fragment의 수명주기 변경에 영향을 받지 않는다.</strong></p>
  </li>
</ol>

<p>지금까지</p>

<ul>
  <li>
    <p>user_profile_layout.xml : 프로필 화면의 레이아웃 정의 파일</p>
  </li>
  <li>
    <p>UserProfileFragment.kt : 프로필 화면의 레이아웃에 대응하는 Fragment UI 기반 클래스</p>
  </li>
  <li>
    <p>UserProfileViewModel.kt : 프로필 화면에 띄워줄 데이터를 준비하거나 프로필 화면으로부터 받은 사용자 요청(서버의 데이터 값 수정 등)에 반응하여 처리 작업을 하는 클래스(이 예시에서는 userId 및 userObject가 이 ViewModel 클래스에서 준비된다.)</p>
  </li>
</ul>

<p>이렇게 총 3개의 파일이 만들어졌다.</p>

<ol>
  <li>
    <p><strong>Repository 클래스 만들기</strong></p>

    <p>이제 REST API를 통해 Server(Remote Data Source)로부터 사용자 프로필 화면을 보여주기 위해 필요한 데이터를 가져와야 한다.(이 때, 주로 Retrofit 라이브러리와 같은 Android 네트워크 통신을 도와주는 라이브러리를 사용하여 데이터를 가져온다.)</p>

    <p>Android 네트워크 통신과 관련된 코드를 ViewModel 클래스에 작성하여 프로필 화면에 띄워줄 데이터를 준비하는 것도 좋지만</p>

    <p>이렇게 할 경우 <strong>ViewModel 클래스의 역할이 너무 커지게 되고, 앱의 규모가 커지면 유지 보수가 어려울</strong> 수 있다.</p>

    <p>따라서 Android 네트워크 통신과 관련된 코드를 ViewModel에서 분리하는 것이 좋다.</p>

    <p>네트워트 통신 코드가 분리되어 있는 클래스를 <strong>Repository(저장소) 클래스</strong> 라고 부른다.</p>

    <p>UserProfileRepository.kt 라는 클래스를 생성하고 이 안에 네트워크 통신 로직을 작성하면 된다.</p>
  </li>
  <li>
    <p><strong>ViewModel 클래스와 Repository 클래스 연결하기</strong></p>

    <p>이제 Repository 클래스에서 서버와의 통신을 통해 가져온 데이터를 ViewModel 클래스에 넘겨주어 ViewModel 클래스가 UI 기반 클래스에 존재하는 UI 객체에 반영시킬 데이터를 준비하도록 해줘야 한다.</p>
  </li>
  <li>
    <p><strong>ViewModel 클래스에서 데이터가 준비되었다고 UI 객체에게 알리기</strong></p>

    <p>이제 ViewModel 클래스는 Repository 클래스에서 넘겨받은 데이터를 가지고 있게 된다. 즉, <strong>UI 객체에 업데이트 해줄 데이터가 준비된 상태</strong> 이다.</p>

    <p>따라서 <strong>ViewModel 클래스에서 데이터가 준비되었다고 UI에게 알리는 방법이 필요하다.</strong></p>

    <p>이 때, ViewModel 클래스에서 <strong><a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a></strong> 라는 녀석을 사용하면 데이터가 준비되었다고 UI에게 알릴 수 있게 된다.</p>

    <p><strong>LiveData</strong> 는 <strong>데이터를 담고 있는 Holder(홀더)인데 자신이 담고 있는 데이터가 변경되었는지를 식별할 수 있는 Holder</strong> 이다.</p>

    <p>따라서 LiveData를 통해 데이터 변경사항을 모니터링할 수 있게 된다.</p>

    <p>이 예제에서는 LiveData가 userId와 userObject 라는 데이터를 담고 있는 상태라고 볼 수 있다.</p>
  </li>
  <li>
    <p><strong>UI 기반 클래스에서 LiveData를 관찰하고 있다가 변경 신호를 받으면 데이터를 업데이트하기</strong></p>

    <p>이제 UI 기반 클래스에서 ViewModel 클래스에 존재하는 LiveData를 observe(관찰)하여야 한다. 그래야 LiveData가 알려주는 신호를 알아차릴 수 있기 때문이다.</p>

    <p>LiveData가 자신이 담고 있는 데이터가 변경되었다는 신호를 발생하면 이 LiveData를 observe(관찰)하고 있던 UI 기반 클래스에서 이를 알아차리게 되어 UI 객체에 업데이트 작업을 해주면 된다.</p>
  </li>
</ol>

<p>여기까지 하면 위에서 보았던</p>

<p><img src="https://user-images.githubusercontent.com/31889335/83407257-4a0ba100-a44b-11ea-9849-238ebd515768.PNG" alt="03" /></p>

<p>다이어그램 구조대로 기능 하나를 완성시킨 것이 된다. (데이터를 제공해주는 Source가 서버였기 때문에 빨간 박스 처리한 부분의 로직을 따라한 것이다.)</p>

<p>처음부터 다시 한 번 쭉 읽어본다면 Android Clean Architecture가 왜 등장했고, 어떻게 구현할 수 있는지 이해될 것이다!</p>

<h1 id="끝">끝!</h1>

<p>이 포스팅에서는 Android Clean Architecture의 실제 구현 코드를 언급하지는 않았지만 전체적인 구조를 이해하는데 집중하였다.</p>

<p>따라서 각 단계에서 등장했던 LiveData 사용법, Repository 구현법, ViewModel 구현법, UI 기반 클래스에서 LiveData observe 구현법 등에 대해서는 따로 공부할 필요가 있다! 화이탱~ 💪🏻</p>

  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

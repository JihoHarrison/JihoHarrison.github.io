<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  그림으로 배우는 알고리즘 이라는 책으로 자료구조를 쉽게 이해해보았다!📚 꼭! 알고 있어야 할 자료구조들!자료구조 라는 것은 데이터의 효율적인 접근 및 수정을 위한 자료의 조직, 관리, 저장 방법에 관한 것이다.즉, 데이터를 모아 놓고 데이터 간의 관계, 데이터에 적용 가능한 함...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[자료구조] 🎁 꼭! 알아두어야 할 자료구조들! | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[자료구조] 🎁 꼭! 알아두어야 할 자료구조들! | choheeis">
  <meta name="twitter:description" content="  그림으로 배우는 알고리즘 이라는 책으로 자료구조를 쉽게 이해해보았다!📚 꼭! 알고 있어야 할 자료구조들!자료구조 라는 것은 데이터의 효율적인 접근 및 수정을 위한 자료의 조직, 관리, 저장 방법에 관한 것이다.즉, 데이터를 모아 놓고 데이터 간의 관계, 데이터에 적용 가능한 함...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2019-07/BasicDataStructure">
  <meta property="og:title" content="[자료구조] 🎁 꼭! 알아두어야 할 자료구조들! | choheeis">
  <meta property="og:description" content="  그림으로 배우는 알고리즘 이라는 책으로 자료구조를 쉽게 이해해보았다!📚 꼭! 알고 있어야 할 자료구조들!자료구조 라는 것은 데이터의 효율적인 접근 및 수정을 위한 자료의 조직, 관리, 저장 방법에 관한 것이다.즉, 데이터를 모아 놓고 데이터 간의 관계, 데이터에 적용 가능한 함...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[자료구조] 🎁 꼭! 알아두어야 할 자료구조들! | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2019-07/BasicDataStructure">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[자료구조] 🎁 꼭! 알아두어야 할 자료구조들!">[자료구조] 🎁 꼭! 알아두어야 할 자료구조들!</h1>
    <span class="post-meta">
      <span class="post-date">
        16 JUL 2019
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    7 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=85969851">그림으로 배우는 알고리즘</a> 이라는 책으로 자료구조를 쉽게 이해해보았다!</p>

</blockquote>

<p><br /></p>

<h2 id="-꼭-알고-있어야-할-자료구조들">📚 꼭! 알고 있어야 할 자료구조들!</h2>

<p><strong>자료구조</strong> 라는 것은 데이터의 효율적인 접근 및 수정을 위한 자료의 조직, 관리, 저장 방법에 관한 것이다.</p>

<p>즉, 데이터를 모아 놓고 데이터 간의 관계, 데이터에 적용 가능한 함수 등이 모여 있는 것을 자료구조라고 부른다.</p>

<p>알고리즘과 자료구조는 뗄 수 없는 관계이다. 문제를 해결하기 위해 알고리즘을 선택했다면 선택한 알고리즘을 토대로 자료구조를 선택해야 하기 때문이다.</p>

<p>또, 데이터를 관리하고 조작하기 위해 자료구조를 선택했다면 선택한 자료구조를 토대로 알고리즘을 선택할 수도 있다.</p>

<p><br /></p>

<ul>
  <li>
    <p><em>배열</em></p>

    <p>데이터를 빈틈없이 나열한 자료구조이다. 즉 연속된 메모리 공간을 사용한다는 것이다.</p>

    <p>직선형(1차원 배열), 직사각형형(2차원 배열), 직육면체 형(3차원 배열) 등이 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>리스트(Linked List)</em></p>

    <p>데이터를 순서대로 나열한 자료구조이다.</p>

    <p>배열과 같이 순서가 있는 데이터를 저장하고 관리한다.</p>

    <p>하지만 배열과 다르게 데이터들이 화살표로 서로 연결되어 있어 데이터들이 떨어진 장소에 위치해도 된다는 점이 장점이다. (연속된 메모리 공간이 필요 없음)</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/61299760-ab1e8c00-a81b-11e9-84a3-4f27706bb1d9.PNG" alt="리스트" /></p>

    <p>리스트는 크게 두 가지 종류로 나뉜다.</p>

    <p><br /></p>

    <ul>
      <li>
        <p><strong>단방향 리스트</strong></p>

        <p>단방향 리스트의 각 요소에는 2가지 항목이 들어있는데 데이터와 다음 요소를 가리키는 포인터이다.</p>

        <p>이 때, 포인터가 위 그림에서 화살표 역할을 하는 친구이다.</p>

        <p>이 포인터는 다음 요소가 어디에 있는지 <strong>위치정보</strong> 가 저장되어 있다.</p>

        <p>또한, 단방향 리스트의 마지막 요소의 포인터에는 이제 다음 요소가 더이상 없다는 뜻의 종료 정보가 저장되어 있다.</p>

        <p>여기에 더불어 단방향 리스트에는 HEAD 포인터라는 특별한 포인터가 따로 존재하는데 여기에는 리스트의 맨 처음 요소의 위치 정보가 저장되어 있다.</p>

        <p><img src="https://user-images.githubusercontent.com/31889335/61359643-b8895400-a8b7-11e9-89bc-44f64bd6213d.PNG" alt="단방향리스트" /></p>

        <p>만약, 단방향 리스트에 아무 데이터가 저장되어 있지 않아 리스트가 비어있는 경우, HEAD 포인터에는 종료 정보가 저장된다.</p>

        <p><br /></p>
      </li>
      <li>
        <p><strong>양방향 리스트</strong></p>

        <p>양방향이라는 뜻과 같이, 이 리스트는 화살표 방향이 두 방향으로 존재하는 리스트이다.</p>

        <p>따라서 리스트의 각 요소에는 데이터, 다음 요소를 가리키는 포인터 외에도 이전 요소를 가리키는 포인터가 추가로 포함되어 있다.</p>

        <p>이전 요소를 가리키는 포인터에는 이전 요소가 어디에 있는지에 대한 위치 정보가 저장되어 있다.</p>

        <p>또한, 단방향 리스트에서 HEAD 포인터가 존재헀던 것과 같은 맥락으로, 양방향 리스트는 HEAD 포인터와 TAIL 포인터를 둘 다 가지고 있다.</p>

        <p>양방향 리스트에서 HEAD 포인터에는 첫 번째 요소의 위치 정보가 저장되어 있으며, TAIL 포인터에는 마지막 요소의 위치정보가 저장되어 있다.</p>

        <p>만약, 리스트가 비어있다면 HEAD, TAIL 포인터에 모두 종료 정보가 저장된다.</p>

        <p><img src="https://user-images.githubusercontent.com/31889335/61360167-d4d9c080-a8b8-11e9-8863-9e3124737ef3.PNG" alt="양방향리스트" /></p>

        <p><br /></p>
      </li>
    </ul>

    <blockquote>
      <p>👀 배열과 리스트를 비교해보자!</p>

      <p><strong>1. N번째 요소를 찾아야할 때</strong> 리스트보다는 배열을 사용하는 것이 더 편리하다!</p>

      <p>–&gt; 배열은 index 값을 통해 N번째 요소를 즉시 찾을 수 있지만 리스트는 N번째 값을 찾기 위해 첫번째 요소부터 순서대로 N번째 요소까지 확인하여야 한다.</p>

      <p><strong>2. 데이터를 중간지점에 삽입해야 할 때</strong> 배열보다는 리스트를 사용하는 것이 더 효율적이다!</p>

      <p>–&gt; 배열의 중간에 새로운 데이터를 삽입하기 위해서는 삽입 위치 다음에 존재하는 모든 요소들을 한칸씩 뒤로 이동시켜야 한다. 만약 1000개의 요소들을 한칸씩 뒤로 이동시켜야 한다면 시간 소모가 커질 것이다!</p>

      <p>하지만 리스트의 중간에 새로운 데이터를 삽입한다면 삽입 요소의 바로 직전 요소가 가지는 ‘다음요소 위치 정보’ 와 삽입 요소의 ‘다음요소 위치 정보’만 수정하면 되므로 배열보다 더 효율적이다.</p>

      <p><strong>3. 중간지점의 데이터를 삭제해야 할 때</strong></p>

      <p>데이터를 중간지점에 삽입하는 경우와 마찬가지로 배열보다 리스트를 사용하는 것이 더 효율적이다!</p>

      <p>배열의 중간 데이터를 삭제한다면 삭제 위치 다음의 모든 요소들을 한칸씩 앞으로 이동시켜야 한다.</p>

      <p>하지만 리스트 중간 지점의 데이터를 삭제한다면 위치정보만 수정하면 된다.</p>
    </blockquote>

    <p><br /></p>
  </li>
  <li>
    <p><em>스택(Stack)</em></p>

    <p>책상 위에 책을 쌓듯 데이터를 저장하고 관리하는 자료구조이다.</p>

    <p>일반적으로 쌓여있는 책은 가장 위쪽부터 꺼내는 것이 안전하듯이 스택도 가장 위쪽 데이터부터 꺼낼 사용할 수 있다.</p>

    <p>즉, 스택 자료구조를 사용하면 데이터를 넣은 순서와 반대의 순서로 데이터를 꺼낼 수 밖에 없다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/61307781-eb850680-a829-11e9-82ea-6a90a10ed922.PNG" alt="스택" /></p>

    <p>스택 자료구조를 사용하여 데이터를 관리할 때는 아래 두 가지 작업을 알아두어야 한다.</p>

    <ul>
      <li>
        <p><strong>PUSH</strong> : 스택 자료구조에 데이터를 넣는 작업</p>
      </li>
      <li>
        <p><strong>POP</strong> : 스택 자료구조에서 데이터를 꺼내는 작업</p>
      </li>
    </ul>

    <p>이렇게 마지막으로 넣어진 데이터를 제일 먼저 뺄 수 있는 구조는 <strong>Last-In First-Out</strong> 이라고 부르고 줄여서 <strong>LIFO</strong> 라고 한다.</p>

    <p>또한 스택은 맨 위에 있는 데이터 외의 다른 데이터들에는 접근할 수 없는 구조이다. 따라서 맨 위 데이터 외의 다른 데이터에 접근해야 한다면 스택을 사용해서는 안된다.</p>

    <p>즉, 스택은 맨 위에 있는 데이터만을 가지고 작업을 하는 것이 의미가 있을 경우에만 사용한다!</p>

    <p>스택이 사용되기 좋은 곳은 저장된 데이터의 순서를 반대로 바꿔야하는 작업에서 사용하면 좋다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>큐(Queue - 대기행렬)</em></p>

    <p>계산대에 먼저 줄을 선 손님부터 계산을 해주듯 데이터를 저장하고 관리하는 자료구조이다.</p>

    <p>즉, 큐 자료구조를 사용하면 먼저 들어온 데이터부터 꺼낼 수 있다.</p>

    <blockquote>
      <p>운영체제 수업 때 프로세스 레디 큐 구조를 떠올리자!</p>
    </blockquote>

    <p><img src="https://user-images.githubusercontent.com/31889335/61307642-a7920180-a829-11e9-915d-e74543937321.PNG" alt="큐" /></p>

    <p><br /></p>

    <p>큐와 같이 처음 들어온 원소부터 빠지는 방식을 <strong>FIFO(First In First Out)</strong> 방식이라고 한다.</p>
  </li>
  <li>
    <p><em>트리</em></p>

    <p>나뭇 가지가 나뉘듯 퍼져 나가는 자료구조이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/61307349-22a6e800-a829-11e9-9305-ff4f9b55f2c8.PNG" alt="트리" /></p>

    <p><br /></p>
  </li>
  <li>
    <p><em>링 버퍼(ring buffer)</em></p>

    <p>1차원 배열은 각 요소에 index를 통해 참조할 수 있다. 하지만 1차원 배열은 처음과 끝이 존재한다.</p>

    <p>즉, 크기가 10인 1차원 배열의 처음 index는 0이고, 마지막 index는 9이다.</p>

    <p>따라서 마지막 index에 +1을 한 index는 존재하지 않는다.</p>

    <p>하지만 <strong>ring buffer</strong> 라는 자료구조에서는 마지막 index에 +1을 한 index가 존재한다.</p>

    <p>ring buffer는 1차원 배열의 처음과 끝을 원모양이 되도록 붙여놓은 자료구조이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62105437-52e88f00-b2dd-11e9-89ed-0dde7b44d3d9.PNG" alt="링버퍼" /></p>

    <p><br /></p>
  </li>
  <li>
    <p><em>이진트리</em></p>

    <p>이진트리는 다음 요소를 가리키는 포인터를 2개 가진 단방향 리스트의 일종이다. 즉, 데이터 x의 다음 요소로 데이터 L과 데이터 R이 존재하는 자료구조이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62107160-fc318400-b2e1-11e9-983e-cf9394d4aa33.PNG" alt="이진트리" /></p>

    <p>이진트리는 각 요소들을 <strong>노드</strong> 라고 부른다. 위 그림에서 데이터 X를 부모노드, 데이터 L과 데이터 R을 자식노드라고 부른다.</p>

    <p>자식노드에 데이터 L과 R이 반드시 있을 필요는 없으며 왼쪽 자식 노드만 있거나 오른쪽 자식 노드만 있을 수도 있다.</p>

    <p><strong>하지만! 자식 노드를 3개 이상 가질 수는 없다.</strong></p>

    <p>또한, 아래 그림과 같이 자식 노드는 또 다른 자식 노드의 부모 노드가 될 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62107640-056f2080-b2e3-11e9-9be1-35658f0c0379.PNG" alt="이진트리2" /></p>

    <p>이진트리에서 맨 처음 노드를 루트 노드라고 부르며, 더 이상 자식 노드가 없는 노드를 리프 노드라고 부른다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>힙</em></p>

    <p>위 이진트리에서 각 노드의 값이 <strong>“부모 노드의 값(데이터)은 항상 하위 노드의 값보다 작다”</strong> 를 만족하는 이진트리를 <strong>힙</strong> 이라고 부른다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62107833-73b3e300-b2e3-11e9-81c3-dd9f56a1061a.PNG" alt="힙1" /></p>

    <p>위 그림에서 보면 부모 노드의 데이터 값은 항상 하위 노드의 데이터 값보다 작다!</p>

    <p>자식 노드 간의 대소 비교는 상관하지 않는다.</p>

    <p>따라서 힙의 루트 노드에는 항상 최솟값이 저장된다.</p>

    <p>힙의 조건은 <strong>“부모 노드의 값(데이터)은 항상 하위 노드의 값보다 크다”</strong> 도 가능하다. 이 경우에는 루트 노드에 항상 최댓값이 저장된다.</p>

    <p>따라서 힙은 최솟값과 최댓값을 효율적으로 구하는데 적합하다.</p>

    <p>실제로 힙을 구현할 때는 배열을 사용하고, 힙의 아래서 위로, 힙의 왼쪽에서 오른쪽 방향으로 훑으면서 데이터를 배열에 차례로 저장한다.</p>

    <p>아래 그림은 위에서 보여준 힙 그림을 배열로 구현한 것을 보여주는 그림이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62108211-74994480-b2e4-11e9-94d7-7499e7c7051d.PNG" alt="힙2" /></p>

    <p><br /></p>
  </li>
  <li>
    <p><em>해시 테이블</em></p>

    <p>해시 테이블은 <strong>1. N개의 요소를 가진 루트 배열이라는 이름의 배열</strong> 과 <strong>2. 루트 배열의 각 요소들이 가리키는 리스트</strong> 이 2개의 자료구조가 결합된 자료구조이다.</p>

    <p>아래 그림을 보며 이해하자!</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62108908-25ecaa00-b2e6-11e9-91f2-e91e68a8092f.PNG" alt="해시테이블1" /></p>

    <p>즉, 데이터들은 배열 요소가 가리키는 하나의 리스트에 저장되어있다. 즉, 데이터들이 그룹화 되어 있는 것이다.</p>

    <p>만약 해시테이블로 데이터들을 관리할 경우, 필요한 데이터를 찾기 위해서는 먼저 루트 배열 요소를 알아야 한다. 왜냐하면 루트 배열 요소가 각 리스트를 가리키고 있기 때문이다.</p>

    <p>해시 테이블에서는 이 배열의 요소 번호를 구할 때 <strong>해시 함수</strong> 라는 것을 사용한다.</p>

    <p>해시 함수는 데이터를 함수의 입력으로 넣으면 0 ~ N 사이의 값인 배열 요소 번호를 출력해주는 함수이다.</p>

    <p>이렇게 해시 함수를 통해 루트 배열 요소의 번호를 구한 후, 해당 배열 요소가 가리키는 리스트에 접근하여 순차적으로 리스트를 탐색하여 원하는 데이터를 찾을 수 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>그래프</em></p>

    <p>그래프는 2개 이상의 항목이 어떤 관계를 맺고 있는지에 주목하여 이 관계를 그림으로 나타낸 것이다.</p>

    <p>그래프에서는 각 항목을 <strong>정점(노드)</strong> 라고 부르고, 각 항목들의 관계를 표현하는 선을 <strong>간선(edge)</strong> 라고 부른다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62113128-ff7f3c80-b2ee-11e9-83b5-a48098c1d953.PNG" alt="그래프1" /></p>

    <p>위 그림은 간선에 <strong>방향성이 없는</strong> 그래프를 나타낸 것이다. 위 그래프에 따르면 A 에서 C로 한번에 갈 수 있는 방법은 없다는 것을 알 수 있다. 또한, B에서 D로도 한번에 갈 수 없다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62113407-859b8300-b2ef-11e9-81c4-555769deb945.PNG" alt="그래프2" /></p>

    <p>위 그림은 간선에 <strong>방향성이 있는</strong> 그래프를 나타낸 것이다. 이 경우에 정점 D에서 B로 가려면 D, E, A 를 순서대로 거쳐야 함을 알 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/62113609-db702b00-b2ef-11e9-95e5-b5bf5638a53f.PNG" alt="그래프3" /></p>

    <p>위 그림은 간선에 <strong>가중치가 있는</strong> 그래프를 나타낸 것이다. 이 그래프에서는 각 정점사이를 이동할 때 필요한 가중치를 계산할 수 있다.</p>

    <p><br /></p>

    <blockquote>
      <p>쉬운 책으로 자료구조 <strong>개념</strong> 에 대해 쭉 봐보니 알고리즘을 공부할 때 등장했던 것들이 지금은 어렵게 느껴지지 않는다!</p>

      <p>역시 쉽게 쉽게 접근하는 것이 이해와 정신건강에 좋다! ㅋㅋㅋ</p>
    </blockquote>
  </li>
</ul>

  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  ReactiveX 공식 문서 중 Scheduler 와 RxJava 프로그래밍 이라는 책을 참고하여 공부한 내용입니다😃🧾 Scheduler 란??만약 우리가 Observable의 연산자(operator)들의 체이닝(chaining) 안에서 다중 쓰레드를 사용하고 싶다면 그 연산자...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[RxJava] 🧾 RxJava에서 스케줄러! | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[RxJava] 🧾 RxJava에서 스케줄러! | choheeis">
  <meta name="twitter:description" content="  ReactiveX 공식 문서 중 Scheduler 와 RxJava 프로그래밍 이라는 책을 참고하여 공부한 내용입니다😃🧾 Scheduler 란??만약 우리가 Observable의 연산자(operator)들의 체이닝(chaining) 안에서 다중 쓰레드를 사용하고 싶다면 그 연산자...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-04/RxScheduler">
  <meta property="og:title" content="[RxJava] 🧾 RxJava에서 스케줄러! | choheeis">
  <meta property="og:description" content="  ReactiveX 공식 문서 중 Scheduler 와 RxJava 프로그래밍 이라는 책을 참고하여 공부한 내용입니다😃🧾 Scheduler 란??만약 우리가 Observable의 연산자(operator)들의 체이닝(chaining) 안에서 다중 쓰레드를 사용하고 싶다면 그 연산자...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[RxJava] 🧾 RxJava에서 스케줄러! | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-04/RxScheduler">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[RxJava] 🧾 RxJava에서 스케줄러!">[RxJava] 🧾 RxJava에서 스케줄러!</h1>
    <span class="post-meta">
      <span class="post-date">
        23 APR 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    16 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p><a href="http://reactivex.io/documentation/scheduler.html">ReactiveX 공식 문서 중 Scheduler</a> 와 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=116852658">RxJava 프로그래밍</a> 이라는 책을 참고하여 공부한 내용입니다😃</p>
</blockquote>

<p><br /></p>

<h2 id="-scheduler-란">🧾 Scheduler 란??</h2>
<hr />

<p>만약 우리가 Observable의 연산자(operator)들의 체이닝(chaining) 안에서 다중 쓰레드를 사용하고 싶다면 그 연산자들에게 특정 쓰레드에서 작동하라고 지시하면 된다!</p>

<blockquote>
  <p>다중 쓰레드를 사용한다는 것은 작업 공간을 여러 개로 나누어 동시에 작업한다는 의미로 비동기처리라고도 한다.</p>
</blockquote>

<p><br /></p>

<p>Rx 연산자들 중에는 매개변수에 Scheduler를 가지는 모양의 연산자들이 있다.</p>

<p>그 중 대표적인 두 가지 연산자를 알아보자.</p>

<p><strong>subscribeOn</strong> 이라는 연산자는 특정한 스케줄러를 지정함으로써 어떤 쓰레드에서 Observable의 작동이 시작될지를 결정하는 연산자이다.</p>

<p>반면에 <strong>observerOn</strong> 이라는 연산자는 Observable이 사용하고 있는 쓰레드의 아래 단계 쓰레드에 영향을 미치는 연산자이다.</p>

<p>더 자세히는 Observable이 observer에게 item을 방출하기 위해 사용될 쓰레드를 지정하는 연산자이다.</p>

<p>따라서 연산자 chain 안의 다양한 위치에서 observerOn 연산자를 여러 번 호출할 수 있고, 이로 인해 특정한 연산자들이 서로 다른 쓰레드에서 실행되도록 할 수 있다.</p>

<p>만약 subscribeOn 을 여러 번 호출했다면 가장 마지막에 적힌 subscribeOn 에 따라 Observable의 작업이 시작된다.</p>

<p>다음 마블 다이어그램을 보고 observeOn과 subscribeOn 연산자에 대해서 조금 더 쉽게 이해해보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/80064305-b7860100-8572-11ea-874f-1a6e09fcb442.PNG" alt="01" /></p>

<p>위 그림을 보면 처음에는 파란색 쓰레드에서 Observable이 시작된다.</p>

<p>그리고 나서 observeOn 연산자를 통해 이 다음부터 나오는 메소드는 주황색 쓰레드에서 실행하라고 하는 모습이다.</p>

<p>따라서 map() 함수는 주황색 쓰레드에서 실행되어 observer에게 item을 방출한다.</p>

<p>그 다음 observeOn 연산자를 통해 이 다음부터 나오는 메소드는 주확색 쓰레드에서 실행하라고 하였으므로 item들은 주황색 쓰레드로 방출되게 된다.</p>

<p>이 때, 중간의 subscribeOn은 처음 Observable이 시작되는 쓰레드가 파란색임을 나타낸 것으로 위 그림에서도 파란색 쓰레드에서 시작한 것을 알 수 있다.</p>

<p><br />
그렇다면 이제 쉬운 코드를 보면서 subscribeOn과 observeOn 연산자에 대해서 자세히 이해해보자.</p>

<p>다음과 같은 코드의 출력 결과는 어떻게 될까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"RxJava3!!"</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 어느 쓰레드에서 실행되는지 출력해보기 위한 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/31889335/80338265-d77d3380-8896-11ea-9952-655842cf7af3.PNG" alt="02" /></p>

<p>Observable에서 observe에게 주는 item은 Hello와 RxJava3!! 이렇게 두 개이므로 getThread 함수는 이 두 item에 대해 두 번 실행될 것이다.</p>

<p>즉, 출력결과를 보면 getThread는 현재 쓰레드인 main 쓰레드에서 실행되고 있는 것을 알 수 있다.</p>

<p>만약 main 쓰레드 외의 다른 쓰레드를 사용하여 비동기로 동작하도록 해주려면?</p>

<p>이 때 스케줄러를 사용하는 것이다.</p>

<p><strong>스케줄러는 쓰레드를 지정할 수 있게 해주기 때문이다.</strong></p>

<p>Rx의 스케줄러는 새로운 방식으로 비동기 처리를 할 수 있게 해준다.</p>

<p>기존의 자바로 비동기 프로그래밍을 하기 위해 스레드를 만드는 것은 생각해야 하는 것들이 많아 매우 까다로웠다.</p>

<p>하지만 Rx로 비동기 처리를 한다면 정말 간결한 코드로 비동기 프로그래밍을 할 수 있을 것이다!</p>

<blockquote>
  <p>자바로 비동기 처리를 안 해봐서 잘 모르겠지만 일단 자바보다 Rx로 비동기 처리 하는게 더 쉽다는 건 알겠다!! ㅋㅋㅋㅋ</p>
</blockquote>

<p>이제 다음 코드를 보고 쓰레드가 바뀌는 과정을 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">objs</span><span class="o">)</span>
                <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">newThread</span><span class="o">())</span>
                <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">newThread</span><span class="o">())</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">objs</span> <span class="o">+</span> <span class="s">"#"</span><span class="o">);</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 doOnNext 라는 함수는 Observable에서 onNext 이벤트가 발생하기 전에 실행되는 함수이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/80340765-3abd9480-889c-11ea-8280-4e5f37b5a660.PNG" alt="03" /></p>

<p>그리고 subscribeOn() 연산자를 통해 observer가 subscribe() 함수로 Observable을 구독할 때 이 Observable의 작동이 시작될 쓰레드를 지정해주는 것이다.</p>

<p>마지막으로 observeOn() 을 통해 이 다음에 나오는 함수들이 실행될 쓰레드를 또 새로운 쓰레드로 바꿔준 것이다.</p>

<p>따라서 observeOn() 뒤에 나오는 map 함수는 기존 Observable 데이터 흐름이 있는 쓰레드가 아닌 새로운 쓰레드레서 실행될 것이다.</p>

<p>위 코드를 실행시켜 보면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/80340992-99830e00-889c-11ea-9f6c-82d58da1360c.PNG" alt="04" /></p>

<p>이렇게 출력결과가 나올 것이다.</p>

<p>doOnNext()에 의해 기존의 데이터 1, 2, 3이 존재하는 쓰레드는 1번 쓰레드이고 그 뒤에 observeOn() 에 의해 map 함수에 적용되어 방출된 item은 subscribe(Test::getThread) 에 의해 새로운 쓰레드에서 실행되었음을 알 수 있게 된다.</p>

<p>따라서!</p>

<p>최초의 데이터 흐름이 발생하는 쓰레드와 map() 함수를 거쳐서 구독자에게 전달되는 쓰레드가 다르게 된다~!</p>

<p>이렇게 Rx를 통해 비동기 처리를 가능하도록 했는데 이 과정에서 subscribeOn() 함수와 observeOn() 함수만 사용했을 뿐 자바에서 사용하는 Runnable이나 Callable 객체를 전달한 적이 없다는 것을 알 수 있다!</p>

<blockquote>
  <p>오?? 진짜 엄청 간단하네!! 일단 Runnable 객체가 안 보이는 것부터 짱이다</p>
</blockquote>

<p>이처럼 스케줄러를 활용하는 비동기 프로그래밍의 핵심은 <strong>바로 데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 전달하는 스레드를 분리할 수 있다</strong> 는 것이다!</p>

<p>그렇다면! 만약 다음 코드와 같이 observeOn() 함수를 사용하지 않아 쓰레드를 바꿔주지 않는다면??</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">objs</span><span class="o">)</span>
                <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">newThread</span><span class="o">())</span>
                <span class="c1">//.observeOn(Schedulers.newThread())</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">objs</span> <span class="o">+</span> <span class="s">"#"</span><span class="o">);</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/31889335/80341780-034fe780-889e-11ea-97fb-e6e4865e4711.PNG" alt="05" /></p>

<p>이렇게 처음 Observable이 작동하기 시작한 스레드에서 map() 함수까지 실행된다!</p>

<p><br /></p>

<p>그렇다면 다음과 같이 subscribeOn() 함수를 통해 Observable의 시작 스레드까지 정해주지 않는다면??</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">objs</span><span class="o">)</span>
                <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span>
                <span class="c1">//.subscribeOn(Schedulers.newThread())</span>
                <span class="c1">//.observeOn(Schedulers.newThread())</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">objs</span> <span class="o">+</span> <span class="s">"#"</span><span class="o">);</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드를 실행시켜보면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/80341987-604b9d80-889e-11ea-9bee-490d6405219f.PNG" alt="06" /></p>

<p>이렇게 출력된다.</p>

<p>즉, 별도의 스케줄러를 지정하지 않으면 모든 동작이 main 스레드에서 동작한다!</p>

<p>그렇다면 이제 어떤 스케줄러들이 있는지 <strong>스케줄러의 종류</strong> 에 대해서 알아보자!</p>

<p><br /></p>

<h2 id="-스케줄러의-종류">🧾 스케줄러의 종류</h2>
<hr />

<p>Rx는 다양한 스케줄러를 제공한다.</p>

<p>즉, 용도가 다른 다양한 스레드들을 제공한다는 것이다.</p>

<p>Rx를 사용하면 특정 스케줄러를 사용하다가 다양한 다른 스케줄러로 변경하기 쉽다는 것이 큰 장점이므로 이것을 잘 활용하면 좋다.</p>

<p>RxJava에서 제공하는 스케줄러는 io.reactivex.schedulers 패키지의 Schedulers 클래스의 정적 팩토리 메서드로 생성할 수 있다.</p>

<p>따라서 Rxjava로 스케줄러를 사용하고 싶다면</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">io.reactivex.rxjava3.schedulers.Schedulers</span><span class="o">;</span>
</code></pre></div></div>

<p>위와 같이 schedulers 패키지의 Schedulers 클래스를 import 해야 한다.</p>

<blockquote>
  <p>RxJava의 버전에 따라 지원하는 스케줄러가 있고 지원하지 않는 스케줄러가 있으니 버전을 잘 확인하자!</p>
</blockquote>

<p><br /></p>

<h2 id="1️⃣-newthread뉴-쓰레드-스케줄러">1️⃣ newThread(뉴 쓰레드) 스케줄러</h2>

<p><a href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html">Schedulers 클래스 Docs</a> 를 참고하여 공부해보자.</p>

<p>위 문서에는 Schedulers 라는 이름의 클래스에 정의된 여러 스케줄러 호출 함수들을 볼 수 있다.</p>

<p>그 중 <strong>newThread()</strong> 라는 함수에 대해서 알아보자.</p>

<p>이 함수는 이름처럼 새로운 스레드를 생성할 때 호출하는 함수이다.</p>

<p>새로운 스레드를 만들어 어떤 동작을 실행하고 싶을 때 Schedulers.newThread() 함수를 인자로 넣어주면 되고, 이 뉴 쓰레드 스케줄러 함수는 요청을 받을 때마다 새로운 스레드를 생성해준다.</p>

<p>아래 코드는 newThread() 함수를 subscribeOn() 연산자의 인자로 넣어 새로운 쓰레드를 생성하고 그 안에서 작업을 하는 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">orgs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
        <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">orgs</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="s">"&lt;&lt;"</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="s">"&gt;&gt;"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original Data : "</span> <span class="o">+</span> <span class="n">data</span><span class="o">))</span>
                <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">newThread</span><span class="o">())</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">orgs</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="s">"##"</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="s">"##"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Original Data : "</span> <span class="o">+</span> <span class="n">data</span><span class="o">))</span>
                <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">newThread</span><span class="o">())</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/31889335/81553393-f5cb4f00-93bf-11ea-815b-ad6960cdbc9e.PNG" alt="07" /></p>

<p>위 코드를 실행시키면 이와 같은 출력 결과가 나온다. 쓰레드 이름으로 보아 main 쓰레드가 아닌 새로운 1번 쓰레드와 2번 쓰레드에서 각각 동작이 실행된 것을 볼 수 있다.</p>

<p>newThread() 함수를 통해 새로운 쓰레드 생성을 호출하는 방법은 적극적으로 추천하는 방법은 아니다.</p>

<p>왜냐하면 RxJava에는 newThread() 스케줄러 보다 활용도가 높은 계산 스케줄러와 IO 스케줄러 같은 것이 있기 때문이다.</p>

<p><br /></p>

<h2 id="2️⃣-계산-스케줄러">2️⃣ 계산 스케줄러</h2>

<p><img src="https://user-images.githubusercontent.com/31889335/81554052-13e57f00-93c1-11ea-9225-f1bc8b74c13c.PNG" alt="09" /></p>

<p>Rx 연산자를 공부하면서 알게 된 interval() 이라는 함수는 사실 기본적으로 계산 스케줄러에서 동작하는 함수이다.</p>

<p>interval() 함수의 원형을 보면 SchedulerSupport 어노테이션을 통해 computation 스케줄러에서 실행된다는 사실을 알 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/81553956-ebf61b80-93c0-11ea-9339-21a149b7d93a.PNG" alt="08" /></p>

<p>물론 위처럼 같은 interval() 함수여도 오버로드되어 스케줄러를 custom 할 수 있는 함수도 있다.</p>

<p>계산 스케줄러를 사용하면 ‘계산’ 작업을 할 때 대기 시간 없이 빠르게 결과를 도출할 수 있게 된다.</p>

<p>계산 작업은 I/O(입출력) 작업이 아닌 작업이라고 생각하면 된다.</p>

<p>계산 스케줄러는 Schedulers.compatation() 함수를 통해 호출할 수 있다.</p>

<p><br /></p>

<h2 id="3️⃣-io-스케줄러">3️⃣ IO 스케줄러</h2>

<p>IO 스케줄러는 네트워크 요청을 처리하거나 데이터 베이스 쿼리 작업을 하거나 각종 입출력 작업을 실행하기 위한 스케줄러이다.</p>

<p>계산 스케줄러와 IO 스케줄러의 가장 큰 차이점은 생성되는 스레드 개수가 다르다는 것이다.</p>

<p>계산 스케줄러는 CPU 개수만큼 스레드를 생성하지만 IO 스케줄러는 필요할 때 마다 스레드를 계속 생성한다.</p>

<p>또한, 입출력 작업은 비동기로 실행하여도 결과를 얻기까지 대기 시간이 길다는 특징이 있다.</p>

<p>IO 스케줄러는 Schedulers.io() 함수를 호출함으로써 생성할 수 있다.</p>

<p><br /></p>

<h2 id="4️⃣-트램펄린trampoline-스케줄러">4️⃣ 트램펄린(Trampoline) 스케줄러</h2>

<p>트램펄린 스케줄러는 새로운 스레드를 생성하지 않고 현재 스레드에 무한한 크기의 대기 행렬(큐)을 생성하는 스케줄러이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">orgs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">orgs</span><span class="o">);</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">trampoline</span><span class="o">())</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="s">"&lt;&lt;"</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="s">"&gt;&gt;"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">trampoline</span><span class="o">())</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="s">"##"</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="s">"##"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드는 main 쓰레드를 트램펄린 스케줄러를 통해 길게 늘려준 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/81556200-e4d10c80-93c4-11ea-8200-8271f5322297.PNG" alt="10" /></p>

<p>이렇게 하면 새로운 스레드를 생성하지 않고 main 스레드에서 모든 작업을 실행한다.</p>

<p>대기 행렬인 큐에 작업을 넣은 후 1개씩 꺼내어 동작하므로 첫 번째 구독과 두 번쨰 구독 순서가 바뀌는 경우는 발생하지 않는다.</p>

<p><br /></p>

<h2 id="5️⃣-싱글-스레드-스케줄러">5️⃣ 싱글 스레드 스케줄러</h2>

<p>싱글 스레드 스케줄러는 RxJava 내부에서 단일 스레드를 별도로 생성하여 작업을 처리할 때 사용하는 스케줄러이다.</p>

<p>싱글 스레드는 여러 번 생성 요청이 와도 하나의 스레드를 공통으로 사용한다는 점이 특징이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>

        <span class="n">numbers</span><span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">single</span><span class="o">())</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>
        <span class="n">chars</span><span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">single</span><span class="o">())</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getThread</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getThread</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드는 두 개의 Observable에 대한 subscribe 작업을 single 스레드에서 처리한 코드이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/81556955-23b39200-93c6-11ea-840a-e1384d98dded.PNG" alt="11" /></p>

<p>위 코드의 출력결과는 위와 같다. main 쓰레드가 아닌 새로운 스레드에서 작업되는 모습을 볼 수 있다.</p>

<p>싱글 스레드 스케줄러를 생성하면 여러 개의 Observable 이 있어도 별도로 마련된 단일 스레드에서 작업이 차례대로 실행된다.</p>

<p><br /></p>

<h2 id="-scheduler-로-콜백-지옥callback-hell-벗어나기">🧾 Scheduler 로 콜백 지옥(callback hell) 벗어나기</h2>
<hr />

<p>Rx 프로그래밍을 이용하면 서버와 통신하는 네트워크 프로그래밍을 할 때 빈번히 발생하는 <strong>콜백 지옥</strong> 을 해결할 수 있다.</p>

<p>일단 Rx의 스케줄러를 이용했을 때 장점을 다시 한번 짚어보자.</p>

<p>스케줄러를 이용하면 스레드를 생성하는 것과 같은 비동기 프로그래밍을 해야 할 경우 Callable, Runnable 객체를 실행하는 코드는 필요 없다.</p>

<p>따라서 Reactive Programming 은 서버와 통신하는 비동기 프로그래밍을 작성할 때 가장 큰 힘을 발휘한다.</p>

<p><br /></p>

<p>그렇다면 <strong>콜백 지옥이 뭔지</strong> 에 대해서 알아보자.</p>

<p>예를 들어, 다음과 같이 서버에 http 요청을 하는 java 코드가 있다고 가정해보자.(OkHttp3기반)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Request</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Request</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">url</span><span class="o">(</span><span class="s">"https://~~~"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="n">Client</span><span class="o">.</span><span class="na">newCall</span><span class="o">(</span><span class="n">request</span><span class="o">).</span><span class="na">enqueue</span><span class="o">(</span><span class="k">new</span> <span class="n">Callback</span><span class="o">()){</span>

    <span class="c1">// 서버 통신 실패시 호출</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">Call</span> <span class="n">call</span><span class="o">,</span> <span class="n">IOException</span> <span class="n">e</span><span class="o">){</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 서버 통신 성공시 호출</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onResponse</span><span class="o">(</span><span class="n">Call</span> <span class="n">call</span><span class="o">,</span> <span class="n">Response</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">body</span><span class="o">().</span><span class="na">string</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이처럼 서버 통신에 사용할 코드에는 기본적으로 성공할 경우와 실패할 경우를 나눠 각각 콜백함수로 작성하곤 한다.</p>

<p>만약 위 코드에서 서버 통신에 성공할 경우에 또 다른 URL로 서버 통신을 하고 싶다고 가정해보자.</p>

<p>즉, 서버 통신을 중첩해야 해결되는 기능이 있는 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/81897980-ab7de400-95f2-11ea-8b4a-c4bfd6e458c0.PNG" alt="12" /></p>

<p>위 코드만 봐도 콜백 함수를 4번 작성해야 하는 걸 알 수 있다.</p>

<p>하지만 두 번째 서버 통신 성공 시 한 번 더 서버 통신을 해야 한다면??</p>

<p>콜백함수가 총 6개가 생길 것이다.</p>

<p>이 결과 코드의 가독성이 떨어지고 정상적인 로직과 예외 처리도 섞여있을 가능성이 크다.</p>

<p>이런 현상을 콜백지옥(Callback Hell)이라고 한다.</p>

<p><br /></p>

<p>하지만 이러한 콜백지옥을 Rx 스케줄러를 이용하면 해결할 수 있다.</p>

<p>아래 코드는 RxJava로 콜백 지옥을 해결한 모습을 보여줄 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"https://~~~"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">io</span><span class="o">())</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">OkHttpHelper:</span><span class="o">:</span><span class="n">get</span><span class="o">)</span>
    <span class="o">.</span><span class="na">concatWith</span><span class="o">(</span><span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"https://~~두번째URL"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">OkHttpHelper:</span><span class="o">:</span><span class="n">get</span><span class="o">));</span>
<span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">();</span>
</code></pre></div></div>

<p>IO 스케줄러를 이용해 네크워크 처리를 할 것이라는 것을 subscribeOn() 연산자를 통해 명시하였고, concatWith() 함수를 통해 현재의 Observable에 새로운 Observable을 결합하여 해결하였다.</p>

<p>위 코드는 OkHttpHelper클래스의 get() 함수에는 서버 통신에 필요한 enqueue() 메소드가 정의되어 있다고 가정한 코드이다.</p>

<p>이처럼 Rx 스케줄러로 네트워크 통신을 처리하면 비즈니스 로직과 비동기 프로그래밍을 분리할 수 있어 프로그램의 효율을 향상시킬 수 있다.</p>

<p><br /></p>

<h2 id="-observeon-함수-사용하기">🧾 observeOn() 함수 사용하기</h2>
<hr />

<p>지금까지는 subscribeOn() 함수를 통해 스케줄러를 사용한 예시만 공부했었다.</p>

<p>그러나 스케줄러의 핵심은 스케줄러의 종류를 선택한 후 subscribeOn() 과 observeOn() 함수를 호출하는 것이다.</p>

<p>스케줄러 초반에 알아본 아래 마블 다이어그램으로 다시 한번 subscribeOn() 과 observeOn() 의 차이를 짚어보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/81899016-d406dd80-95f4-11ea-8ac4-300668e6b370.PNG" alt="13" /></p>

<p><br /></p>

<ul>
  <li>
    <p>subscribeOn() 함수는 Observable에서 구독자가 subscribe() 함수를 호출했을 때 데이터 흐름을 발행하는 스레드를 지정해주는 함수이다.</p>

    <p>subscribeOn() 함수는 처음 지정한 스레드를 고정시키므로 다시 subscribeOn() 함수를 호출해도 두 번째 subsribeOn() 함수는 무시한다는 특징이 있다.</p>
  </li>
  <li>
    <p>반면 observeOn() 함수는 처리된 결과를 구독자에게 전달하는 스레드를 지정해주는 함수이다.</p>
  </li>
</ul>

<p><br /></p>

<p>일단 위 마블 다이어그램에서 가장 먼저 나오는 subsribeOn() 함수는 파란색 스레드를 인자로 가지고 있다.</p>

<p>즉, 위 Observable을 구독자가 subscribe 하면 데이터를 발행하는 스레드는 파란색 스레드로 고정된다는 의미이다.</p>

<p>그렇다면 위 다이어그램에서 가장 먼저 나오는 observeOn() 함수는 주황색 스레드를 인자로 가지고 있다.</p>

<p>즉, observeOn()이 호출된 후부터는 주황색 스레드에서 작업이 실행된다는 의미이다.</p>

<p>따라서 마블 다이어그램의 map() 함수는 스레드 변경과는 상관 없는 함수이므로 계속 주황색 스레드에서 실행이 된다.</p>

<p>마지막으로 분홍색 스레드를 인자로 갖는 observeOn() 이 호출되면 그 다음 데이터 흐름은 분홍색 스레드에서 실행된다.</p>

<p><br /></p>

<p>지금까지 Rx 프로그래밍의 스케줄러에 대해서 공부해보았다.</p>

<p>안드로이드 앱과 같은 UI 프로그래밍을 하려면 스케줄러에 대한 이해가 필수적이고, 특히 observeOn() 함수가 매우 유용하다!!</p>

<p><br /></p>


  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

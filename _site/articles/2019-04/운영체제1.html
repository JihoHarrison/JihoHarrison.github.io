<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  1강 - Introduction to Operating Systems  🙋 1강에서 설명할 수 있어야 할 것들 🙋      운영체제란    하드웨어에 속하는 것들과 각각의 특징    운영체...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[OS] 운영체제1 | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[OS] 운영체제1 | choheeis">
  <meta name="twitter:description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  1강 - Introduction to Operating Systems  🙋 1강에서 설명할 수 있어야 할 것들 🙋      운영체제란    하드웨어에 속하는 것들과 각각의 특징    운영체...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2019-04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C1">
  <meta property="og:title" content="[OS] 운영체제1 | choheeis">
  <meta property="og:description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  1강 - Introduction to Operating Systems  🙋 1강에서 설명할 수 있어야 할 것들 🙋      운영체제란    하드웨어에 속하는 것들과 각각의 특징    운영체...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[OS] 운영체제1 | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2019-04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C1">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[OS] 운영체제1">[OS] 운영체제1</h1>
    <span class="post-meta">
      <span class="post-date">
        3 APR 2019
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    12 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p>서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆</p>

  <p><em>1강 - Introduction to Operating Systems</em></p>

  <p>🙋 1강에서 설명할 수 있어야 할 것들 🙋</p>

  <ul>
    <li>운영체제란</li>
    <li>하드웨어에 속하는 것들과 각각의 특징</li>
    <li>운영체제가 가지는 특징</li>
    <li>프로세스 관리</li>
    <li>메모리 관리</li>
    <li>가상머신</li>
  </ul>
</blockquote>

<p><br /></p>

<h2 id="-운영체제를-정의-해보자">☺ ‘운영체제’를 ‘정의’ 해보자!</h2>
<hr />

<ul>
  <li>
    <p>운영체제를 정의하기 위해서는 기본적으로 컴퓨터 시스템이 4가지 구성요소로 이루어져 있다는 것을 알아야한다.</p>

    <p>컴퓨터시스템(computer system)에는 4가지 구성요소가 있는데,</p>

    <ul>
      <li>최상위 요소 : <strong>Users</strong> (말그대로 컴퓨터를 사용하는 유저)</li>
      <li>세번째 요소 : <strong>Applications</strong> (워드 프로세서, 웹 브라우저, 게임 등등 유저가 사용하는 프로그램들. 유저가 필요할 때 설치하고 사용하지 않을 때는 지우기도 하는 것들, 사용자가 필요할 때만 실행되는 것들)</li>
      <li>두번째 요소 : <strong>Operating Systems</strong> (운영체제)</li>
      <li>
        <p>최하위 요소 : <strong>Hardware</strong> (컴퓨터 부품들, CPU, 메모리, 입출력장치 등)</p>

        <p><img src="https://user-images.githubusercontent.com/31889335/55477789-f50ca900-5654-11e9-8504-96a77e025d82.PNG" alt="운영체제1" /></p>

        <p>컴퓨터가 부팅되면 하드웨어 위에서 운영체제가 제일 먼저 가동되고 운영체제가 각 어플리케이션의 실행을 관리한다</p>

        <p>위 그림에서 볼 수 있듯이 유저는 운영체제에 직접 접근할 수 없다. 어플리케이션을 통해서 운영체제나 하드웨어에 접근할 수 있다.</p>

        <p>예 ) 유저는 프린트를 하려고 프린터를 실행시키고 싶으면 프린터 실행 프로그램(인쇄 프로그램)을 실행시켜야 하지!</p>
      </li>
    </ul>
  </li>
  <li>
    <p>운영체제가 뭘까?</p>

    <p>운영체제는 영어로 Operating system 이라고 하고 줄여서 OS라고 한다.</p>

    <p>운영체제는 위 그림에서 알 수 있듯이 컴퓨터 시스템의 4가지 구성요소 중 어플리케이션과 하드웨어를 중개하는 중개인 역할을 하는 시스템이다.</p>
  </li>
  <li>
    <p>사용자들의 시점에서 본 운영체제의 역할</p>

    <p>사용자들의 thinking about OS !</p>

    <blockquote>
      <p>운영체제는 어플리케이션을 수행시키고, 사용자들이 컴퓨터 시스템을 사용하기 편리하도록 만드는 시스템이다.</p>
    </blockquote>
  </li>
  <li>
    <p>컴퓨터시스템의 시점에서 본 운영체제의 역할</p>

    <p>컴퓨터의 thinking about OS !</p>

    <blockquote>
      <p>운영체제는 자원 할당자이다. 그리고, 프로그램들을 컨트롤한다. 즉, 운영체제는 어플리케이션이나 입출력장치의 동작을 컨트롤 한다.</p>

      <p><em>여기서 말하는 <strong>자원</strong> 이란 뭘까</em></p>

      <p>자원은 두가지로 분류되는데 <strong>하드웨어 자원</strong> 과 <strong>소프트웨어 자원</strong> 으로 나눌 수 있다.</p>

      <ol>
        <li>하드웨어 자원 = CPU, 메모리, 입출력 장치</li>
        <li>소프트웨어 자원 = 파일들, 소켓 등등</li>
      </ol>

      <p>이 자원들이 관리되어야 하는 이유는 자원은 무한하지 않고 한정되어 있기 때문이다!</p>
    </blockquote>
  </li>
  <li>
    <p>자자! 운영체제가 뭔지를 한줄로 정리해보면?! (출제율↑)</p>

    <p><strong>어플리케이션과 하드웨어 중간에서 하드웨어 자원(리소스)를 적절하고 효율적으로 관리하는 것!</strong></p>
  </li>
  <li>
    <p>우리 일상생활에서 어떤 것들을 운영체제라고 할까?</p>

    <p>마이크로소프트의 윈도우, 유닉스, 리눅스, 안드로이드, iOS 등등이 운영체제의 종류이다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="️-컴퓨터-시스템-작동-방식">⚡️ 컴퓨터 시스템 작동 방식</h2>
<hr />

<ul>
  <li>
    <p>컴퓨터 시스템의 구성요소 중 하나인 하드웨어는 CPU, 메모리, Disk controller, USB controller, Graphics Adapter 가 하나의 bus로 연결되어 있는 구조이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/55482565-c47e3c80-565f-11e9-8edf-05174837c389.PNG" alt="운영체네2" /></p>

    <p>디스크 컨트롤러는 다시 하드디스크를 연결하고, USB 컨트롤러는 다시 키보드, 마우스, 프린터 등을 연결한다.</p>

    <p>이때, 컨트롤러는 디바이스(예를 들어, 프린터기)를 구동시키는 프로그램이다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>CPU</em></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/55970562-bb721880-5cba-11e9-94c1-99e625a3894f.PNG" alt="운영체제3" /></p>

    <p>위 그림은 CPU의 모습을 나타낸 그림이다. CPU에는 주로 인텔 같은 CPU 회사 이름이 써있는 경우가 많다.</p>

    <p>각 입출력 디바이스 컨트롤러는 local 버퍼(자기 자신의 버퍼 = 조그만 메모리 공간)를 가지고 있다.</p>

    <p>이 버퍼에 임시로 데이터를 잠깐 저장한다.</p>

    <p>마찬가지로 디스크 컨트롤러도 local 버퍼를 갖는데 디스크와 디스크 컨트롤러 버퍼간에 데이터를 주고 받을 때 데이터 임시 저장 공간으로 버퍼를 사용한다.</p>

    <p>CPU는 메인 메모리와 디바이스 컨트롤러의 버퍼간에 데이터를 이동시킨다.
  <br /></p>
  </li>
  <li>
    <p><em>CPU와 입출력 장치들 간의 관계는 독립적이다</em></p>

    <p>CPU와 입출력 장치들은 서로 독립적으로 수행될 수 있다. 만약 CPU가 다른 일을 하고 있을 때 입출력 장치는 CPU가 그 일을 다 마칠때까지 기다려야 할까?</p>

    <p>만약 CPU가 필요하지 않은 작업이라면 CPU가 마칠때까지 기다리지 않고 독자적으로 수행될 수 있다.</p>

    <p>디바이스 컨트롤러는 어떤 디바이스의 수행이 종료되었음을 <strong>interrupt(중단)</strong> 을 발생시켜서 CPU에게 알려준다.</p>

    <p>예를 들어, 마우스를 관리하는 디바이스 컨트롤러는 마우스 클릭이 한번 끝날 때마다 interrpt를 발생시킨다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>interrupt 핸들링</em></p>

    <p>만약 디바이스 컨트롤러가 CPU에게 interrupt를 발생시켜서 CPU가 알게되면 CPU는 자신이 하던 일을 멈추고 ISR을 발생시킨다.</p>

    <p><strong>ISR = Interrupt Service Routine</strong></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/55971672-e78e9900-5cbc-11e9-9e65-b8e0e318607a.PNG" alt="운영체제4" /></p>

    <p>위 그림에서 민트색으로 표현된 구조를 <strong>interrupt vector 테이블</strong> 이라고 한다.</p>

    <p>이 vector 테이블에는 키보드 interrupt, 마우스 interrupt, 프린트 interrupt, 디스크 interrupt 등 각각의 디바이스에 대한 interrupt 공간이 있다.</p>

    <p>이 테이블에는 각각의 interrupt가 발생하면 어떻게 해야하는지( = interrupt service)가 저장이 되어있다.</p>

    <p>프로그램을 수행하면서 디바이스 컨트롤러에 의해 각각의 interrupt가 발생하면 vector 테이블에서 해당 interrupt 발생 시 정보가 저장되어 있는 칸으로 이동한다.</p>

    <p>하지만, 이 vector 테이블이 직접 칸에 저장된 서비스대로 수행시키는 것이 아니라 이 서비스는 ISR이 수행시키는 것이다.</p>

    <p>ISR에 의한 서비스 수행이 끝나면 interrupt가 발생된 결과로 중단되었던 CPU가 다시 실행된다.</p>

    <p><em>결국, CPU가 뭔가를 수행하고 있어도 interrupt가 발생하면 자신이 하던 일을 멈추고 발생한 interrupt에 해당하는 서비스를 해야한다는 것이다.</em></p>

    <p>즉, CPU는 사실 엄청 많이 중단되었다가 실행되기를 반복하고 있다. 하지만 CPU가 너무나도 빨라서 중단되지 않는 것으로 보이는 것이다!</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56131190-c500c680-5fc1-11e9-95e8-caddd2b2fc97.PNG" alt="운영체제20" /></p>

    <p>위 그림은 입출력장치의 실행이 끝난 후 CPU에서 ISR이 실행되는 모습을 나타낸 것이다.</p>

    <p>idle(=쉬고 있는)</p>

    <p>위 그림을 보면 입출력장치가 transfer 상태(실행되는 상태)에서 idle 상태(쉬고있는 상태 = 즉, 입출력 행위가 끝난 상태)로 변경되면 디바이스 컨트롤러가 intterupt를 발생시킨다.</p>

    <p>그럼 프로그램을 실행시키고 있던 CPU가 프로그램 실행을 멈추고 ISR을 실행시키는 모습을 확인할 수 있다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="-저장-장치들">🍄 저장 장치들</h2>
<hr />

<ul>
  <li>
    <p><em>메인 메모리(1차 저장소)</em></p>

    <p>CPU가 직접 바로 엑세스할 수 있는 저장장치이다.</p>

    <p><strong>DRAM( = Dynamic Random Access Memory )</strong> 이라고도 한다.</p>

    <p>하지만 휘발성이 있어서 전원을 끄면 메인 메모리에 저장한 데이터들이 날아간다. 그래서 HDD나 SSD 같은 2차 저장소를 사용해서 저장해야 한다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>2차 저장소들</em></p>

    <p>2차 저장소들인 <strong>HDD(하드디스크)</strong>, <strong>SSD(Solid State Drive)</strong>, <strong>flash memory</strong> 등은 휘발성이 없어서 전원을 꺼도 데이터가 사라지지 않으며, 저장공간이 매우 넓다. 단, CPU가 직접 이 저장소들에 접근하지 않는다!</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/55972895-5c62d280-5cbf-11e9-9bd2-d815a545a651.PNG" alt="운영체제5" /></p>

    <p><br /></p>
  </li>
  <li>
    <p><em>저장소들을 비교해보자!</em></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/55973063-c24f5a00-5cbf-11e9-8c1b-d7e905fb014c.PNG" alt="운영체제6" /></p>

    <p>위 그림의 각 항목들은 모두 컴퓨터 시스템에서 사용되는 데이터 저장 공간들이다.</p>

    <p>레지스터 쪽으로 갈수록 속도가 빨라지지만 가격이 비싸고, 저장용량이 적어진다.</p>

    <p>SRAM(CPU 캐시)은 CPU 안에 있는 저장장치로, 인텔 CPU의 i5와 i7의 차이점 중 SRAM 차이도 포함된다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>캐시에 대해서 더 알아보자</em></p>

    <p>CPU 캐시가 언제 사용될까?</p>

    <p>하드디스크에 있는 데이터는 메인 메모리로 올라와진다. 또, 메인 메모리로 올라온 데이터는 CPU 캐시로 올라와진다. 최종적으로 CPU 캐시에 있는 데이터들은 레지스터로 올라온다.</p>

    <p>CPU 가까이에 데이터를 놓을 수 있는 저장소가 CPU 캐시(SRAM)이다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>“캐싱한다” 는 무슨 말일까?</em></p>

    <p>“캐싱한다” 는 것에 대한 설명을 해보자. 일단 CPU가 어떤 데이터를 얻고자 한다면 얻고자 하는 데이터가 하드디스크에 있는지를 체크한다. 하드디스크에 해당 데이터가 있다면 메인 메모리로 가지고 오고, CPU 캐시에 넣어놓는다.</p>

    <p>이 데이터를 CPU 캐시에 계속 넣어놓으면 CPU가 다음에도 같은 데이터를 원할 때 하드디스크까지 가서 데이터 여부를 확인하지 않고, 바로 CPU 캐시에서 데이터를 찾을 수 있다.</p>

    <p>즉, CPU가 요청하는 데이터가 CPU 캐시에 있는지를 먼저 확인한다. 만약 캐시에 해당 데이터가 있다면 하드디스크까지 가지 않고 CPU 캐시에 있는 데이터를 바로 사용할 수 있다.</p>

    <p>만약 CPU 캐시에 해당 데이터가 없어서 하드디스크까지 갔다 와야 하는 상황이라면 이 때는 다음번을 위해 그 데이터를 CPU 캐시에 복사해서 가져다 놓는다.</p>

    <p>캐시는 CPU 캐시 개념에서만 쓰이는 개념이 아니다.</p>

    <p>다양한 곳에서 캐시라는 개념이 사용되는데 CPU 캐시 외에도 <strong>OS 버퍼 캐시</strong>, <strong>디스크 캐시</strong>, <strong>웹 캐시</strong> 등 다양한 곳에서 캐시 개념이 사용된다.</p>

    <p>일반적으로 캐시의 크기는 제한적이다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>캐시 데이터 일치(coherency)</em></p>

    <p>캐시에 저장된 데이터들은 반드시 일치되어야 한다!</p>

    <p>무슨말이냐면</p>

    <p>만약 두 개의 프로그램이 실행되고 있는데 이 두 개의 프로그램은 메인메모리를 공유하고 있고, 각자는 로컬 캐시를 가지고 있다고 하자.</p>

    <p>즉, 아래 그림과 같이</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56132812-e5cb1b00-5fc5-11e9-8870-b39faef9fd15.PNG" alt="운영체제21" /></p>

    <p>각 프로그램을 실행 중인 각 클라이언트가 메인메모리는 공유하되, 자신만의 캐시 저장소를 가지고 있는 것이다.</p>

    <p>이 때, 메인 메모리에 변수 X가 올라왔고, 이 변수에 0이 저장되어 있다고 하자.</p>

    <p>만약 이 때, 클라이언트 A가 X에 데이터 1을 저장한 후, 클라이언트 B가 변수 X를 읽어들이게 될 경우 A에 의해 변경된 1을 읽게 되는 것이 아니라 0을 읽어들이게 된다.</p>

    <p>즉, 데이터 불일치 문제가 발생한 상황이다.</p>

    <p>따라서 메모리를 공유하는 방식으로 실행되고 있는 상황에서는 메모리에서 올라온 각 프로그램의 캐시 데이터가 일치되어야 한다는 것이 <strong>캐시 일관성</strong> 개념이다.</p>

    <p>캐시 일관성을 유지하기 위해서는 다른 프로세서가 갱신한 캐시 값을 곧바로 다른 프로세서에서 사용할 수 있도록 해주어야 한다. 캐시 일관성을 유지하기 위한 다양한 프로토콜과 일관성 모델이 존재한다.</p>

    <p>이와 같은 캐시 일관성 문제는 멀티 프로세서 환경에서 중요하다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-운영체제의-특징">👙 운영체제의 특징</h2>
<hr />

<ul>
  <li>
    <p><em>멀티프로그래밍</em></p>

    <p>운영체제는 여러 개의 프로그램을 동시에 수행시킬 수 있는 특징이 있다.</p>

    <p>멀티 프로그램이 실행될 때, 한 프로그램이 독자적으로 계속 CPU를 차지할까?</p>

    <p>아니다! 하나의 프로그램이 자신의 실행이 끝날 때까지 CPU를 차지하지 않는다!</p>

    <p>만약 자신의 실행이 끝날때까지 CPU를 차지한다면 그 프로그램이 끝날 때까지 다른 프로그램들이 실행되지 못하고 기다리고 있어야 할 것이다..</p>

    <p>설명을 조금 더 보충하자면!!</p>

    <p>여러개의 실행을 위해 메인 메모리에 올라온 프로그램들이 같은 시간동안 메인메모리에 붙잡혀 있을 수 있다는 것이다.</p>

    <p>그리고, 한 프로그램이 독자적으로 CPU를 차지하지 않는다는 말은 CPU는 실행되는 중에는 하나의 프로그램을 실행시키지만 이 프로그램을 끝까지 실행시키고 있지는 않는다는 의미이다.</p>

    <p><strong>스케줄러</strong> 에 의해 메인 메모리에 올라온 여러 프로그램 중 하나가 선택되고, 선택된 프로그램이 수행되다가 다른 프로그램으로 교체된다. 다른 프로그램으로 교체되면 원래 실행되고 있던 프로그램이 다시 자신이 선택되기를 기다려야 한다.</p>

    <p>즉, CPU가 여러 프로그램을 돌려가며 실행시킨다는 것이다!</p>

    <p>이런 특징 때문에 유저들은 여러 프로그램과 상호작용을 할 수 있게 된다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>타임쉐어링(Timesharing = 시간공유)</em></p>

    <p>CPU에게 만약 1초라는 시간이 주어진다면 CPU는 0.1초는 1번 프로그램을 실행시키는데 쓰고, 0.1초는 2번 프로그램을 실행시키는데 쓴다.</p>

    <p>타임쉐어링은 유닉스라는 운영체제에서 가장 잘 실행되고 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>OS는 이벤트가 발생하기를 기다리고 있는 시스템이라고 보면 된다</em></p>

    <p>프로그램이 실행되고 있지도, 입출력 요청이 있지도 않다면 운영체제는 어떠한 이벤트라도 일어나기를 조용히 기다리고 있다.</p>

    <p>운영체제가 기다리는 이벤트에는 <strong>하드웨어 interrupt</strong> , <strong>유효하지 않은 메모리 엑세스</strong>, <strong>시스템 콜</strong>, <strong>무한 루프 에러</strong> 등이 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>듀얼 모드(Dual mode)</em></p>

    <p>운영체제에는 두 가지 모드가 존재한다.</p>

    <p><strong>유저 모드</strong></p>

    <p><strong>커널 모드</strong></p>

    <p>운영체제가 무언가를 수행하는 모드는 <strong>커널 모드</strong> 라고 하고, <strong>유저 모드</strong> 는 유저가 무언가를 수행하는 모드이다.</p>

    <p>유저 모드는 비트 1로 설명하고, 커널 모드는 비트 0으로 설명된다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56137685-5840f880-5fd0-11e9-8071-b445b7c3a065.PNG" alt="운영체제22" /></p>

    <p>위 그림과 같이 유저가 어떤 프로세스를 실행하여 시스템 콜이 호출되는 부분까지는 유저모드로 분류된다.</p>

    <p>그 후에 시스템 콜이 실행되는 부분은 커널모드로 분류되고, 시스템 콜이 종료되어 비트 1을 반환받으면 다시 유저모드로 분류된다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="--프로세스-관리하기process-management">😎  프로세스 관리하기(Process Management)</h2>
<hr />

<ul>
  <li>
    <p><em>프로세스(Process)가 뭘까?</em></p>

    <p>프로세스는 지금 실행되고 있는 프로그램을 말한다.</p>

    <blockquote>
      <p>잉? 프로그램과 프로세스의 차이가 정확히 뭐지?</p>
    </blockquote>

    <p>프로세스는 능동적이고 프로그램은 수동적이다.</p>

    <p>무슨 말이냐 하면 <strong>프로그램</strong> 은 아직 실행되지 않은 실행할 수 있는 파일이고, <strong>프로세스</strong> 는 메모리에 올라와 CPU를 할당받고 실행되고 있는 프로그램이다.</p>

    <p>프로세스는 여러가지 자원(resource)들을 필요로 한다. 예를 들어, CPU, 메모리, 입출력장치들, 파일들 등등!</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>프로세스를 “관리한다”에 속하는 것들</em></p>

    <ul>
      <li>CPU를 사용하는 프로세스들의 스케줄 관리</li>
      <li>프로세스 생성 및 삭제</li>
      <li>프로세스 동기화</li>
      <li>프로세스들 간의 커뮤니티</li>
      <li>deadlock(데드락) 핸들링</li>
    </ul>

    <p><br /></p>
  </li>
</ul>

<h2 id="-메모리-관리하기memory-management">💽 메모리 관리하기(Memory Management)</h2>
<hr />

<ul>
  <li>
    <p><em>메모리를 “관리한다”에 속하는 것들</em></p>

    <ul>
      <li>메모리의 어떤 부분을 누구에게 줄 것인가 결정</li>
      <li>어떤 프로세스와 어떤 데이터가 메모리로 올려질 것인가를 결정</li>
    </ul>

    <p>메모리가 한정적이기 때문에 위의 항목들을 메모리 관리자가 잘 결정해야 한다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>가상 메모리 시스템</em></p>

    <p>운영체제는 <strong>가상 메모리</strong> 라는 개념을 지원한다.</p>

    <p>가상 메모리는 실제 존재하지는 않지만 사용자에게 있어 메모리로써의 역할을 하는 메모리이다.</p>

    <p>이 때, 프로그램은 용량이 큰 가상메모리의 크기에 맞춰 수용되지만 실제 실행될 때는 실제 물리 메모리를 필요로 한다.</p>

    <blockquote>
      <p>가상 메모리가 사용되는 경우는 어떤 경우일까?</p>
    </blockquote>

    <p>예를 들어, 전공 서적 100권이 필요한데 내 책상은 100권을 모두 놓을 수 없고, 50권의 책만 놓을 수 있다고 하자. 그렇다면 책상에 놓지 않을 50권의 책을 고르려고 고민을 해야만 한다.</p>

    <p>하지만 만약 책장이 있어서 100권의 책을 책장에 놓고, 필요한 책들만 책상으로 가져올 수 있다면? 너무 좋을 것이다.</p>

    <p>이와 같이 실제 메인 메모리보다 용량이 큰 가상 메모리에 프로그램을 올려놓고, 메인 메모리에는 필요한 부분만을 옮겨오는 방식이 가상 메모리 방식이다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-저장소-관리하기storage-management">💾 저장소 관리하기(Storage Management)</h2>
<hr />

<ul>
  <li>
    <p><em>운영체제는 정보 저장에 대한 논리적이고 통일된 저장소를 제공한다.</em></p>

    <ul>
      <li>
        <p>파일과 파일 시스템</p>

        <p>데이터를 저장할 때 파일을 주로 많이 사용한다. 파일은 소프트웨어적인 저장공간이다.</p>

        <p>파일 시스템을 통해 파일에 데이터를 저장하고, 수정한다.</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><em>파일 시스템이 하는 일</em></p>

    <ul>
      <li>파일과 디렉토리를 생성 및 삭제한다.</li>
      <li>파일과 디렉토리를 조작(수정)한다.</li>
      <li>파일을 실제 저장소와 어떻게 매핑 시킬 것인지를 관리한다.</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><em>대용량 저장소 관리자</em></p>

    <p>보통 대용량 데이터를 저장할 때는 저장 공간이 대용량인 디스크를 많이 사용한다.</p>

    <p>따라서 컴퓨터 속도는 디스크 시스템과 디스크 알고리즘에 의해 많이 좌우된다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-io-서브-시스템subsystem">📺 I/O 서브 시스템(SubSystem)</h2>
<hr />

<ul>
  <li>
    <p><em>운영체제의 목적 중 하나는 유저로부터 하드웨어의 특색을 숨기는 것에 있다</em></p>

    <p>유저로부터 하드웨어를 숨기는 것은 여러 I/O 서브 시스템들을 사용함으로서 실행된다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>I/O 서브 시스템들은 다음과 같은 요소들로 구성되어 있다</em></p>

    <ul>
      <li>일반적인 디바이스 드라이버 인터페이스</li>
      <li>특정 하드웨어를 위한 드라이버</li>
      <li>I/O 디바이스들의 메모리 관리자(버퍼, 캐시 등)</li>
    </ul>

    <p>디바이스 마다 디바이스 드라이버가 존재한다. 이 디바이스 드라이버도 운영체제의 일부이다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-특별한-목적을-위한-시스템들">🌀 특별한 목적을 위한 시스템들</h2>
<hr />

<ul>
  <li>
    <p><em>리얼 타임 시스템</em></p>

    <p>리얼 타임 운영체제를 말하는 것이다.</p>

    <p>real time = <strong>실시간</strong></p>

    <p>리얼 타임 시스템은 deadline(마감 시간)을 중요시 하는 목적을 가진 시스템에 사용된다. 즉, 요청에 의한 응답시간이 실시간으로 수행되어야 하는 시스템에 사용된다.</p>

    <p><strong>미사일 제어 시스템</strong> 이나 <strong>운전 시스템</strong> , <strong>의료 기계 시스템</strong> 에 사용되는 운영체제가 리얼 타임 시스템 운영체제에 속한다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>멀티미디어 시스템</em></p>

    <p>멀티미디어에 최적화 해놓은 시스템으로 MP3 플레이어, DVD 플레이어 등을 잘 관리하는 시스템이다.</p>

    <p>멀티미디어 시스템도 약간의 리얼타임 시스템이 요구된다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-가상-머신virtual-machine">💭 가상 머신(Virtual Machine)</h2>
<hr />

<ul>
  <li>
    <p><em>가상머신이 뭐지?</em></p>

    <p>가상머신은 <strong>여러 개의 다른 환경을 제공</strong> 해주는 추상적인 모습의 <strong>단일 컴퓨터</strong> 이다.</p>

    <p>무슨 말이냐면 하나의 PC에서 종류가 다른 여러 운영체제를 실행하려 할 때 사용되는 것이 가상머신이라는 말이다.</p>

    <p>가상 머신을 사용하지 않으면 실제로 여러개의 다른 OS를 한 컴퓨터에서 수행시킬 수 없다.</p>

    <p>가상머신은 각각의 분리된 실행 환경이 하나의 컴퓨터에 환각적으로 생성된다.</p>

    <p>가상 머신을 줄여서 <strong>VM</strong> 이라고도 부른다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56140112-3302b900-5fd5-11e9-9e4b-52edd7dd9ed2.PNG" alt="운영체제23" /></p>

    <p>위 그림에서 볼 수 있듯이 가상머신이 아닌 경우에는 하드웨어에 커널(운영체제)를 올린다.</p>

    <p>반면, 가상머신의 경우에는 하드웨어 위에 가상머신을 실행시키고 각 가상머신을 분리된 하드웨어 위에 올린 후, 그 위에 각 커널을 올린다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>가상머신의 특징</em></p>

    <ul>
      <li>
        <p>가상머신은 시스템 리소스들을 완벽히 보호한다.</p>
      </li>
      <li>
        <p>가상머신 안에서 돌아가는 프로세스가 가상 머신이 제공하는 환경과 자원에 제한을 받으며 가상 세계를 벗어날 수 없다.</p>
      </li>
      <li>
        <p>가상머신들 간의 리소스 공유할 수 없다.</p>
      </li>
      <li>
        <p>가상머신은 개발하는 것을 편리하도록 도와준다.</p>
      </li>
      <li>
        <p>어플리케이션들을 다른 운영체제 환경에서 실행시켜 보면서 테스트 할 때 편리하다.</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><em>Vmware의 아키텍처(구조)</em></p>

    <p>Vmware은 <strong>가상머신</strong> + <strong>제품들(software 할 때의 ware이다)</strong> 을 뜻한다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56141504-e1a7f900-5fd7-11e9-8dc3-bf9974d0850b.PNG" alt="운영체제24" /></p>

    <p>위 그림은 가상머신의 구조를 시각화한 그림이다.</p>

    <p>일단 하드웨어 위에 host(주인) 운영체제가 올라간다.(리눅스라고 가정)</p>

    <p>host 운영체제 위에서 돌아가는 어플리케이션도 존재한다.</p>

    <p>가상 머신을 만들기 위해 host 운영체제 위에 가상 계층을 만든다.</p>

    <p>이 계층 위에 각각의 가상 메모리, 가상 CPU 등을 올리고 각 운영체제를 올리는 것이다.</p>
  </li>
</ul>


  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

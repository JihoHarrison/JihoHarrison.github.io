<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  3강 - Processes      프로세스란    address공간    프로세스의 5가지 상태    PCB란    CPU 스케줄러    context switch    프로세스가 생성되...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[OS] 운영체제3 | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[OS] 운영체제3 | choheeis">
  <meta name="twitter:description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  3강 - Processes      프로세스란    address공간    프로세스의 5가지 상태    PCB란    CPU 스케줄러    context switch    프로세스가 생성되...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2019-04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C3">
  <meta property="og:title" content="[OS] 운영체제3 | choheeis">
  <meta property="og:description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  3강 - Processes      프로세스란    address공간    프로세스의 5가지 상태    PCB란    CPU 스케줄러    context switch    프로세스가 생성되...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[OS] 운영체제3 | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2019-04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C3">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[OS] 운영체제3">[OS] 운영체제3</h1>
    <span class="post-meta">
      <span class="post-date">
        13 APR 2019
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    11 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p>서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆</p>

  <p><em>3강 - Processes</em></p>

  <ul>
    <li>프로세스란</li>
    <li>address공간</li>
    <li>프로세스의 5가지 상태</li>
    <li>PCB란</li>
    <li>CPU 스케줄러</li>
    <li>context switch</li>
    <li>프로세스가 생성되는 방식</li>
    <li>생산자-소비자 문제</li>
    <li>동기화</li>
  </ul>
</blockquote>

<p><br /></p>

<h2 id="-프로세스process">🚿 프로세스(Process)</h2>
<hr />

<ul>
  <li>
    <p><em>프로세스란?</em></p>

    <p>프로그램들 중 <strong>실행되고 있는 프로그램</strong> 을 프로세스라고 한다!</p>

    <p>종종 task 라는 용어를 들을 수 있는데 이 task도 프로세스를 말하는 것이다.</p>

    <p><br /></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56074981-1a887800-5df6-11e9-8626-e35ffdf7bd41.PNG" alt="운영체제11" /></p>

    <p>위 그림은 프로세스가 실행될 때 a메모리에 생기는 Address(주소) 공간이다.</p>

    <ul>
      <li>
        <p><strong>text 부분</strong> = 해당 프로그램의 코드가 들어가는 부분</p>
      </li>
      <li>
        <p><strong>data 부분</strong> = 전역변수, static 변수들이 들어가는 부분</p>
      </li>
      <li>
        <p><strong>Stack 부분</strong> = 일시적인 데이터가 들어가는 부분( 함수, 함수의 매개변수, 지역변수, 리턴되야하는 주소값 등)</p>

        <p>스택은 용량이 늘어나고 줄어드는 것이 가능하기 때문에 함수가 호출되면 스택이 늘어나고, 함수가 끝나면 스택이 줄어든다!</p>
      </li>
      <li>
        <p><strong>Heap 부분</strong> = 런타임동안 동적으로 할당되는 메모리가 들어가는 부분 ( 힙 영역도 늘어나기도 하고 줄어들기도 한다. )</p>
      </li>
    </ul>

    <p>이때, 텍스트와 데이터 영역은 크기가 변하지 않고 고정되어있다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-프로세스-상태">😐 프로세스 상태</h2>
<hr />

<ul>
  <li>
    <p><em>프로세스가 실행되면 프로세스의 상태가 바뀐다!</em></p>

    <p>총 5개의 프로세스의 상태가 존재한다.</p>

    <p><strong>New</strong> 상태 (프로세스가 생성될 때의 상태)</p>

    <p><strong>Running</strong> 상태 (프로세스가 실행되고 있는 상태)</p>

    <p><strong>Waiting</strong> 상태 (running 상태는 아닌데 어떤 이벤트가 발생하기를 기다리는 상태이다. 즉, cpu가 할당되기 전에 이벤트를 기다리고 있는 상태이다. 이벤트를 받아야 CPU 할당을 받을 수 있다.)</p>

    <p>blocked 상태 또는 sleep 상태 라고도 한다.</p>

    <p><strong>Ready</strong> 상태 (CPU가 할당되기를 기다리고 있는 상태)</p>

    <p><strong>Terminated</strong> 상태 (프로세스가 종료된 상태)</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56075083-c7172980-5df7-11e9-92c5-d24fa5dcaefd.PNG" alt="운영체제12" /></p>

    <p>위 그림은 프로세스의 상태가 변하는 모습을 다이어그램으로 나타낸 그림이다.</p>

    <p>새로운 프로세스가 생성(new 상태)되면 ready 상태로 바뀐다.</p>

    <p>ready 상태에서 <strong>스케줄러 디스패치(scheduler dispatch)</strong> 에 의해 선택된 프로세스에 CPU가 할당된다. 즉, running 상태로 바뀌는 것이다.</p>

    <p>프로세스는 cpu를 할당받아서 running 하는데 이 때 혼자만 계속 cpu를 사용할 수는 없다.  <strong>타임 슬라이스(time slice)</strong> 라고 하는 정해진 시간 만큼 cpu를 쓰다가 다시 ready 상태 줄의 맨 뒤로 돌아간다.</p>

    <p>만약 프로세스가 입출력을 수행해야 하는 프로세스라면 I/O 이벤트를 기다리는 상태인 waiting 상태가 된다. I/O 이벤트가 완료되면 다시 ready 상태의 줄 뒤로 이동하고, 스케줄러에 의해 cpu를 다시 할당 받아서 프로세스 작업을 이어서 한다.</p>

    <p>이 과정을 반복한 후 유저가 프로그램을 종료하면 프로세스가 종료된다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="️-프로세스-control-블록">♒️ 프로세스 Control 블록</h2>
<hr />

<ul>
  <li>
    <p><em>프로세스 Control 블록이란?</em></p>

    <p>Process Control Block의 줄임말인 PCB라고 명칭하기도 한다.</p>

    <p>PCB는 프로세스에 관한 데이터(메타데이터)가 저장된 공간이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56075245-51f92380-5dfa-11e9-9dbd-934414e1a788.PNG" alt="운영체제13" /></p>

    <p>PCB는 위와 같은 모습으로 되어있다. 커널 안에 현재 실행중인 프로세스 별 PCB들이 존재하는 모습이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56075258-8a006680-5dfa-11e9-8e77-25b6936d2bbc.PNG" alt="운영체제14" /></p>

    <p>PCB의 구조를 자세히 살펴보면 위와 같다.</p>

    <p>해당 프로세스의 ID, 프로세스 상태, 프로그램 counter, 레지스터, 우선순위 등의 정보가 담겨있다.</p>

    <p><strong>program counter</strong> 은 프로그램 계수기라고 하며 이 프로세스가 다음에 실행할 명령어가 있는 주소를 가리킨다.</p>

    <p><strong>priority(우선순위)</strong> 에는 이 프로세스가 중요한 프로세스여서 CPU할당을 빨리 받아야 하는지 아닌지에 대한 정보가 저장된다.</p>

    <p>리눅스 운영체제에서는 PCB를 <strong>task_struct</strong> 라고 한다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-프로세스-스케줄링-큐queue">📜 프로세스 스케줄링 큐(Queue)</h2>
<hr />

<ul>
  <li>
    <p>프로세스 스케줄링 큐에는 <strong>레디(ready) 큐</strong> 와 <strong>디바이스(device) 큐</strong> 가 있다.</p>
  </li>
  <li>
    <p><em>레디 큐</em></p>

    <p>메인 메모리에 올라가 있으면서 수행을 기다리고 있는 모든 프로세스들의 집합을 말한다.</p>

    <p>큐에 있다고 하는 것은 순서를 지켜 한 줄로 기다리고 있음을 의미한다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>디바이스 큐</em></p>

    <p>어떤 I/O 디바이스의 이벤트를 기다리고 있는 프로세스들의 집합이다.</p>

    <p>프로세스들은 레디 큐와  디바이스 큐 사이에 왔다갔다 하는데 즉, 디바이스 큐에서 나와서 레디 큐로 들어갈 수도 있고, 레디 큐에서 나와서 디바이스 큐로 들어갈 수도 있다는 것이다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-스케줄러scheduler">📝 스케줄러(Scheduler)</h2>
<hr />

<ul>
  <li>
    <p><em>CPU 스케줄러</em></p>

    <p>스케줄러는 CPU 스케줄러를 말한다.</p>

    <p>CPU 스케줄러는 현재 수행되고 있는 프로세스가 타임 슬라이스에 의해 중단되면 이 다음으로 어떤 프로세스를 선택하여 CPU를 할당해 주어야 하는지 결정하는 일을 한다.</p>

    <p>일반적으로 CPU 스케줄러는 레디 큐에 있는 것 중 제일 앞에 있는 것을 선택한다.(선착순)</p>

    <p>하지만 맨 앞에 있는 프로세스에게 CPU를 할당해주는 것이 항상 좋은 방법일까? 아니다!</p>

    <p>CPU 스케줄러가 다음에 수행될 프로세스를 선택하는 기준은 <strong>프로세스의 종류가 어떤 것이냐</strong> 이다.</p>

    <p>프로세스는 2가지로 분류될 수 있다.</p>

    <p><strong>I/O bound 프로세스</strong> = CPU 연산보다는 I/O 작업을 하는데 시간을 더 많이 사용하는 프로세스</p>

    <p><strong>CPU bound 프로세스</strong> = I/O 연산보다는 CPU 연산을 하는데 시간을 더 많이 사용하는 프로세스</p>

    <p>이 두 종류의 프로세스들이 레디 큐에서 CPU 할당을 기다리고 있다면 이들 중 CPU 스케줄러는 어떤 프로세스를 먼저 선택해야 할까?</p>

    <p>I/O bound 프로세스를 먼저 선택하여 CPU를 먼저 할당해 주는 것이 좋다.</p>

    <p>왜냐하면 I/O 작업은 CPU의 처리가 오래 걸리지 않고 오히려 I/O 자체 작업 시간이 더 오래 걸린다.</p>

    <p>따라서 I/O bound 프로세스가 CPU를 요구하는 것을 얼른 들어주고 I/O 자체 작업을 하도록 넘겨주는 것이 좋다.</p>

    <p>만약 CPU 사용시간이 긴 CPU bound 프로세스를 먼저 선택하면 I/O bound 프로세스는 잠깐의 CPU 연산을 하기 위해 CPU bound 프로세스가 끝날 때까지 오래 기다려야 하는 불상사가 발생한다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-context-switch">🚁 Context Switch</h2>
<hr />

<ul>
  <li>여러 프로세스들이 CPU 할당을 받아서 실행되다가 타임 슬라이스에 의해 중단된 시점에는 막 마쳐진 이 프로세스의 마지막 상태를 저장해야 한다.</li>
</ul>

<p>또, 이 프로세스가 CPU 스케줄러에게 다시 선택되어졌을 때는 전에 저장해 놓은 프로세스 상태를 불러와야 한다.</p>

<p>위 과정을 <strong>Context Switch</strong> 라고 한다.</p>

<p>Context Switch 가 행해지는 동안은 어떤 작업도 효율적으로 잘 동작되지 않다. 즉, Context Switch를 하는데 있어서 비용(손해)이 많이 든다는 뜻이다.</p>

<p>이 비용은 운영체제가 올려진 하드웨어의 성능에 따라 달라진다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/56150649-453b2200-5fea-11e9-873f-d494320ea637.PNG" alt="운영체제30" /></p>

<p>위 그림은 프로세스 P0과 P1 사이에서 Context Switch가 일어나는 과정을 보여준다.</p>

<p>일단, 처음에는 P0가 CPU의 할당을 받아 실행 중인 모습이다. 하지만 타임 슬라이스에 의해 P0은 중단된다.</p>

<p>P0이 중단되면 P0의 PCB에 P0가 중단되기 전 마지막 상태를 저장하고, 다음에 실행될 P1의 상태를 불러온다.</p>

<p>이 과정을 거쳐야 P1이 실행되기 때문에 P0이 중단되고 바로 P1이 실행되는 것이 아니라 약간의 시간지연(PCB저장과 P1상태 load를 위한 시간)이 생길 수 밖에 없다.</p>

<p>바로 이 시간 지연이 운영체제가 올려진 하드웨어 성능에 따라 달라진다는 것이다.</p>

<p><br /></p>

<h2 id="--프로세스의-생성과-종료에-대해서">👍 👎 프로세스의 생성과 종료에 대해서</h2>
<hr />

<ul>
  <li>
    <p><em>프로세스의 생성</em></p>

    <p>그럼 프로세스는 처음에 어떤 방식으로 생성될까?</p>

    <p>바로 부모 프로세스가 자식 프로세스를 생성하는 구조로 생성된다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56260278-97c32e00-6111-11e9-8d28-7e9b98b43e3f.PNG" alt="운영체제31" /></p>

    <p>부모 프로세스에서 자식 프로세스가 생성되어 뻗어나오는 구조로, 프로세스의 탄생 구조는 <strong>트리 구조</strong> 임을 확인할 수 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>자식 프로세스는 자원을 필요로 한다</em></p>

    <p>자식 프로세스는 자신의 수행을 위해 CPU 같은 리소스를 필요로 하는데 이와 같은 리소스를 운영체제가 직접 할당해 줄 수도 있고, 부모 프로세스가 공유해 줄 수도 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>부모와 자식 프로세스 간의 리소스 공유</em></p>

    <p>부모 프로세스가 자식 프로세스에게 자신의 리소스를 공유해 주는 경우에는 부모가 자식 프로세스에게 <strong>모든</strong> 리소스를 공유해 줄수도 있고, <strong>부분</strong> 만을 공유해 줄수도 있으며 공유하지 <strong>않을</strong> 수도 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>프로세스 실행</em></p>

    <p>부모와 자식 프로세스가 동시에 실행될 수도 있고, 자식 프로세스가 먼저 종료될 때까지 부모 프로세스가 기다리고 있을수도 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>주소 공간</em></p>

    <p>앞에서 프로세스가 실행되면 주소 공간이 생성된다고 설명했다.</p>

    <p>자식 프로세스의 주소 공간은 부모의 주소 공간을 복사함으로써 생성된다. 이 때, 복사한다는 것이 주소 공간의 내용까지 모두 복사하는 것이 아니라 주소 공간의 구조만 복사한다는 것이다. 그러면 크기가 똑같은 주소 공간이 생성되는데 자식 프로세스가 이 곳을 자신의 주소 공간으로 사용한다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>프로세스 실행 과정</em></p>

    <p>프로세스가 하나 생성되면 처음에는 운영체제 커널이 PCB를 하나 만들어 준다. 또, 주소 공간도 할당해 준다. 그 후 바이너리 프로그램(실행프로그램)을 그 위에 로드하고(PCB상에 프로그램 코드를 올림) 프로그램이 실행될 수 있도록 준비시킨다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>유닉스 운영체제가 프로세스를 생성하는 방법</em></p>

    <p>유닉스 운영체제는 fork 라는 것으로 새로운 프로세스를 생성한다.</p>

    <p>유닉스에서는 fork가 새로운 프로세스를 만드는 유일한 방법이다. 프로세스를 fork 하면 부모의 PCB가 복사되고 메모리가 할당된다.</p>

    <p>fork가 실행된 후, execve 라는 시스템 콜을 호출하여 디스크에 바이너리 프로그램(실행 프로그램)을 올리고 실행시킨다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>프로세스 종료</em></p>

    <p>부모 프로세스로 부터 생성된 자식 프로세스는 자신이 해야할 일을 끝마친 후, 운영체제에게 자신이 종료되어도 되는지 물어본다.</p>

    <p>종료 허가를 받은 자식 프로세스는 종료되면서 자신이 종료되기를 기다리고 있는 부모 프로세스에세 자신의 상태값을 return(반환)한다.</p>

    <p>이 상태값은 0 부터 255 까지 숫자 중 하나이다.</p>

    <p>wait()라는 시스템 콜에 의해 자식의 종료만을 기다리고 있는 부모 프로세스는 이 상태값(pid라는 변수로 표현)을 받는다.(wait() 함수가 받음)</p>

    <p>만약 어떤 부모 프로세스가 종료된 자신의 자식 프로세스의 상태값을 회수하지 못했을 경우, 이 자식 프로세스를 <strong>좀비 프로세스</strong> 라고 한다.</p>

    <p>또, 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 이 부모의 자식 프로세스를 <strong>orphan(고아) 프로세스</strong> 라고 부른다.</p>

    <p>부모 프로세스는 wait( )를 통해 자식 프로세스의 종료를 기다려야만 하고 그 결과로 받은 자식의 상태값에 따라 부모 프로세스가 뒤처리를 해야한다.</p>

    <p>좀비 프로세스는 정상적이지 않은 프로세스이다. 하지만 결국 이 좀비 프로세스도 메모리 위에 올라가 있기 때문에 좀비 상태가 많아지면 비정상 프로세스에게 자원을 낭비하는 것이다. 따라서 좀비 상태가 된 프로세스는 어느 정도 시간이 지나면 사라진다.</p>

    <p>부모 프로세스가 자식 프로세스를 직접 종료시키는 경우도 있다. 만약 자식 프로세스가 할당받은 자원을 초과하여 실행되는 경우, 부모 프로세스는 자식 프로세스를 종료시킨다.</p>

    <p>또, 자식 프로세스에게 할당된 일이 더이상 요구되지 않을 경우 자식 프로세스를 종료시킨다.</p>

    <p>어떤 운영체제에서는 부모 프로세스가 종료되면 해당 자식 프로세스들의 존재를 허용하지 않기도 한다. 즉, 부모 프로세스가 종료되면 모든 자식 프로세스도 함께 종료시켜버린다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>fork과정을 c로 작성하기</em></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56282346-e7255080-6149-11e9-8d76-8d75988da3db.PNG" alt="운영체제32" /></p>

    <p>위 코드는 fork() 를 통해 자식 프로세스가 생성되는 과정을 c언어로 구현한 코드이다.</p>

    <p>코드의 흐름을 살펴보면,</p>

    <p>일단 pid_t 타입의 변수인 pid를 선언한다.(pid_t 는 Process Id 를 저장하는 Type의 약자이다.)</p>

    <p>그 다음 fork()를 호출하고 반환값을 pid에 저장한다.</p>

    <p>이 때, fork()를 통해 부모 프로세스의 PCB가 복사되어 자식 프로세스가 생성되고 실행된다.</p>

    <p>fork()의 반환값은 -1 또는 0인데 -1일 경우에는 에러로 인해 자식 프로세스가 생성되지 못한 것을 의미하고, 0일 경우 자식 프로세스가 정상적으로 생성됨을 의미한다.</p>

    <p>따라서, 위 코드에서는 pid가 음수(-1을 의미)이면 실패 메시지를 띄우고, pid가 0이면 if문 안에 자식 프로세스가 할 일을 작성하였다.</p>

    <p>execlp() 함수는 프로세스를 실행시키는 함수이다. 첫번째 인자는 실행시킬 프로그램의 경로이고, 두번째 인자는 실행시킬 프로그램의 이름이다. 세번째 인자는 옵션인데 특별한 경우가 아닌 이상 NULL로 채운다.</p>

    <p>마지막 else문은 pid가 양수인 경우를 의미한다. fork의 반환값 중 양수는 부모프로세스를 의미한다. 따라서 마지막 else문 안에는 부모 프로세스가 할 일을 작성하면 된다.</p>

    <p>부모 프로세스는 wait() 을 통해 자식 프로세스가 종료되기를 기다린다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56077311-96de8380-5e15-11e9-81ee-fbecf9d08f70.PNG" alt="운영체제16" /></p>

    <p>위 그림을 보고 앞에서 보여준 코드의 흐름을 다시 한번 파악할 수 있을 것이다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-프로세스들의-협력">👬 프로세스들의 협력</h2>
<hr />

<ul>
  <li>
    <p>프로세스 중에는 <strong>Cooperate Process</strong> 라고 하는 프로세스들 간에 서로 영향을 주고 받아 협력하는 프로세스들이 있는 반면, 서로에게 영향을 주지 않는 독립적인 프로세스도 있다.</p>
  </li>
  <li>
    <p><em>프로세스들끼리 협력하면 좋은 점</em></p>

    <p>서로 정보를 공유할 수 있다.</p>

    <p>계산 속도를 증가시킬 수 있다.</p>

    <p>시스템 함수들을 분리하여 모듈화해서 사용할 수 있다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="--생산자-소비자-문제">💸  생산자-소비자 문제</h2>
<hr />

<ul>
  <li>
    <p><em>생산자-소비자 문제란?(Producer-Consumer Problem)</em></p>

    <p>프로세스에는 생산자 프로세스와 소비자 프로세스가 존재한다는 점을 알아두자.</p>

    <p>생산자-소비자 문제란 생산자가 데이터를 생산하면 소비자가 그것을 소비하는 형태에서 발생하는 문제를 말한다.</p>

    <p>이 문제는 생산 속도와 소비 속도의 차이에 의해 발생하는데 생산되는 속도가 소비되는 속도보다 빠를 경우, 생산된 데이터가 바로 소비되지 못한다.</p>

    <p>그래서 <strong>버퍼</strong> 라는 데이터 임시 저장 공간이 존재하는 것이다. 생산자가 생산한 데이터를 버퍼에 보관하고 소비자는 데이터를 버퍼에서 빼간다.</p>

    <p>하지만 버퍼는 대부분 크기가 정해져 있다. 이렇게 크기가 정해져있는 버퍼를 <strong>Bounded Buffer</strong> 라고 부른다.(크기가 정해져 있지 않은 버퍼는 <strong>Unbounded Buffer</strong> 라고 한다.)</p>

    <p>즉, 만약 버퍼가 가득차면 생산자 프로세스는 더 이상 버퍼에 생산한 데이터를 저장할 수 없게 된다. 또 버퍼가 비어있다면 소비자가 데이터를 뺄 수 없게 된다.(이것이 생산자-소비자 문제의 핵심이다)</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>생산자-소비자간의 버퍼 사용 과정</em></p>

    <p>생산자와 소비자가 데이터를 공유하는 공간인 버퍼에 대해 자세히 알아보자.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56287536-9288d200-6157-11e9-8212-07fbe889ac80.jpg" alt="버퍼" /></p>

    <p>위 그림은 공간이 한정적인 버퍼를 원형으로 설명한 그림이다.</p>

    <p>위 그림은 아래 코드(생산자와 소비자의 버퍼 사용 과정)를 설명한 것이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56287619-d2e85000-6157-11e9-903c-0fe3b0672741.PNG" alt="운영체제33" /></p>

    <p><br /></p>
  </li>
  <li>
    <p><em>두 프로세스의 Communication</em></p>

    <p>프로세스들은 서로의 주소 공간을 공유하지 않기 때문에 메시지를 주고 받음으로써 서로 소통해야 한다.</p>

    <p>메시지를 주고 받기 위한 두 가지 메소드가 존재한다.</p>

    <p><strong>send(message)</strong></p>

    <p><strong>receive(message)</strong></p>

    <p>만약, 두 개의 프로세스가 서로 소통하기를 원한다면 그들 사이에 <strong>communication 링크</strong> 를 만들어야 한다. 또, send/receive 메소드를 이용하여 메시지를 교환해야 한다.</p>

    <p>communication 링크는 물리적 또는 논리적으로 만들어진다. (물리적 = 하드웨어 버스, 네트워크 / 논리적 = Direct/Indirect Communication, 동기화)</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>논리적인 Communication 링크의 종류</em></p>

    <p><strong>1. Direct Communication</strong></p>

    <p>프로세스는 서로에게 명시적인 이름을 붙인다.</p>

    <p>예를 들어, <strong>send</strong> (P, message) 는 P라는 프로세스에게 메시지를 보낸다는 것이고, <strong>receive</strong> (Q, message)라는 것은 Q라는 프로세스로부터 메시지를 받는다는 것이다.</p>

    <p><strong>2. Indirect Communication</strong></p>

    <p>메시지가 <strong>mailbox</strong> 라고 하는 곳으로 보내지고 받아지는 방식의 커뮤니케이션이다.</p>

    <p>mailbox는 메시지가 보내지고 받아지는 객체(Object)이다.</p>

    <p>각각의 mailbox는 자신만의 id를 갖는다.</p>

    <p>소통하고자 하는 두 프로세스가 한 mailbox를 공유하는 경우에만 커뮤니케이션이 가능해진다. 그리고 소통이 끝나면 mailbox는 파괴된다.</p>

    <p><strong>send</strong> (A, message) 는 A라는 mailbox로 메시지를 보내라는 것이고, <strong>receive</strong> (A, message) 는 A라는 mailbox로부터 메시지를 받으라는 것이다.</p>

    <p><strong>3. 동기화(Synchronization)</strong></p>

    <p>두 프로세스가 메시지를 주고 받음으로써 소통하는 방식으로 <strong>Blocking방식</strong> 또는 <strong>non-Blocking방식</strong> 을 사용한다.</p>

    <p><strong>Blocking방식</strong> 은 <strong>동기적</strong> 인 방식이다.</p>

    <p>무슨 말이냐면 blocking 방식으로 메시지를 주고 받는 경우에는 만약 메시지 receiver가 메시지를 받고 있다면 그 메시지를 다 받을 때까지 메시지 sender을 block(막음=중단)한다.</p>

    <p>하지만 <strong>Non-blocking</strong> 은 <strong>비동기적</strong> 이다.</p>

    <p>즉, Non-blockin 방식에서는 receiver가 메시지를 받고 있어도 메시지 sender는 계속 메시지를 보낼 수 있다.</p>
  </li>
</ul>


  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  2강 - Operating System Structures  🙋 2강에서 설명할 수 있어야 하는 것들 🙋      다양한 인터페이스    운영체제의 구조    운영체제가 부트되는 과정  👮...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[OS] 운영체제2 | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[OS] 운영체제2 | choheeis">
  <meta name="twitter:description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  2강 - Operating System Structures  🙋 2강에서 설명할 수 있어야 하는 것들 🙋      다양한 인터페이스    운영체제의 구조    운영체제가 부트되는 과정  👮...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2019-04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C2">
  <meta property="og:title" content="[OS] 운영체제2 | choheeis">
  <meta property="og:description" content="  서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆  2강 - Operating System Structures  🙋 2강에서 설명할 수 있어야 하는 것들 🙋      다양한 인터페이스    운영체제의 구조    운영체제가 부트되는 과정  👮...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[OS] 운영체제2 | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2019-04/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C2">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[OS] 운영체제2">[OS] 운영체제2</h1>
    <span class="post-meta">
      <span class="post-date">
        12 APR 2019
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    6 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p>서울과학기술대학교 3학년 교과과정으로 배운 “운영체제” 시험 공부 및 정리용 포스팅 😆</p>

  <p><em>2강 - Operating System Structures</em></p>

  <p>🙋 2강에서 설명할 수 있어야 하는 것들 🙋</p>

  <ul>
    <li>다양한 인터페이스</li>
    <li>운영체제의 구조</li>
    <li>운영체제가 부트되는 과정</li>
  </ul>
</blockquote>

<p><br /></p>

<h2 id="-운영체제의-서비스">👮 운영체제의 서비스</h2>
<hr />

<ul>
  <li>
    <p><em>운영체제는 아래의 여러 서비스들을 제공한다</em></p>

    <ul>
      <li>
        <p>유저 인터페이스를 제공한다.</p>

        <p>CLI = Command Line Interface</p>

        <p>GUI = Graphics User Interface</p>
      </li>
      <li>
        <p>프로그램을 실행시켜준다.</p>

        <p>프로그램을 메모리에 올려서 실행시키고, 종료한다.</p>
      </li>
      <li>
        <p>입출력을 동작시킨다.</p>

        <p>키보드와 마우스로부터 입력을 받고, 모니터와 프린터로 출력을 해준다.</p>
      </li>
      <li>
        <p>파일 시스템을 조작한다.</p>

        <p>파일이나 디렉토리를 읽고 쓰며, 파일들을 생성하고 삭제하고 검색한다.</p>
      </li>
      <li>
        <p>프로세스간에 정보를 교환하여 소통하게 해준다.</p>
      </li>
      <li>
        <p>에러를 감지해준다.</p>

        <p>하드웨어 에러나 입출력 에러, 유저가 사용중인 프로그램 에러를 감지한다.</p>

        <p>메모리 에러, 네트워크 연결 에러, 용지 부족 에러, 사용자의 불법적인 메모리 접근 감지 등등</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><em>운영체제는 자신의 효율적인 작동을 위해 아래와 같은 작동을 한다</em></p>

    <ul>
      <li>
        <p>효율적으로 리소스를 할당한다.</p>

        <p>주로 멀티 유저 경우나 멀티태스킹 경우에 효율적인 리소스 할당은 중요하다.</p>

        <p>어떤 프로세스에게 얼만큼의 리소스를 할당해야 효율적인지 계산하여 할당한다.</p>
      </li>
      <li>
        <p>어떤 유저가 어떤 리소스를 얼만큼 사용하고 있는지 체크한다.</p>
      </li>
      <li>
        <p>보호 및 보안 기능을 작동한다.</p>

        <p>보호 = 시스템 리소스에 아무나 접근할 수 없도록 통제한다.</p>

        <p>보안 = 유저 인증 기능(사용자 비밀번호 확인 등)을 제공하고, 유저의 잘못된 접근 시도를 방어한다.</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
</ul>

<h2 id="-운영체제의-유저-인터페이스">📺 운영체제의 유저 인터페이스</h2>
<hr />

<ul>
  <li>
    <p><em>CLI</em></p>

    <p><strong>Command Line Interface</strong> 의 약자이다.</p>

    <p>키보드를 사용해서 사용자와 컴퓨터가 상호 작용하는 방식이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56050388-bc707c00-5d86-11e9-9338-8cc417a5186e.PNG" alt="운영체제8" /></p>

    <p>위와 같이 키보드로 명령어를 입력하여 컴퓨터 시스템을 다루는 것이다.</p>

    <p>사용자들이 명령어들을 외워야 한다.</p>

    <p>이 때, <strong>쉘(shell)</strong> 이라는 것이 등장하는데 쉘은 CLI 방식에서 사용되는 명령을 해석하고 관리하는 프로그램이다. 커맨드 interpreter(해석자)라고도 불린다.</p>

    <p>쉘의 종류 중 bash 라는 쉘이 있다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>GUI</em></p>

    <p><strong>Graphics User Interface</strong> 의 약자이다.</p>

    <p>마우스를 사용해서 사용자와 컴퓨터가 상호 작용하는 방식이다.</p>

    <p>현대의 유저들에게 가장 친근한 컴퓨터 조작 방식이다.</p>

    <p>운영체제 중 하나인 리눅스와 유닉스는 CLI 기반이긴 하지만 유저에게 친숙한 GUI도 제공한다.</p>

    <p>요즘의 운영체제들은 위 두 가지 인터페이스 방식을 모두 제공한다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>시스템 콜(System Call)</em></p>

    <p>시스템 콜이라는 것도 인터페이스 중 하나인데 운영체제와 어플리케이션 사이에서 작동되는 인터페이스이다.</p>

    <p>프로그램들은 이 인터페이스를 통해 운영체제에게 서비스를 요청한다.</p>

    <p>프로그램은 운영체제에게 서비스를 제공해 달라는 요청( 예를 들어, 하드웨어를 엑세스 해달라는 요청)을 해야만 한다. 컴퓨터 시스템은 유저가 직접 하드웨어에 접근할 수 없는 구조이기 때문이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56051039-6f8da500-5d88-11e9-842e-3186bc0a3076.PNG" alt="운영체제9" /></p>

    <p>위 그림을 보면 새로운 프로세스를 생성하거나 종료할 때도 시스템 콜을 통해서 수행됨을 볼 수 있다. (프로세스 매니저가 시스템 콜에 요청 및 응답하는 구조)</p>

    <p>하드디스크에 접근해야 할 때도 시스템 콜을 통해 요청하고 응답받는 것도 볼 수 있다.</p>

    <p>즉, 정리해보면 운영체제 커널과 유저레벨 사이에 시스템 콜이 위치한다.</p>

    <p>위 그림을 통해 시스템 콜 밑에서 동작하는 것들에 대해 알아보자!</p>

    <ul>
      <li>
        <p>프로세스 관리자 = 프로세스를 생성하고 종료시키는 일을 한다.</p>
      </li>
      <li>
        <p>파일 관리자 = 파일들을 생성하고 삭제하고, 열고 닫으며 읽고 쓰는 일을 한다.</p>
      </li>
      <li>
        <p>메모리 관리자 = 메모리를 할당해주는 역할을 한다.</p>
      </li>
      <li>
        <p>데이터 유지자 = 타이머나 달력 정보를 세팅하거나 가져온다.</p>
      </li>
      <li>
        <p>Communications = 네트워크 연결을 생성하고 삭제하며, 메시지를 보내거나 받는일을 한다.</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><em>파일의 내용을 다른 파일에 복사하는 작업에서 시스템 콜의 동작 과정</em></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56145709-c17c3800-5fdf-11e9-9ccd-fc58e67e253a.PNG" alt="운영체제25" /></p>

    <p>위 코드는 파일 이름이 infile인 파일을 outfile 이라는 파일로 복사하는 작업에서 실행되는 시스템의 흐름이다.</p>

    <p>위 그림을 통해 우리가 cmd 창에 CLI 명령어인 <strong>cp infile outfile</strong> 이라고 작성하면 시스템 콜에서는 위와 같은 과정이 일어난다는 것을 알게되었다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>시스템 콜과 API의 차이점</em></p>

    <p>일단! <strong>API</strong> 란 뭘까?</p>

    <p><strong>Application Program Interface</strong> 의 약자이다.</p>

    <p>풀어서 설명하면 어플리케이션을 개발하는 프로그래머들이 사용할 수 있도록 제공하는 <strong>함수</strong> 들을 모아놓은 것을 말한다!</p>

    <p>프로그래머들이 API를 사용하는 이유는 OS 내부적으로 돌아가는 시스템 콜이 API에 의해 숨겨져 있기 때문에 시스템 콜의 동작을 알 필요가 없기 때문이다.</p>

    <blockquote>
      <p>그런데 그럼 <strong>라이브러리</strong> 랑 <strong>API</strong> 의 차이점은 뭘까?</p>
    </blockquote>

    <p><strong>라이브러리</strong> = 특정 목적을 위해 별도로 제공되는 함수들의 모임으로 외부로 노출될 수도 있고, 내부에서도 돌아가는 형태이다.</p>

    <p><strong>API</strong> = 외부로 노출되는( = 인터페이스 역할을 하는) 함수들의 모음이다. 결국, API를 통해 라이브러리가 사용되는 것이다.</p>

    <blockquote>
      <p>흠,,, 아직 잘 모르겠다 하하</p>
    </blockquote>

    <p><br /></p>
  </li>
  <li>
    <p><em>가장 유명한 API들</em></p>

    <ul>
      <li>윈도우 프로그래밍을 위한 Win32 API</li>
      <li>자바 가상 머신을 위한 Java API</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p><em>시스템 콜 vs API</em></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56053046-f1340180-5d8d-11e9-8d6b-227206026929.PNG" alt="운영체제10" /></p>

    <p>일단 위 그림을 보자~</p>

    <p>유저가 프로그램에서 printf() 라는 함수를 호출했다. printf() 함수는 사실 라이브러리이다.</p>

    <p>라이브러리의 printf() 함수를 보면 write() 라는 함수를 호출하는 것을 확인할 수 있는데 이 write()가 시스템 콜(유저가 커널에 간접적으로 접근할 수 있게 하는 인터페이스)이다!</p>

    <p>여기서는 printf() 가 라이브러리 or API 역할을 한다고 보면 된다.</p>

    <p>write()는 시스템 콜이기 때문에 유저가 프로그램 단계에서 직접 호출할 수도 있다.</p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-시스템-콜이-매개변수를-넘기는-과정passing">📢 시스템 콜이 매개변수를 넘기는 과정(Passing)</h2>
<hr />

<ul>
  <li>
    <p><em>시스템 콜은 어떤식으로 운영체제에게 자신의 매개변수를 넘겨줄까?</em></p>

    <p>예를 들어, open() 이라는 시스템 콜을 호출하려면 open(“/etc/passwd”, O_RDONLY); 와 같은 코드를 작성해야 하는데 이 때 open() 의 매개변수들인 “/etc/passwd” 와 O_RDONLY를 어떻게 운영체제에게 넘겨주는 것일까?</p>

    <p>(시스템 콜의 종류와 운영체제에 따라서 시스템 콜의 매개변수로 요구되는 변수의 타입과 개수가 다양하다.)</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>운영체제에게 매개변수(Parameter)를 넘겨주기 위한 3가지 방법!</em></p>

    <ul>
      <li>
        <p>파라미터를 레지스터에게 넘겨주기!</p>
      </li>
      <li>
        <p>매개변수들을 메모리 위의 테이블안에 저장해 놓았다가 레지스터에게 이 테이블의 주소를 넘겨주기!</p>
      </li>
      <li>
        <p>매개변수들을 프로그램의 스택에 push 해 놓고, 운영체제 스택으로 pop off 하기!</p>
      </li>
    </ul>

    <p><br /></p>
  </li>
</ul>

<h2 id="-운영체제의-구조">🏬 운영체제의 구조</h2>
<hr />

<ul>
  <li>
    <p><em>단순 구조</em></p>

    <p>옛날 운영체제(MS-DOS 또는 초창기 UNIX)가 사용했던 구조이다.</p>

    <p>인터페이스와 기능을 담당하는 부분이 분리되어 있지 않은 구조였다.</p>

    <p>또, 어플리케이션은 I/O routine에 직접 접근이 가능했고, 따라서 어플리케이션이 죽어버리면 시스템 전체가 깨져버렸다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>계층 구조</em></p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56147082-8596a200-5fe2-11e9-9ca4-fc243620fe61.PNG" alt="운영체제26" /></p>

    <p>위 그림과 같이 운영체제 전체가 여러 계층으로 나누어져 있는 구조이다.</p>

    <p>맨 처음 계층(level 0)은 hardware 층이고, 가장 바깥 계층은 user interface 층이다.</p>

    <p>이러한 구조는 디버그가 쉽지만 계층을 정의하기가 어려웠다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>마이크로커널(Microkernel) 구조</em></p>

    <p>이 구조는 많은 것들이 커널 공간으로부터 유저 공간으로 옮겨진 구조이다.</p>

    <p>이 구조에서는 메시지를 통해 유저와 커널의 커뮤니케이션이 가능했지만 많은 메시지 전달로 인해 성능이 떨어지는 단점이 있었다.</p>

    <p>보안성은 좋았다.</p>

    <p>Window NT가 이 구조를 사용한 운영체제였다.</p>

    <p><br /></p>
  </li>
  <li>
    <p><em>모듈(Module) 구조</em></p>

    <p>모듈 구조는 대부분의 현대 운영체제가 가지는 구조이다.</p>

    <p>객체지향적 접근을 사용하는 구조이며 각각의 요소들이 분리되어 있다.</p>

    <p>인터페이스를 통해 각 요소들간에 소통을 하고, 필요한 요소들만 운영체제를 통해 호출되는 방식이다.</p>

    <p>정확하게는 아래와 같은 구조이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56147588-8b40b780-5fe3-11e9-9326-52efc971dd9e.PNG" alt="운영체제27" /></p>

    <p><br /></p>
  </li>
</ul>

<h2 id="-시스템-부트system-boot">🚀 시스템 부트(System boot)</h2>
<hr />

<p><strong>boot</strong> = 기억 장치로 스타트하다.</p>

<ul>
  <li>
    <p><em>운영체제는 어떻게 로드(load)되는 걸까?</em></p>

    <p><strong>부트 로더(bootloader)</strong> 라는 것에 의해 시스템이 초기화 되고, 실행(run)된다.</p>

    <p>부트 로더는 운영체제를 메모리에 올리고 실행시킨다.</p>

    <p><strong>Small system</strong> 이라는 것을 통해 ROM에 부트 로더와 운영체제를 저장한다.</p>

    <p><strong>Large system</strong> 이라는 것을 통하면 ROM에는 부트 로더를 저장시키고, 디스크에는 운영체제를 저장시킨다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56148043-6e58b400-5fe4-11e9-8b99-e008ab7ce7fd.PNG" alt="운영체제28" /></p>

    <p>위 그림은 리눅스 운영체제가 부팅되는 과정을 나타낸 그림이다.</p>

    <p>이 때, <strong>BIOS</strong> 는 운영체제 중 가장 기본적인 컴퓨터의 입출력을 처리하는 소프트웨어이다.</p>

    <p><img src="https://user-images.githubusercontent.com/31889335/56148177-b4ae1300-5fe4-11e9-8b3c-a3dfbef2a4ae.PNG" alt="운영체제29" /></p>

    <p>위와 같은 입출력창이 바로 bios이다.</p>

    <p>다시 돌아가서, 먼저 ROM에 저장된 바이오스가 실행된다.</p>

    <p>그 다음 Bootloader가 실행되어 Disk에 있는 운영체제 요소들(쉘, 운영체제, 초기화)을 메모리에 올린다.</p>

    <p><br /></p>
  </li>
</ul>


  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

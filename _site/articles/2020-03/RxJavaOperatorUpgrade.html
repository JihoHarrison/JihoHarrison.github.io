<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  “RxJava 프로그래밍”이라는 책과 ReactiveX Operator Documentation을 참고하여 공부한 내용입니다.😃🏈 ReactiveX의 Operator을 더 알아보자!ReactiveX의 연산자에 관한 이전 포스팅인 Operator 을 보면 ReactiveX의 연산...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[RxJava] 🏈 RxJava Operator 심화 | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[RxJava] 🏈 RxJava Operator 심화 | choheeis">
  <meta name="twitter:description" content="  “RxJava 프로그래밍”이라는 책과 ReactiveX Operator Documentation을 참고하여 공부한 내용입니다.😃🏈 ReactiveX의 Operator을 더 알아보자!ReactiveX의 연산자에 관한 이전 포스팅인 Operator 을 보면 ReactiveX의 연산...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-03/RxJavaOperatorUpgrade">
  <meta property="og:title" content="[RxJava] 🏈 RxJava Operator 심화 | choheeis">
  <meta property="og:description" content="  “RxJava 프로그래밍”이라는 책과 ReactiveX Operator Documentation을 참고하여 공부한 내용입니다.😃🏈 ReactiveX의 Operator을 더 알아보자!ReactiveX의 연산자에 관한 이전 포스팅인 Operator 을 보면 ReactiveX의 연산...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[RxJava] 🏈 RxJava Operator 심화 | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-03/RxJavaOperatorUpgrade">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[RxJava] 🏈 RxJava Operator 심화">[RxJava] 🏈 RxJava Operator 심화</h1>
    <span class="post-meta">
      <span class="post-date">
        9 MAR 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    25 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=116852658">“RxJava 프로그래밍”</a>이라는 책과 <a href="http://reactivex.io/documentation/operators.html">ReactiveX Operator Documentation</a>을 참고하여 공부한 내용입니다.😃</p>
</blockquote>

<p><br /></p>

<h1 id="-reactivex의-operator을-더-알아보자">🏈 ReactiveX의 Operator을 더 알아보자!</h1>

<p>ReactiveX의 연산자에 관한 이전 포스팅인 <a href="https://choheeis.github.io/rxjava/2020/03/03/RxJavaOperator.html">Operator</a> 을 보면 ReactiveX의 연산자의 종류에 대해 간단히 알 수 있다.</p>

<p>ReactiveX 연산자의 수는 정말 많아서 카테고리를 나누어 분류해 놓기도 한다.</p>

<p>이 포스팅에서는 카테고리 별로 나눠진 연산자 중 각 카테고리에는 어떤 연산자들이 있는지 조금 더 많이 알아볼 것이다!</p>

<p>연산자(=함수)를 사용하려면 연산자의 원형을 알아야한다. <a href="http://reactivex.io/">ReactiveX 공식 홈페이지</a>에 들어가보니</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76189696-af6e3e00-621e-11ea-802b-59f80741960c.PNG" alt="07" /></p>

<p>이렇게 ReactiveX를 지원하는 각 언어별 공식 깃헙에 접속할 수 있는 배너가 있다.</p>

<p>Rxjava를 클릭해보면 <a href="https://github.com/ReactiveX/RxJava">RxJava 공식 깃헙</a> 에 연결되는데 리드미를 읽어보면 현재 ReactiveX 버전인 3버전에서 지원하는 기본 클래스에 대한 문서가 나온다!</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76189827-f52b0680-621e-11ea-9329-4e8f6bcc4460.PNG" alt="06" /></p>

<p>위 기본 클래스 중에서 <a href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html">Observable에 관련된 클래스</a>를 들어가보면 Observable 클래스 안에 정의되어 있는 연산자들의 원형과 설명을 볼 수 있다!</p>

<p>그럼 이제부터 각 카테고리에 속하는 연산자들을 몇 가지 알아보자.</p>

<p><br /></p>

<h1 id="1️⃣-생성creating-연산자">1️⃣ 생성(Creating) 연산자</h1>

<p>Rx 연산자의 첫 번째 카테고리는 생성연산자이다.</p>

<p>생성연산자는 데이터 흐름인 Obseravable을 생성할 때 사용하는 연산자이다.</p>

<p>생성 연산자의 가장 단순한 연산자는 just(), from() 계열의 함수, create() 가 있다.</p>

<p>이 외의 함수들에 대해서도 알아보자!</p>

<ol>
  <li>
    <p>interval() 함수</p>
  </li>
  <li>
    <p>timer() 함수</p>
  </li>
  <li>
    <p>range() 함수</p>
  </li>
  <li>
    <p>defer() 함수</p>
  </li>
  <li>
    <p>repeat() 함수</p>
  </li>
</ol>

<p><br /></p>

<h2 id="-interval-함수">👉🏾 interval() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/interval.html">interval()</a> 함수는 주어진 시간 간격에 따라 일련의 정수를 무한히 방출하는 Observable을 생성해주는 함수이다.</p>

<p>interval() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76187987-44bb0380-621a-11ea-8af4-197bd3c86319.PNG" alt="01" /></p>

<p>위 마블 다이어그램을 보면 인자로 정해준 시간의 간격에 따라 0부터 1씩 증가하는 정수가 발행되는 것을 볼 수 있다.</p>

<p>이 때, 발행되는 정수는 Long객체이다.</p>

<p><a href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html">Observable 라이브러리</a>에서 interval() 함수를 찾아보면 interval() 함수의 원형은 총 4가지인 것을 알 수 있고, 각 원형마다 함수의 기능이 조금씩 다르다는 것을 알 수 있다.</p>

<p>이 4가지 중 자주 사용되는 interval() 함수의 원형은 다음 두 가지이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76188442-623c9d00-621b-11ea-9607-29670b516f7e.PNG" alt="02" /></p>

<p><img src="https://user-images.githubusercontent.com/31889335/76188441-61a40680-621b-11ea-9ce4-3545bf4253d6.PNG" alt="03" /></p>

<p>첫 번째 원형은 일정 시간 쉬었다가 데이터를 발행하도록 한다.</p>

<p>두 번째 원형은 첫 번째 원형과 동작은 같지만 최초 지연 시간을 정해줄 수 있다.</p>

<p>위에서 본 interval() 함수의 마블 다이어그램을 자세히 보면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76189232-800b0180-621d-11ea-86e8-6d78ccd055a8.PNG" alt="04" /></p>

<p>이렇게 첫 번째 item이 발행되는 것도 일정 간격이 지난 후이다. 이렇게 첫 번째 item이 발행되기 전에 흐르는 일정 시간을 최초 지연 시간이라고 하는데 두 번째 원형을 통해 최초 지연 시간을 0으로 지정하면 이 시간이 없어지게 된다.</p>

<p>따라서 두 번째 원형은 보통 초기 지연 없이 바로 데이터를 발행하기 위해 최초 지연 시간을 0으로 해서 많이 사용된다.</p>

<p>또, interval 함수는 main 쓰레드에서 실행되는 함수가 아니라 Computation(계산) 쓰레드에서 실행되는 함수이다! (이것도 Observable 라이브러리에 명시되어 있다.)</p>

<p>그렇다면 RxJava를 사용해서 interval() 함수를 사용한 간단한 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// interval() 함수를 사용하여 100ms 간격으로 0부터 데이터를 발행한 후 map() 함수를 호출하여 1을 더해주고 100을 곱해주어서 100, 200, 300 ... 등의 데이터를 발행한다.</span>
    <span class="c1">// filtering 함수인 take 함수를 통해 최초 5개의 데이터만 취한다.</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">100L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="mi">100</span><span class="o">).</span><span class="na">take</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">));</span>

    <span class="c1">// interval 함수는 Computation 쓰레드에서 실행되므로 메인 쓰레드가 잠깐 기다려줘야 한다.</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 1초 동안 쉬기</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드를 보면 Observable을 생성하고, 구독하는 부분은 잘 이해가 된다.</p>

<p>하지만 왜 쓰레드를 sleep() 해주어야 하는지는 의문이였다.(sleep()은 쓰레드를 지정 시간동안 일시정지 시키는 함수이다.)</p>

<p>찾아보니 interval() 함수는 main 쓰레드에서 실행되는 것이 아니라 Computation이라는 계산 쓰레드에서 실행되는 함수이다.</p>

<p>즉, interval()로 생성한 Observable가 계산 쓰레드에서 작동하는 동안 main 쓰레드를 멈춰
주지 않으면 main 쓰레드에서 할 일이 아무것도 없으므로 main 쓰레드가 실행되자마자 종료되어 프로그램이 종료되게 된다.</p>

<p>따라서 원하는 출력 코드를 실행시키기 위해서는 main 쓰레드도 동시에 무슨 일을 하거나 main 쓰레드에서 할 일이 없는 경우에는 잠깐 멈춰주어야 한다.</p>

<p>위 코드를 실행시켜보면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76191222-3244c800-6222-11ea-9ee7-6aa98c7d6b42.PNG" alt="08" /></p>

<p>이와 같이 출력되는 것을 볼 수 있다.</p>

<p><br /></p>

<h2 id="-timer-함수">👉🏾 timer() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/timer.html">timer()</a> 함수는 주어진 일정 시간이 지나면 특정한 item 한 개를 방출하는 Observable을 생성할 때 사용된다.</p>

<p>timer() 함수의 마블 다이어그램은 아래와 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76189493-32db5f80-621e-11ea-9e5f-51e1b8c0283f.PNG" alt="05" /></p>

<p>위 마블 다이어그램을 보면 subscribe()를 하면 주어진 일정 시간이 지나고 하나의 item을 방출하는 모습을 볼 수 있다.</p>

<p>한 개의 item 방출이 끝나면 onComplete() 이벤트가 호출되면서 Observable은 종료되게 된다.</p>

<p>또한 timer() 함수도 interval() 함수와 마찬가지로 Computation 쓰레드에서 실행되는 함수이다.</p>

<p>timer() 함수는 보통 일정 시간이 지난 후에 어떤 동작을 해야 할 때 많이 사용된다.</p>

<p>timer()함수도 여러 원형을 가지고 있는데 그 중</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76191386-9bc4d680-6222-11ea-9107-72d63710a836.PNG" alt="09" /></p>

<p>이러한 원형의 timer() 함수를 RxJava로 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 500ms 후에 현재 시간을 출력하는 동작을 한다.</span>
    <span class="c1">// 500ms 후에 item인 0이 방출되지만 이 0을 실제로 map() 함수에서 사용할 필요가 없으므로 람다 표현식의 인자 이름을 notUsed라고 지었다.</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">timer</span><span class="o">(</span><span class="mi">500L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">notUsed</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="nf">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy/MM/dd HH:mm:ss"</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">());</span>
                <span class="o">});</span>
    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">));</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같은 코드를 실행시킨 결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76191914-c7948c00-6223-11ea-96ea-4a212ad92cdd.PNG" alt="10" /></p>

<p><br /></p>

<h2 id="-range-함수">👉🏾 range() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/range.html">range() 함수</a>는 지정해준 범위내에 속하는 정수를 item으로 방출하는 Observable을 생성할 때 사용되는 함수이다.</p>

<p>range() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76192029-22c67e80-6224-11ea-8a89-641129f5a3de.PNG" alt="11" /></p>

<p>위 그림을 보면 range() 함수 안의 인자로는 n과 m을 지정해주었는데 방출되는 item을 보니 n부터 시작하여 m개의 item을 방출해주는 모습임을 알 수 있다.</p>

<p>즉, range() 함수는 첫 번째 인자로 지정한 숫자부터 두 번째 인자로 지정해준 숫자 만큼의 item을 방출해주는 Observable을 생성한다.</p>

<p>예를 들어 range(1, 5) 라고 하면 Observable은 1부터 차례대로 5개의 숫자를 방출하기 시작한다. 따라서 1, 2, 3, 4, 5까지의 숫자가 방출된다.</p>

<p>또한 range() 함수는 다른 쓰레드에서 실행되지 않고 현재 쓰레드에서 실행되는 함수이다.</p>

<p>range() 함수를 통해 for문이나 while문 같은 반복문을 대체할 수 있다.</p>

<p>그렇다면 RxJava로 range() 함수를 사용하여 반복문을 대체한 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드는 1 ~ 10까지의 수 중 짝수인 수만 출력하게 하는 반복문 대체 코드이다.</p>

<p>실행결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76591380-8659f000-6533-11ea-96c6-f9f23f896b9c.PNG" alt="12" /></p>

<p>그리고 range() 함수는 현재 쓰레드에서 실행되기 때문에 Thread.sleep() 함수를 호출해줄 필요가 없다.</p>

<p><br /></p>

<h2 id="-defer-함수">👉🏾 defer() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/defer.html">defer()</a> 함수는 구독자가 subscribe() 함수를 호출하기 전까지는 Observable을 생성하지 않고 각각의 observer에게 새로운 Observable을 생성해주는 함수이다.</p>

<p>defer() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76592181-efdafe00-6535-11ea-83fc-f7ca994aaf8b.PNG" alt="13" /></p>

<blockquote>
  <p>defer() 함수 다시 읽어보고 쓰기</p>
</blockquote>

<p><br /></p>

<h2 id="-repeat-함수">👉🏾 repeat() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/repeat.html">repeat()</a> 함수는 어떤 특정한 item을 반복적으로 계속 방출하는 Observable을 만들어야 할 때 사용하는 함수이다.</p>

<p>repeat() 함수가 가장 많이 사용되는 경우는 서버와 통신을 할 경우 해당 서버가 살아있는지 확인하는 코드를 작성할 때 사용한다.</p>

<blockquote>
  <p>해당 서버가 살아있는지 확인하는 과정은 ping 이라고 부르거나 heart beat 이라고 부른다!</p>
</blockquote>

<p>repeat() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76592821-dd61c400-6537-11ea-93c1-e0ba7133a7b1.PNG" alt="15" /></p>

<p>repeat() 함수의 인자에는 반복할 횟수를 넣어준다. 만약 인자에 아무것도 없다면 영원히 반복하게 된다.</p>

<p><br /></p>

<h1 id="2️⃣-변환transforming-연산자">2️⃣ 변환(Transforming) 연산자</h1>

<p>변환 연산자라는 것은 <a href="https://choheeis.github.io/rxjava/2020/03/03/RxJavaOperator.html">Rx의 연산자 포스팅</a>에서 살짝 소개했던 Rx 연산자 카테고리 중 하나이다.</p>

<p>변환 연산자는 생성 연산자로 생성된 Observable(데이터 흐름)을 원하는 대로 변형할 수 있도록 해주는 연산자이다.</p>

<ol>
  <li>
    <p>concatMap() 함수</p>
  </li>
  <li>
    <p>switchMap() 함수</p>
  </li>
  <li>
    <p>scan() 함수</p>
  </li>
  <li>
    <p>groupBy() 함수</p>
  </li>
</ol>

<p><br /></p>

<h2 id="-concatmap-함수">👉🏽 concatMap() 함수</h2>

<p>concatMap() 함수는 <a href="https://choheeis.github.io/rxjava/2020/03/03/RxJavaOperator.html">Rx 연산자 포스팅</a>에서 알아본 flatMap() 과 매우 비슷하다.</p>

<p>flatMap() 은 먼저 들어온 데이터를 처리하는 도중에 새로운 데이터가 들어오면 나중에 들어온 데이터의 처리 결과가 먼저 출력될 수도 있다.</p>

<p>이것을 interleaving(인터리빙, 끼어들기)라고도 한다.</p>

<p>하지만 concatMap() 함수는 먼저 들어온 데이터 순서대로 처리해서 결과를 낼 수 있도록 보장해주는 함수이다.</p>

<p>flatMap() 과 concatMap() 함수의 차이를 마블 다이어그램을 통해 알아보자.</p>

<p>일단 먼저 flatMap() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76926740-715cd280-6920-11ea-8d94-e119c1acb32b.PNG" alt="16" /></p>

<p>이 마블 다이어그램을 보면 초록 동그라미가 입력되어 두 개의 초록 다이아몬드가 출력되어야 하는데 두 번째 초록 다이아몬드가 출력되기 전에 파란 동그라미가 입력된 모습이다.</p>

<p>이 때, flatMap() 은 interleaving을 허용하므로 출력되는 Observable은 초록, 파랑, 초록 파랑 순으로 순서가 교차되게 된다.</p>

<p>하지만 concatMap() 함수의 마블 다이어그램을 보면 concatMap() 함수만의 특징을 바로 알 수 있을 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76926858-c0a30300-6920-11ea-81f0-1abc3ed69d1c.PNG" alt="17" /></p>

<p>위 마블 다이어그램이 concatMap() 함수의 마블 다이어그램인데 초록 동그라미 다음에 바로 파란 동그라미가 입력되어도 출력 Observable 에는 초록 동그라미 2개, 파란 동그라미 2개 순으로 출력되는 모습을 볼 수 있다!</p>

<p>즉, concatMap() 함수는 먼저 들어온 데이터 순서대로 처리해주는 함수인 것이다.</p>

<p>그렇다면 concatMap() 함수를 Rxjava로 사용한 예시를 봐보자!</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">balls</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>

    <span class="c1">// 1, 2, 3이 차례대로 방출되는 Observable이 생성된다</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">100L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Long:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">balls</span><span class="o">[</span><span class="n">idx</span><span class="o">])</span>
            <span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="n">balls</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>

            <span class="c1">// 여기부터 1, 2, 3을 방출하는 Observable를 변형시킨다.</span>
            <span class="o">.</span><span class="na">concatMap</span><span class="o">(</span><span class="n">ball</span> <span class="o">-&gt;</span> <span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">200L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">notUsed</span> <span class="o">-&gt;</span> <span class="n">ball</span> <span class="o">+</span> <span class="s">"@"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
            <span class="o">);</span>

    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
         <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드의 1, 2, 3이 100ms 간격으로 발생하지만 변형시킨 Observable은 200ms 간격으로 발생하기 때문에 입력과 출력의 순서가 역전될 수 있다.</p>

<p>하지만 그것을 concatMap() 함수로 잡아준 것이고, 위 코드의 실행결과는</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76927541-99e5cc00-6922-11ea-9893-ed45af59612b.PNG" alt="18" /></p>

<p>이와 같다!</p>

<p>하지만 concatMap() 함수는 flatMap() 함수보다 수행 시간이 느리다.</p>

<p>왜냐하면 flatMap()은 interleaving을 허용하지만 concatMap()은 허용하지 않아 순서를 맞춰주는데 필요한 추가 시간이 들기 때문이다.</p>

<p><br /></p>

<h2 id="switchmap-함수">👉🏽switchMap() 함수</h2>

<p>switchMap() 함수는 concatMap() 함수처럼 순서를 보장하지만 순서를 보장하기 위해 기존에 진행 중이던 작업을 중단한다.</p>

<p>따라서 여러 개의 값이 발행되었을 때 마지막에 들어온 값만 처리하고 싶을 때 사용하는 함수이다.</p>

<p>일단 무슨 말인지 잘 이해가 되지 않으므로 바로 마블 다이어그램을 봐보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76928219-32308080-6924-11ea-9266-dc35f5d350b1.PNG" alt="19" /></p>

<p>위 마블 다이어그램을 보면 초록 동그라미가 들어오고 그 결과값으로 Observable이 나오는데 이 때 파란 동그라미가 들어와 겹치게 된다.</p>

<p>그러면 초록 사각형 발행을 중단하고 파랑 다이아몬드를 처리하는 것을 볼 수 있다.</p>

<p>아래 RxJava로 switchMap() 함수를 이용한 예시를 봐보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">balls</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>

     <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">100L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Long:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">balls</span><span class="o">[</span><span class="n">idx</span><span class="o">])</span>
            <span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="n">balls</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>

            <span class="o">.</span><span class="na">switchMap</span><span class="o">(</span><span class="n">ball</span> <span class="o">-&gt;</span> <span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">200L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">notUsed</span> <span class="o">-&gt;</span> <span class="n">ball</span> <span class="o">+</span> <span class="s">"#"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
            <span class="o">);</span>

    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드를 보면 1, 2, 3이 100ms 시간 간격에 따라 하나씩 방출되어 새로운 Observable의 데이터 흐름이 되는데 새로운 Observable은 200ms 씩 item을 방출하는 형태이므로 3이 방출될 때 1의 출력과 겹치게 된다.</p>

<p>이 때, switchMap()을 사용했으므로 기존에 처리되던 1의 출력 작업은 중단되게 된다.</p>

<p>따라서 위 코드의 출력결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76928580-4759df00-6925-11ea-939d-25c624b93b36.PNG" alt="20" /></p>

<p>이 switchMap() 함수는 센서의 값을 얻어와야 하는 경우에 많이 사용된다. 센서값은 중간값보다는 최종적인 값으로 결과를 처리하는 경우가 더 많기 때문이다.</p>

<p><br /></p>

<h2 id="groupby-함수">👉🏽groupBy() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/groupby.html">groupBy() 함수</a> 는 원래의 Observable을 어떠한 기준을 적용시켜 두 개의 Observable로 나누어주는 함수이다.</p>

<p>groupBy() 함수의 마블 다이어그램을 보면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76929127-bd127a80-6926-11ea-933c-c09438c7e046.PNG" alt="21" /></p>

<p>이와 같다. 이 그림을 잘 살펴보면 동그라미는 동그라미끼리 삼각형은 삼각형끼리 서로 다른 Observable로 나뉘어지는 모습을 볼 수 있다.</p>

<p>그렇다면 RxJava로 groupBy() 함수를 사용한 예시를 봐보자!</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="o">{</span><span class="s">"6"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">,</span> <span class="s">"2-T"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"6-T"</span><span class="o">,</span> <span class="s">"4-T"</span><span class="o">};</span>

    <span class="c1">// GroupedObservable클래스는 Observable클래스와 동일하지만 getKey()라는 메서드를 제공하여</span>
    <span class="c1">// 구분된 그룹을 알 수 있게 해준다.</span>
    <span class="c1">// Test::getShape은 함수형 프로그래밍에서 인자로 함수를 넣을 때 사용하는 방식 중 하나이다.</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">GroupedObservable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">objs</span><span class="o">)</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getShape</span><span class="o">);</span>

    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">obj</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">val</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"GROUP:"</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\t Value:"</span> <span class="o">+</span> <span class="n">val</span><span class="o">));</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getShape</span><span class="o">(</span><span class="n">String</span> <span class="n">obj</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"-T"</span><span class="o">))</span> <span class="k">return</span> <span class="s">"TRIANGLE"</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="s">"BALL"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드의 실행결과는 다음과 같다!</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76930872-d4ebfd80-692a-11ea-9aaf-52855a3e6a97.PNG" alt="22" /></p>

<p><br /></p>

<h2 id="scan-함수">👉🏽scan() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/scan.html">scan() 함수</a> 는 <a href="https://choheeis.github.io/rxjava/2020/03/03/RxJavaOperator.html">Rx 연산자 포스팅</a> 에서 알아본 reduce() 함수와 비슷하다.</p>

<p>reduce() 함수는 Observable에서 모든 데이터가 입력된 후 그것을 종합하여 마지막 1개의 데이터만을 구독자에게 발행했지만 scan() 함수는 실행할 때마다 입력값에 맞는 중간 결과 및 최종 결과를 구독자에게 발행한다.</p>

<p>일단 reduce() 함수의 마블 다이어그램을 다시 한번 봐보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76931118-59d71700-692b-11ea-9178-5d13cfd8c37a.PNG" alt="24" /></p>

<p>reduce() 함수는 1, 2, 3, 4, 5 라는 데이터를 모두 더해서 마지막 결과값인 15만을 구독자에게 넘겨준다.</p>

<p>하지만 scan() 함수의 마블 다이어그램을 보면 reduce() 함수와 다른 점을 볼 수 있을 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/76931052-38762b00-692b-11ea-910d-2986788daf30.PNG" alt="23" /></p>

<p>위 마블 다이어그램에서와 같이 scan() 함수는 하나의 데이터가 합쳐질 때마다 그 결과를 구독자에게 넘겨준다.</p>

<p>즉, 마지막 데이터인 15만 넘겨지는 것이 아니라 합산된 결과를 그때 그때 넘겨주는 것이다.</p>

<p>그렇다면 RxJava로 scan() 함수를 사용한 예시를 봐보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">balls</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">};</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">balls</span><span class="o">)</span>
            <span class="o">.</span><span class="na">scan</span><span class="o">((</span><span class="n">ball1</span><span class="o">,</span> <span class="n">ball2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">ball2</span> <span class="o">+</span> <span class="s">"("</span> <span class="o">+</span> <span class="n">ball1</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드의 실행결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77033141-c6b0e680-69e9-11ea-8054-94e3a0f8df68.PNG" alt="25" /></p>

<p><br /></p>

<h1 id="3️⃣-결합combining-연산자">3️⃣ 결합(Combining) 연산자</h1>

<p>결합 연산자라는 것은 <a href="https://choheeis.github.io/rxjava/2020/03/03/RxJavaOperator.html">Rx의 연산자 포스팅</a>에서 살짝 소개했던 Rx 연산자 카테고리 중 하나이다.</p>

<p>위에서 보았던 생성연산자와 변환연산자는 한 개의 Observable(데이터 흐름)만을 다뤘다. 하지만 결합 연산자는 여러 개의 Observable들을 조합하여 활용하게 해준다.</p>

<ol>
  <li>
    <p>zip() 함수</p>
  </li>
  <li>
    <p>combineLatest() 함수</p>
  </li>
  <li>
    <p>merge() 함수</p>
  </li>
  <li>
    <p>concat() 함수</p>
  </li>
</ol>

<p><br /></p>

<h2 id="-zip-함수">👉🏼 zip() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/zip.html">zip() 함수</a> 는 여러 개의 Observable이 방출하는 데이터들을 특정한 함수를 통해서 결합시켜주는 함수이다.</p>

<p>zip() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77034382-2c52a200-69ed-11ea-9cc2-2f5a26ce70ae.PNG" alt="26" /></p>

<p>이 마블 다이어그램을 살펴보면 먼저 두 개의 서로 다른 Observable이 존재하는데 결과적으로는 두 Observable에서 방출되는 item이 결합된 또 다른 새로운 Observable이 탄생한다는 것을 알 수 있다.</p>

<p>zip() 함수의 원형을 찾아보면 다음과 같다.</p>

<blockquote>
  <p>Observable 클래스에 포함된 함수들을 모두 볼 수 있는 document –&gt; <a href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html">여기</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/31889335/77034635-c581b880-69ed-11ea-8c0d-913d59975e74.PNG" alt="27" /></p>

<p>source1, source2 는 서로 다른 Observable이고 zipper 변수는 이 두 Observable을 결합시킬 원하는 함수이다.</p>

<p>그렇다면 RxJava로 zip() 함수를 사용해 본 예시를 봐보자!</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">HEXAGON</span> <span class="o">=</span> <span class="s">"HEXAGON"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">OCTAGON</span> <span class="o">=</span> <span class="s">"OCTAGON"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">RECTANGLE</span> <span class="o">=</span> <span class="s">"RECTANGLE"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TRIANGLE</span> <span class="o">=</span> <span class="s">"TRIANGLE"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIAMOND</span> <span class="o">=</span> <span class="s">"DIAMOND"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PENTAGON</span> <span class="o">=</span> <span class="s">"PENTAGON"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">BALL</span> <span class="o">=</span> <span class="s">"BALL"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">STAR</span> <span class="o">=</span> <span class="s">"STAR"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">shapes</span> <span class="o">=</span> <span class="o">{</span><span class="s">"BALL"</span><span class="o">,</span> <span class="s">"PENTAGON"</span><span class="o">,</span> <span class="s">"STAR"</span><span class="o">};</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">coloredTriangles</span> <span class="o">=</span> <span class="o">{</span><span class="s">"2-T"</span><span class="o">,</span> <span class="s">"6-T"</span><span class="o">,</span> <span class="s">"4-T"</span><span class="o">};</span>

        <span class="c1">// 두 Observable을 생성하고 결합하기</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">zip</span><span class="o">(</span>
                <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">shapes</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getSuffix</span><span class="o">),</span>
                <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">coloredTriangles</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">Test:</span><span class="o">:</span><span class="n">getColor</span><span class="o">),</span>
                <span class="o">(</span><span class="n">suffix</span><span class="o">,</span> <span class="n">color</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">color</span> <span class="o">+</span> <span class="n">suffix</span><span class="o">);</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">// 하이푼 전까지의 문자열을 추출하는 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getColor</span><span class="o">(</span><span class="n">String</span> <span class="n">shape</span><span class="o">){</span>
        <span class="c1">// 인자로 들어온 shape의 모양이 다이아몬드로 끝날 경우</span>
        <span class="k">if</span><span class="o">(</span><span class="n">shape</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"◇"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="n">shape</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"◇"</span><span class="o">,</span> <span class="s">""</span><span class="o">).</span><span class="na">trim</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// -의 위치를 인덱스로 저장</span>
        <span class="kt">int</span> <span class="n">hyphen</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">"-"</span><span class="o">);</span>

        <span class="k">if</span><span class="o">(</span><span class="n">hyphen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">shape</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">hyphen</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 원의 경우</span>
        <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getSuffix</span><span class="o">(</span><span class="n">String</span> <span class="n">shape</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">HEXAGON</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"-H"</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">OCTAGON</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"-O"</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">RECTANGLE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"-R"</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">TRIANGLE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"-T"</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">DIAMOND</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"◇"</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">PENTAGON</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"-P"</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">STAR</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">shape</span><span class="o">))</span> <span class="k">return</span> <span class="s">"-S"</span><span class="o">;</span>

        <span class="c1">// 원의 경우</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>위 코드의 실행결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77035640-8dc84000-69f0-11ea-9469-6ee593a308aa.PNG" alt="28" /></p>

<p><br /></p>

<h2 id="-combinelatest-함수">👉🏼 combineLatest() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/combinelatest.html">combineLatest() 함수</a> 는 서로 다른 두 개의 Observable로부터 아이템이 방출되었을 때 각각의 Observable에서 가장 마지막으로 방출된 아이템을 특정한 함수에 적용시켜 결합시켜주는 함수이다.</p>

<p>또한 combineLatest() 함수의 결과로 결합된 아이템을 방출하는 또 다른 새로운 Observable이 생성된다.</p>

<p>combineLatest() 함수의 마블 다이어그램을 봐보자!</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77036094-9a996380-69f1-11ea-9094-2fc04ba4b328.PNG" alt="29" /></p>

<p>이 마블 다이어그램을 보면 combineLatest() 함수의 기능을 더욱 확실히 알 수 있을 것이다.</p>

<p>위 마블 다이어그램에서는 일단 서로 다른 두 개의 Observable이 존재한다.</p>

<p>첫 번째 Observable이 1이라는 데이터를 방출하고 난 후에 두 번째 Observable이 A라는 데이터를 방출한다.</p>

<p>그러면 이 시점에서 각 Observable에서 가장 마지막으로 방출된 것은 1과 A이므로 이 둘을 결합하면 1A가 된다.</p>

<p>이어서 첫 번째 Observable에서 2를 방출하였다. 그러면 이 시점에서 각 Observable에서 가장 마지막으로 방출된 것은 2와 A이므로 이 둘을 결합한 것은 2A가 된다.</p>

<p>이어서 두 번째 Observable에서 B를 방출하게 되므로 이 시점에서 각 Observable이 가장 마지막으로 방출한 것은 2와 B가 된다.</p>

<p>따라서 이 둘이 결합된 2B가 나오게 된다.</p>

<p>이런 식으로 어느 Observable에서 데이터의 변경이 일어나면 그 시점에서의 가장 마지막 데이터가 무엇인지 파악하고 결합해주는 함수가 combineLatest() 함수인 것이다.</p>

<p>이 함수의 원형도 위에서 언급한 문서에서 찾을 수 있으므로 찾아서 사용하면 된다!</p>

<p><br /></p>

<h2 id="-merge-함수">👉🏼 merge() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/merge.html">merge() 함수</a> 는 여러 개의 Observable을 하나의 Observable로 결합해주는 가장 단순한 함수이다.</p>

<p>각 Observable의 데이터를 변형하지 않고 순서대로 결합해준다.</p>

<p>merge() 함수의 마블 다이어그램을 봐보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77036604-db45ac80-69f2-11ea-853d-ea124f62a8cf.PNG" alt="30" /></p>

<p>이 다이어그램을 보면 서로 다른 두 개의 Observable이 하나의 Observable로 합쳐지는데 이 때 각 Observable의 데이터가 결합되거나 변형되지 않고 순서대로 끼워 넣어지는 모습을 볼 수 있다.</p>

<p>merge() 함수도 원형을 찾아서 인자에 무엇을 넣어야하는지 알아보고 사용하면 된다!</p>

<p><br /></p>

<h2 id="-concat-함수">👉🏼 concat() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/concat.html">concat() 함수</a> 는 두 개 이상의 서로 다른 Observable들을 이어 붙여주는 기능을 하는 함수이다.</p>

<p>concat() 함수는 서로 다른 Observable을 이어 붙일 때 interleaving(끼어들기, 인터리빙)을 하지 않고 그냥 쭈루룩 이어 붙여준다.</p>

<p>concat() 함수의 마블 다이어그램을 봐보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77036998-a5ed8e80-69f3-11ea-9bdb-c3a39ab1101d.PNG" alt="31" /></p>

<p>위 마블 다이어그램을 보면 두 Observable이 item을 방출하는 시간이 겹치지만 이것을 하나의 Observable로 합칠 때는 겹치는 시간을 고려하지 않고 뒤로 이어서 붙여지는 모습을 볼 수 있다.</p>

<p>여기서 주의할 점은 첫 번째 Observable이 onComplete 되지 않는다면 즉, Observable이 종료되지 않는다면 두 번째 Observable을 첫 번째 Observable이 끝날 때까지 계속 기다려야 하는 상황이 발생한다.</p>

<p>따라서 잠재적인 메모리 누수의 위험을 내포하고 있다는 것을 알아두어야 하고, 꼭 Observable이 완료될 수 있게 해야 한다.</p>

<p>concat() 함수도 원형을 찾아보고 그에 맞게 사용하면 된다!</p>

<p><br /></p>

<h1 id="4️⃣-조건-연산자">4️⃣ 조건 연산자</h1>

<p>조건 연산자는 Observable의 흐름을 제어하는 역할을 하는 연산자이다.</p>

<ol>
  <li>
    <p>amb() 함수</p>
  </li>
  <li>
    <p>takeUntil(other) 함수</p>
  </li>
  <li>
    <p>skipUntil(other) 함수</p>
  </li>
  <li>
    <p>all() 함수</p>
  </li>
</ol>

<p><br /></p>

<h2 id="-amb-함수">👉🏻 amb() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/amb.html">amb() 함수</a> 는 ambiguous(모호한)이라는 영어 단어의 줄임말이다.</p>

<p>이 함수는 여러 개의 Observable 중 item 방출이 가장 먼저 되는 Observable만 선택하고 나머지 Observable은 무시하는 함수이다.</p>

<p>amb() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77282919-81085c80-6d0e-11ea-81aa-c32dbf7ac65d.PNG" alt="32" /></p>

<p>이 마블 다이어그램을 보면 총 3개의 Observable이 있는데 그 중 첫 번째 item 방출 시간이 가장 빠른 두 번째 Observable만 선택받고 나머지는 무시되는 모습을 볼 수 있다!</p>

<p>amb() 함수의 원형은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77283013-c4fb6180-6d0e-11ea-8c54-557981ed8c79.PNG" alt="33" /></p>

<p>List처럼 Iterable&lt;Observable&lt;T» 객체를 인자로 넣으면 그 중에서 가장 먼저 데이터를 발행하는 Observable만 선택해서 계속 값을 발행하도록 해준다.</p>

<p>그렇다면 Rxjava로 amb() 함수를 사용한 예시를 봐보자!</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">data1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">};</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">data2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"2-R"</span><span class="o">,</span> <span class="s">"4-R"</span><span class="o">};</span>

        <span class="c1">// 1) sources 변수에 data1을 데이터로 발행하는 Observable과</span>
        <span class="c1">//    100ms 동안 기다렸다가 data2를 데이터로 발행하는 Observable을 넣는다.</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">sources</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">data1</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">doOnComplete</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Observable #1 : onComplete()"</span><span class="o">)),</span>
                <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">data2</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">delay</span><span class="o">(</span><span class="mi">100L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">doOnComplete</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Observable #2 : onComplete()"</span><span class="o">))</span>
        <span class="o">);</span>

        <span class="c1">// 2) sources 변수를 amb() 함수의 인자로 넣는다.</span>
        <span class="n">Observable</span><span class="o">.</span><span class="na">amb</span><span class="o">(</span><span class="n">sources</span><span class="o">)</span>
                <span class="o">.</span><span class="na">doOnComplete</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result : onComplete()"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>위 코드의 실행결과는</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77283535-f294da80-6d0f-11ea-8df8-9ca5eda14b7d.PNG" alt="34" /></p>

<p>이와 같다.</p>

<p><br /></p>

<h2 id="-takeuntil-함수">👉🏻 takeUntil() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/takeuntil.html">takeUntil() 함수</a> 는 <a href="http://reactivex.io/documentation/operators/take.html">take()</a> 라는 함수에 조건을 설정할 수 있는 함수이다.</p>

<p>더 정확하게는 takeUntil() 함수의 인자로 받은 Observable에서 어떤 값을 발행하면 현재 Observable의 데이터 발행을 중단하고 즉시 완료 (onComplete) 하게 해준다.</p>

<p>takeUntil() 함수의 마블 다이어그램을 봐보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77283752-78188a80-6d10-11ea-81d7-87b554a15075.PNG" alt="35" /></p>

<p>위 마블 다이어그램을 보면 알 수 있듯이 인자로 받은 걸로 보여지는 두 번째 Observable에서 첫 번째 item이 방출되는 순간 현재 Observable가 종료되는 것을 볼 수 있다.</p>

<p>즉, take() 함수처럼 일정 개수만 값을 발행하도록 하는 대신 그 기준을 다른 Observable에서 값을 발행하는지로 판단하는 것이다.</p>

<p>takeUntil() 함수의 원형은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77283905-cc236f00-6d10-11ea-8a4e-c576b3006bda.PNG" alt="36" /></p>

<p>즉, 마침의 기준이 되는 other Observable이 필요한 것이다!</p>

<p>그렇다면 RxJava로 takeUntil() 함수를 사용해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">,</span> <span class="s">"6"</span><span class="o">};</span>

        <span class="c1">// 1) 현재 Observable은 100L 마다 데이터를 방출한다.</span>
        <span class="c1">// 2) 기준이 되는 Other Observable은 500L 마다 데이터를 방출한다.</span>
        <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">fromArray</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
                <span class="o">.</span><span class="na">zipWith</span><span class="o">(</span><span class="n">Observable</span><span class="o">.</span><span class="na">interval</span><span class="o">(</span><span class="mi">100L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">),</span> <span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">notUsed</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="o">)</span>
                <span class="o">.</span><span class="na">takeUntil</span><span class="o">(</span><span class="n">Observable</span><span class="o">.</span><span class="na">timer</span><span class="o">(</span><span class="mi">500L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">));</span>

        <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 기준이 되는 Other Observable은 500L 마다 데이터를 방출하므로 현재 Observable이 데이터 5를 방출할 때 처음 데이터가 방출되게 된다. 따라서 현재 Observable은 이 시점에서 종료된다.</p>

<p>위 코드의 실행결과는</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77284492-27a22c80-6d12-11ea-90b6-14fdbd959b83.PNG" alt="37" /></p>

<p>이와 같다.</p>

<p><br /></p>

<h2 id="-skipuntil-함수">👉🏻 skipUntil() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/skipuntil.html">skipUntil() 함수</a> 는 takeUntil() 함수와 정반대의 기능을 가진 함수이다.</p>

<p>인자로 기준이 되는 other Observable을 받는다는 점은 같지만 skipUntil() 함수는 other Observable에서 첫 데이터를 발행할 때까지 현재 Observable이 방출하는 데이터를 무시한다.</p>

<p>skipUntil() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77284643-810a5b80-6d12-11ea-9c06-0b52e3ab24a7.PNG" alt="38" /></p>

<p>위 마블 다이어그램을 보면 알 수 있듯이 skipUntil() 함수는 기준이 되는 Observable로 보이는 두 번째 Observable의 첫 데이터가 방출되기 전까지 현재 Observable에서 방출되는 데이터를 무시한다.</p>

<p><br /></p>

<h2 id="-all-함수">👉🏻 all() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/all.html">all() 함수</a> 는 방출되는 모든 item이 주어진 조건에 100% 맞을 때만 true 값을 발행하고 조건에 맞지 않는 데이터가 하나라도 발행되면 바로 false 값을 발행하는 함수이다.</p>

<p>all() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77284806-e3fbf280-6d12-11ea-818a-3221d0d170a6.PNG" alt="39" /></p>

<p>위 마블 다이어그램을 보면 알 수 있듯이 all() 함수에 들어오는 모든 데이터가 10보다 작으므로 마지막에 true가 발행된 것이다.</p>

<p>all() 함수의 원형은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77285334-135f2f00-6d14-11ea-867f-ce50e196ba09.PNG" alt="40" /></p>

<p><br /></p>

<h1 id="5️⃣-기타-연산자">5️⃣ 기타 연산자</h1>

<p>RxJava에는 유독 시간을 다루는 함수들이 많다.</p>

<ol>
  <li>
    <p>delay() 함수</p>
  </li>
  <li>
    <p>timeInterval() 함수</p>
  </li>
</ol>

<p><br /></p>

<h2 id="-delay-함수">👉 delay() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/delay.html">delay() 함수</a> 는 시간을 인자로 받아서 그 시간 만큼이 지난 후로 item들을 미뤄주는 함수이다.</p>

<p>delay() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77285785-2de5d800-6d15-11ea-84ac-6a9bdfec9809.PNG" alt="41" /></p>

<p>이 다이어그램을 보면 알 수 있듯이 일정 시간 후로 item 방출이 밀려있다.</p>

<p>delay() 함수의 원형을 찾아보고 적합하게 사용하면 된다!</p>

<p><br /></p>

<h2 id="-timeinterval-함수">👉 timeInterval() 함수</h2>

<p><a href="http://reactivex.io/documentation/operators/timeinterval.html">timeInterval() 함수</a> 는 어떤 데이터 값이 발행되었을 때 그 이전 값이 발행된 이후 얼마나 시간이 흘렀는지를 알려주는 함수이다.</p>

<p>timeInterval() 함수의 마블 다이어그램은 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/77285906-861cda00-6d15-11ea-8fea-90ae4f786200.PNG" alt="42" /></p>

<p>위 마블 다이어그램에서 알 수 있듯이 timeInterval() 함수는 어떤 데이터가 발행될 때 그 이전의 시간 간격을 알려준다.</p>

<p><br /></p>

<blockquote>
  <p>지금까지 Rx에서 지원하는 Observable클래스 안에 정의되어 있는 연산자(함수)들의 대장정이였다!!!</p>

  <p>Rx에는 이것들 외에도 무수히 많은 함수들이 있으므로 사용할 수 있는 함수들의 가능성을 열어두자~! 👍</p>
</blockquote>


  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

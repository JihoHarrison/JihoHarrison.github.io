<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="  동빈나 유튜브 영상을 참고하여 공부한 내용!👔 DFS란?DFS란 Depth First Search의 줄임말로 깊이 우선 탐색 알고리즘이라고도 한다.DFS도 BFS와 마찬가지로 어떠한 그래프에서 각 노드를 맹목적으로 탐색해봐야 할 때 사용된다.BFS는 큐가 사용되었지만 DFS는 ...">
  <meta name="keywords" content="blog and jekyll">
  <meta name="author" content="[알고리즘] 👔 DFS(깊이 우선 탐색) | choheeis">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f5f5f5">

  <!-- Twitter Tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[알고리즘] 👔 DFS(깊이 우선 탐색) | choheeis">
  <meta name="twitter:description" content="  동빈나 유튜브 영상을 참고하여 공부한 내용!👔 DFS란?DFS란 Depth First Search의 줄임말로 깊이 우선 탐색 알고리즘이라고도 한다.DFS도 BFS와 마찬가지로 어떠한 그래프에서 각 노드를 맹목적으로 탐색해봐야 할 때 사용된다.BFS는 큐가 사용되었지만 DFS는 ...">
  
    <meta property="twitter:image" content="http://localhost:4000/img/leonids-logo.png">
  

  <!-- Open Graph Tags -->
  <meta property="og:type" content="blog">
  <meta property="og:url" content="http://localhost:4000/articles/2020-03/DFS">
  <meta property="og:title" content="[알고리즘] 👔 DFS(깊이 우선 탐색) | choheeis">
  <meta property="og:description" content="  동빈나 유튜브 영상을 참고하여 공부한 내용!👔 DFS란?DFS란 Depth First Search의 줄임말로 깊이 우선 탐색 알고리즘이라고도 한다.DFS도 BFS와 마찬가지로 어떠한 그래프에서 각 노드를 맹목적으로 탐색해봐야 할 때 사용된다.BFS는 큐가 사용되었지만 DFS는 ...">
  
    <meta property="og:image" content="http://localhost:4000/img/leonids-logo.png">
  
  <title>[알고리즘] 👔 DFS(깊이 우선 탐색) | choheeis</title>

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/articles/2020-03/DFS">
  <link rel="alternate" type="application/rss+xml" title="choheeis" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/">
    <img src="http://localhost:4000/img/avatar.png" alt="" class="avatar">
  </a>
  
  <a href="http://localhost:4000/" class="author_name">김초희</a>
  <span class="author_job">나는야 안드로이드 개발자 꿈나무 🍎</span>
  <span class="author_bio mbm">구경하러 오신 분들 모두 좋은 하루 되세요 🍉</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
      <li class="nav-item">
        <a href="http://localhost:4000/archive/">Archive</a>
      </li>
            
      <li class="nav-item">
        <a href="http://localhost:4000/categories/">Categories</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/resume/">Resume</a>
      </li>
          
      <li class="nav-item">
        <a href="http://localhost:4000/tags/">Tags</a>
      </li>
       
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
      <li>
      <script>gen_mail_to_link('chchgml10@gmail.com', 'Hello from website');</script>
      </li>
    
    
    
    
    
    
    
    <li><a href="http://instagram.com/chooeeh" class="social-link-item" target="_blank"><i class="fa fa-fw fa-instagram"></i></a></li>
    
    <li><a href="http://github.com/choheeis" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="[알고리즘] 👔 DFS(깊이 우선 탐색)">[알고리즘] 👔 DFS(깊이 우선 탐색)</h1>
    <span class="post-meta">
      <span class="post-date">
        4 MAR 2020
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    5 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <blockquote>
  <p><a href="https://www.youtube.com/watch?v=l0Rsu7dziws&amp;list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&amp;index=17">동빈나 유튜브</a> 영상을 참고하여 공부한 내용!</p>
</blockquote>

<p><br /></p>

<h1 id="-dfs란">👔 DFS란?</h1>

<p>DFS란 Depth First Search의 줄임말로 <strong>깊이 우선 탐색</strong> 알고리즘이라고도 한다.</p>

<p>DFS도 BFS와 마찬가지로 어떠한 그래프에서 각 노드를 맹목적으로 탐색해봐야 할 때 사용된다.</p>

<p>BFS는 큐가 사용되었지만 DFS는 <strong>스택(Stack)</strong> 이 사용된다.</p>

<p><br /></p>

<h1 id="-dfs-알고리즘의-작동-원리">👔 DFS 알고리즘의 작동 원리</h1>

<p>아래와 같은 그래프와 스택이 있다고 가정하고 그래프의 각 노드를 탐색해야 한다고 해보자.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75888127-39f51d00-5e6e-11ea-8929-b022b119b05d.PNG" alt="01" /></p>

<p>DFS도 BFS처럼 제일 먼저 시작 노드를 스택에 넣어주고 방문처리를 해줌으로써 시작한다.</p>

<p>방문처리는 노드의 색을 연두색으로 칠함으로써 표시하였다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75888185-57c28200-5e6e-11ea-9f0a-66020ae21495.PNG" alt="02" /></p>

<p>위 그림과 같이 시작노드인 1이 스택에 담겨있고, 노드 1은 방문처리가 된 모습임을 알 수 있다.</p>

<p>이제 이 다음부터는 다음 2개의 과정을 반복함으로써 DFS 알고리즘이 완성된다.</p>

<ol>
  <li>
    <p>스택의 최상단 노드를 확인한다.(스택의 특성을 생각해보면 가장 마지막에 들어온 노드를 확인하는 것과 같다.)</p>
  </li>
  <li>
    <p>최상단 노드의 인접 노드 중에서 방문하지 않은 노드가 있으면 그 노드를 스택에 넣고 방문처리한다. 만약 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 뺀다.</p>
  </li>
</ol>

<p>그렇다면 현재 상태에서 스택의 최상단 노드는 1이다.</p>

<p>1의 인접 노드인 2와 3중에서 방문하지 않은 노드인 2부터 스택에 넣고 방문 처리 하면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75888884-63fb0f00-5e6f-11ea-81bc-3ceebc2ff1e6.PNG" alt="03" /></p>

<p>이와 같이 된다.</p>

<p>이제 다시 반복적으로 스택의 최상단 노드를 확인해보면 노드 2가 최상단 노드임을 확인할 수 있다.</p>

<p>2와 인접한 노드인 3과 4에서 3부터 스택에 넣고 방문처리를 하면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889039-9d337f00-5e6f-11ea-98c3-836a6483f659.PNG" alt="04" /></p>

<p>이렇게 된다.</p>

<p>이제 스택의 최상단 노드인 3을 보면 3과 인접한 노드 중에서 아직 방문하지 않은 6을 스택에 넣고 방문 처리 하면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889109-bfc59800-5e6f-11ea-92b9-a704738a7a6f.PNG" alt="05" /></p>

<p>이렇게 된다.</p>

<p>그 다음, 스택의 최상단 노드인 6과 인접한 노드 중 아직 방문하지 않은 노드7을 스택에 넣고 방문처리를 해주면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889239-f4d1ea80-5e6f-11ea-88b2-d86cb39f880a.PNG" alt="06" /></p>

<p>이와 같이 된다.</p>

<p>그 다음, 스택의 최상단 노드인 7을 보면 조금 다른 과정이 나온다.</p>

<p>노드 7과 인접한 노드 중 아직 방문하지 않은 노드는 존재하지 않는다. 그러므로 스택에서 노드 7을 빼주면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889354-22b72f00-5e70-11ea-8bbe-539ce74b75e1.PNG" alt="07" /></p>

<p>이렇게 된다.</p>

<p>노드 7과 마찬가지로 최상단 노드인 6도 스택에서 나오게 되고, 3도 나오게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889440-48dccf00-5e70-11ea-9d45-adf015469478.PNG" alt="08" /></p>

<p>이 상태에서 최상단 노드인 2는 인접한 노드 중 아직 방문하지 않은 노드가 존재하므로 노드 4를 스택에 넣고 방문처리 해준다.</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889529-6ad65180-5e70-11ea-8654-9e96bc9450f8.PNG" alt="09" /></p>

<p>그러면 이와 같게 될 것이다.</p>

<p>그 다음, 스택의 최상단 노드인 4와 인접한 노드 중 아직 방문하지 않은 노드 5를 스택에 넣고 방문처리 해주면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75889643-935e4b80-5e70-11ea-8e0e-c3ea4eb355bd.PNG" alt="10" /></p>

<p>이렇게 된다.</p>

<p>이제 모든 노드가 방문되었으므로 최상단 노드인 5는 스택에서 빠져나오게 되고 마찬가지로 노드 4, 노드 2, 노드 1도 스택에서 모두 빠져나오게 된다.</p>

<p>따라서 그래프의 모든 노드의 방문이 완료된다!</p>

<p>방문했던 노드의 순서를 살펴보면 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; 7 -&gt; 4 -&gt; 5 이다.</p>

<p><br /></p>

<h1 id="-dfs-알고리즘을-코드로-구현해보기">👔 DFS 알고리즘을 코드로 구현해보기</h1>

<p>DFS 알고리즘을 구현하기 전에 알아야하는 사실이 하나 있다!</p>

<p>DFS 알고리즘을 코드로 구현할 때는 사실 스택을 실제로 사용하지 않는다.</p>

<p>왜냐하면 컴퓨터는 이미 항상 스택의 원리를 사용하고 있기 때문에 굳이 새로운 스택을 사용하지 않아도 된다.</p>

<p>새로운 스택을 사용하는 것 대신에 <strong>재귀 함수</strong> 를 이용해서 DFS 알고리즘을 구현할 수 있다.</p>

<p>컴퓨터가 재귀함수를 처리할 때 컴퓨터의 내부적인 구조인 스택에 차곡차곡 쌓이는 형태로 처리하기 때문이다!</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// 그래프의 노드의 갯수
</span><span class="kt">bool</span> <span class="n">checked</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// 방문처리를 위한 배열 
</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// 각 노드에 인접한 노드를 표시하기 위한 벡터
</span>
<span class="cm">/* dfs 알고리즘을 구현한 함수 */</span>
<span class="cm">/* --&gt; 인자 x는 특정한 노드를 의미 */</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="c1">// 특정한 노드 x가 이미 방문한 노드일 경우  
</span>	<span class="k">if</span><span class="p">(</span><span class="n">checked</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">){</span>
		<span class="c1">// 재귀함수 종료  
</span>		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="c1">// 특정한 노드 x를 처음 방문하는 경우  
</span>		<span class="n">checked</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 방문 처리
</span>		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span> <span class="c1">// 방문한 노드 출력  
</span>		
		<span class="c1">// 특정한 노드 x와 인접한 노드를 하나씩 검사하면서  
</span>		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">];</span> <span class="c1">// x와 인접한 노드를 y라 선언 
</span>			<span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// 그 y에 대해서 dfs 재귀함수 호출  
</span>		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span> 

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="c1">// 노드 1과 연결되어 있는 노드들 추가  
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 그래프에서 노드 1은 노드 2와 3과 연결되어 있음 
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	
	<span class="c1">// 노드 2와 연결되어 있는 노드들 추가 
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
	<span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	
	<span class="c1">// 노드 3과 연결되어 있는 노드들 추가  
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
	<span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
	
	<span class="c1">// 노드 4와 연결되어 있는 노드들 추가
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> 
	<span class="n">vec</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 
	
	<span class="c1">// 노드 5와 연결되어 있는 노드들 추가 
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> 
	<span class="n">vec</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> 
	
	<span class="c1">// 노드 6과 연결되어 있는 노드들 추가 
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> 
	<span class="n">vec</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> 
	
	<span class="c1">// 노드 7과 연결되어 있는 노드들 추가 
</span>	<span class="n">vec</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> 
	<span class="n">vec</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
	
	<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// dfs 함수 호출
</span>		
<span class="p">}</span>
</code></pre></div></div>

<p>위와 같은 DFS 알고리즘을 구현한 코드를 실행시켜보면</p>

<p><img src="https://user-images.githubusercontent.com/31889335/75891602-59db0f80-5e73-11ea-9846-85db2cd4c780.PNG" alt="11" /></p>

<p>이렇게 노드를 방문한 순서가 정확히 나오는 것을 볼 수 있다.</p>

<p><br /></p>


  </article>

  <div id="comment">
    <script src="https://utteranc.es/client.js"
      repo="choheeis/blog-comments"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

<!--  -->

        <footer>
  &copy; 2021 김초희. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>


</body>
</html>

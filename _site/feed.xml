<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JihoKevin</title>
    <description>안드로이드 개발자를 목표로 달려나가는 Kevin의 블로그입니다!</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>2021-09-15</pubDate>
    <lastBuildDate>Wed, 15 Sep 2021 07:46:47 +0200</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>[RxKotlin] 🌊 Flowable과 Observable 그리고 BackPressureStrategy</title>
        <description>&lt;h2 id=&quot;프롤로그&quot;&gt;프롤로그&lt;/h2&gt;
&lt;p&gt;사내 서비스 유지 보수를 해 가며 &lt;code class=&quot;highlighter-rouge&quot;&gt;RxKotlin&lt;/code&gt;을 집중적으로 학습하다보니 문득 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorSubject&lt;/code&gt;의 차이가 궁급해졌고, 이를 탐구하며 들어와보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;의 차이를 알아야 했다. 열심히 구글링을 해 가며 알게 된 것이 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;BackPressure&lt;/code&gt; 즉, 배압의 내장 유무였다.&lt;/p&gt;

&lt;h2 id=&quot;배압-backpressure&quot;&gt;배압 (BackPressure)&lt;/h2&gt;
&lt;h3 id=&quot;reactivex에서-배압이-발생-할-조건&quot;&gt;ReactiveX에서 배압이 발생 할 조건&lt;/h3&gt;
&lt;p&gt;데이터를 발행하는 속도와 구독하는 자가 처리하는 속도의 차이가 있을 때 발생한다.&lt;/p&gt;

&lt;p&gt;이 말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;가 수신 할 수 없을 만큼의 엄청난 양의 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;이 방출 할 때 나타난다는 말이다. 이 경우에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Out of Memory Error&lt;/code&gt;가 발생하게 된다.
이러한 경우에 대한 예외 처리가 필요한데 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;BackPressureStrategy&lt;/code&gt;라고 한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;은 결국 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;의 일종이기 때문에, 이 둘은 이러한 차이점만 뺀다면 거의 동일한 형식이라고 봐도 무방하다. 아래의 사이트에서 다음과 같은 부분을 보면 된다. 
 &lt;a href=&quot;https://medium.com/mindorks/rxjava-types-of-observables-404d75605e35&quot;&gt;링크&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;/img/09-15-backpressure/backpressure.png&quot; alt=&quot;backpressure&quot; width=&quot;800&quot; height=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이론적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;을 사용 할 조건은 대량의 데이터 예를들어, 초당 10000건 이상의 데이터 처리를 해야 할 때, 또는 네트워크 통신이나 DB등의 IO스레드에 접근할 때 라고 말하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;을 사용 할 조건은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;과 반대되는 상황으로, 소량의 데이터 또는 GUI 이벤트 등을 처리할 때 사용 된다고 한다.&lt;/p&gt;

&lt;h2 id=&quot;flowable의-배압-대응-전략&quot;&gt;Flowable의 배압 대응 전략&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onBackPressureBuffer()&lt;/code&gt; : 배압 이슈가 발생했을때 별도의 버퍼에 저장한다.&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt; 클래스는 기본적으로 128개의 버퍼가 있다. 버퍼에 만들고 쌓아두다가 처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onBackPressureDrop()&lt;/code&gt; : 배압 이슈가 발생했을 때 해당 데이터를 무시한다. 배압 이슈 이후의 데이터는 다 무시한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onBackPressureLatest()&lt;/code&gt; : 처리할 수 없어서 쌓이는 데이터를 무시하면서 최신 데이터만 유지한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 모든 데이터 스트림에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;을 사용하는 것은 결코 바람직하지 않은 방법이 될 것이다. 소량이 데이터나 UI 이벤트 처리와 같은 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt; 에서도 데이터 스트림의 시간차 등을 두어 스트림의 양을 조절하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;debounce()&lt;/code&gt;라던지, &lt;code class=&quot;highlighter-rouge&quot;&gt;throttle()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sample()&lt;/code&gt; 함수 등이 존재하기 때문에 상황에 따라 적절하게 사용하는 방법을 익히면 될 것 같다.&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/flowable-observable</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/flowable-observable</guid>
        
        
        <category>RxKotlin</category>
        
      </item>
    
      <item>
        <title>[RxKotlin] Hot🔥 &amp; Cold❄️ Observable</title>
        <description>&lt;h2 id=&quot;hot-observable과-cold-observable의-차이&quot;&gt;Hot Observable과 Cold Observable의 차이&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Reactive Programming&lt;/code&gt;을 배우면서 가장 많이 접한 개념이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow&lt;/code&gt;가 어떻게 흘러가는지이다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;은 우리에게 데이터를 배출 시키는 존재이고, 우리는 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe&lt;/code&gt; 함으로써 배출되는 데이터를 얻을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;cold-observable&quot;&gt;Cold Observable&lt;/h2&gt;
&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;cold observable&lt;/code&gt;부터 설명하자면, 앞서 다뤘던 기본적인 예제들처럼 동일한 옵저버블을 여러번 구독해도 그 시점에 항상 새로운 데이터 flow를 얻을 수 있었다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;String 1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;String 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;String 3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Recieved $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error ${it.message}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Done&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    
        &lt;span class=&quot;n&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Recieved $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error ${it.message}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Done&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;출력결과&quot;&gt;출력결과&lt;/h3&gt;

&lt;p&gt;Recieved String 1&lt;br /&gt;
Recieved String 2&lt;br /&gt;
Recieved String 3&lt;br /&gt;
Done&lt;br /&gt;
Recieved String 1&lt;br /&gt;
Recieved String 2&lt;br /&gt;
Recieved String 3&lt;br /&gt;
Done&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위의 예제처럼 여러번 구독을 하더라도 구독을 한 시점부터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;의 요소인 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;String 1&quot;, &quot;String 2&quot;, &quot;String 3&quot;&lt;/code&gt; 값을 얻을 수 있었다.
이러한 특징을 가지고 있는 Observable을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cold Observable&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;hot-observable&quot;&gt;Hot Observable&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hot Observalbe&lt;/code&gt;은 old와 반대로 구독을 하기 전 부터 데이터를 내보내기 시작한다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;Cold Observable&lt;/code&gt;을 CD나 레코드로 본다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hot Observable&lt;/code&gt;은 TV 채녈의 특징과 비슷하다. 이는 결국 구독을 하지 않아고 데이터를 배출 시키기 때문에 구독을 할 필요가 없다. 여기서 중요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;의 개념이 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConnectableObservable&lt;/code&gt;이다. 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;cold&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;hot&lt;/code&gt;으로 바꿀 수 있기도 하다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;connectableObservable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;connectableObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;subscription 1: $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;connectableObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;subscription 2: $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;connectableObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;runBlocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;connectableObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;subscription 3: $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;runBlocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;출력결과-1&quot;&gt;출력결과&lt;/h3&gt;

&lt;p&gt;subscription 1: 0&lt;br /&gt;
subscription 2: 0&lt;br /&gt;
subscription 1: 1&lt;br /&gt;
subscription 2: 1&lt;br /&gt;
subscription 1: 2&lt;br /&gt;
subscription 2: 2&lt;br /&gt;
subscription 1: 3&lt;br /&gt;
subscription 2: 3&lt;br /&gt;
subscription 3: 3&lt;br /&gt;
subscription 1: 4&lt;br /&gt;
subscription 2: 4&lt;br /&gt;
subscription 3: 4&lt;br /&gt;
subscription 1: 5&lt;br /&gt;
subscription 2: 5&lt;br /&gt;
subscription 3: 5&lt;br /&gt;
—&lt;/p&gt;

&lt;p&gt;위의 출력 결과를 보면 1, 2 구독자가 구독을 한 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt; 한 시점 즉, 데이터가 배출되기 시작한 시점부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;500ms&lt;/code&gt;를 대기 하면서 총 5개의 데이터를 받게 된다.
그 5초가 지났을 때 부터 또 다른 3 구독자가 구독하기 시작하면서 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;500ms&lt;/code&gt; 간 &lt;code class=&quot;highlighter-rouge&quot;&gt;delay&lt;/code&gt;를 주게 된다. 이렇게 총 10개의 데이터를 시간 순서에 따라 받아 올 것이고,
출력 결과과 같이 3번 구독자는 이 전에 1, 2 구독자가 받았던 데이터는 받지 못 한 것을 알 수 있다. 이것이 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hot Observable&lt;/code&gt;의 개념이다.&lt;/p&gt;

&lt;p&gt;결국 &lt;code class=&quot;highlighter-rouge&quot;&gt;hot observable&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;cold observable&lt;/code&gt;의 차이는 구독 한 시점에 다시 새로운 데이터를 받아오느냐, 이미 지나간 데이터는 받아오지 못하고 중간에 흐름에 껴서 받아오느냐의 차이이다.&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/hot-cold-observable</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/hot-cold-observable</guid>
        
        
        <category>RxKotlin</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 네비게이션 메뉴에 적용한 BehaviorProcessor의 Flowable 🔀</title>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RxKotlin&lt;/code&gt;을 계속 공부하다보니 항상 Rx의 메커니즘을 어떻게 안드로이드에 적용 시킬지 고민하며 프로젝트를 진행하는 것 같다.
답은 명확한데 답을 찾아내기까지 정말 많은 시간이 걸렸던 부분 중 하나이다. 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;0️⃣-behaviorprocessor-behaviorsubject&quot;&gt;0️⃣ BehaviorProcessor? BehaviorSubject?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt;를 다루기 전에, &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorSubject&lt;/code&gt;라는 형식을 많이 들어 보았을 것이다.
이 둘의 차이점은 매우 단순했다.. 반환하는 형식이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;인지와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;인지의 차이다.
간략하게 설명하자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;BackPressure&lt;/code&gt;를 default로 가지고 있는지와 없는지로 구분되는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;BackPressure&lt;/code&gt;를 기본적으로 가지고 있는 녀석이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;은 다른 방식으로 구현을 해 주어야 한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable&lt;/code&gt;의 차이는 아래 글에서 확인 하도록 하자.&amp;lt;/br&amp;gt;
&lt;a href=&quot;2021-09-15-flowable-observable.md&quot;&gt;Flowable과 Observable의 차이&lt;/a&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;을 반환 해 준다는 것을 알았다. 그럼 이렇게 반환되는 흐름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe&lt;/code&gt; 함으로써 제어를 할 수 있을 것이다.
하지만 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;flow&lt;/code&gt;에 값을 넘겨주고 꺼내 쓸 수 있어야 하는데 어떤식으로 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;flow&lt;/code&gt;에 넣어주고 넣어준 값에 따라 흐름을 제어할 수 있는지 알아보자.
이를 알기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt; 클래스의 내부를 들여다 봐야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt; 타입으로 만들어진 변수명에 .을 찍어보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;라는 형식을 찾을 수 있다.
&lt;img src=&quot;/img/09-14-android/behavior-processor-value-01.png&quot; alt=&quot;value&quot; /&gt;
이 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;라는 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt; 클래스 내부에서 다음과 같은 전역변수로 선언되어있다.
&lt;img src=&quot;/img/09-14-android/behavior-processor-value-02.png&quot; alt=&quot;value&quot; /&gt;
이렇게 선언되어있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;는 또 클래스 내부에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;setCurrent&lt;/code&gt;라는 메서드가 호출될 때 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;lazy&lt;/code&gt;하게 초기화되고,
&lt;img src=&quot;/img/09-14-android/behavior-processor-value-03.png&quot; alt=&quot;value&quot; /&gt;
이 &lt;code class=&quot;highlighter-rouge&quot;&gt;setCurrent&lt;/code&gt; 메서드는 offer가 호출될 때 불려지게 된다.
&lt;img src=&quot;/img/09-14-android/behavior-processor-value-04.png&quot; alt=&quot;value&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;라고..? 맞다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;에서 값을 배출시키는 바로 그 익숙한 연산자이다. 결국 결론적으로는, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;라는 변수는 타고 타고 타서 우리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;의 데이터들을 배출하기 시작할 때 그 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Parameter&lt;/code&gt;로 전달되는 것이다..!&lt;/p&gt;

&lt;p&gt;다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribable&lt;/code&gt;이라는 flow를 외부에서 접근할 수 있게 해 주는 선언이 있다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;behaviorProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BehaviorProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BehaviorProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// createDefault는 말 그대로 초기 값 세팅.. null 값이 올 수 없기 때문..
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;subscribable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flowable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behaviorProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distinctUntilChanged&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 변수를 가진 클래스 내에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;behaviorProcessor&lt;/code&gt;라는 변수로 접근 할 것이고, 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;은 외부에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribable&lt;/code&gt;이라는 변수명으로 접근을 하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt;을 제어 할 것이다. 결국 &lt;code class=&quot;highlighter-rouge&quot;&gt;Flowable&lt;/code&gt; 형태로 &lt;code class=&quot;highlighter-rouge&quot;&gt;BehaviorProcessor&lt;/code&gt;를 받는 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribable&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;하고, 그 &lt;code class=&quot;highlighter-rouge&quot;&gt;flow&lt;/code&gt;를 구독하는 녀석들에게 제어권이 넘어가게 된다.&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-안드로이드에서는-어떻게-적용-해-볼까&quot;&gt;1️⃣ 안드로이드에서는 어떻게 적용 해 볼까..?&lt;/h2&gt;
&lt;p&gt;간단한 로직을 구현 해 보았다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;navigateToDogFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;behaviorProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 함수는 바로 위 코드 블럭에서 사용했던 &lt;code class=&quot;highlighter-rouge&quot;&gt;behaviorProcessor&lt;/code&gt;를 사용한다. 보이는 그대로 이 함수가 어딘가로 호출될 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAT 프래그먼트&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;DOG 프래그먼트&lt;/code&gt;로 화면의 전환이 일어나게 구현 해 볼 것이다. 다음을 살펴봅시다!&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 뷰 단에서 호출되는 함수들 구현
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bindViewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribable&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeOnMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribeWithErrorLogger&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;navigate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addToDisposables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;navigate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fragment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DOG&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DogFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LION&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LionFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;currentFragment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;supportFragmentManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;primaryNavigationFragment&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFragment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;javaClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;javaClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;supportFragmentManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beginTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;// add를 쓰게 되면 덮어진 View가 파괴되지 않아 클릭되는 등 버그를 발생 시키므로 replace 사용
&lt;/span&gt;           &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setPrimaryNavigationFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addToBackStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;javaClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;simpleName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;함수 두 개를 구현 해 놓았다. &lt;code class=&quot;highlighter-rouge&quot;&gt;navigate()&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindViewModels()&lt;/code&gt; 함수에서 IO 스레드 내에서 구독이 되고 있고, 위에서 구현했던 &lt;code class=&quot;highlighter-rouge&quot;&gt;navigateToDogFragment()&lt;/code&gt;가 어떠한 뷰나 액티비티 또는 프래그먼트로 호출됐을 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dog&lt;/code&gt;라는 이름의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Enum&lt;/code&gt; 값이 전달 되면서 값을 방출시킬 것이고 이 방출된 값 즉 DOG라는 이름은 뷰 부분의 &lt;code class=&quot;highlighter-rouge&quot;&gt;bindViewModels()&lt;/code&gt; 함수 안에 구독처리가 되어 &lt;code class=&quot;highlighter-rouge&quot;&gt;it&lt;/code&gt;의 값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;navigate()&lt;/code&gt; 함수의 인자를 결정짓게 되는 것이다. 그럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;navigate()&lt;/code&gt; 함수는 이 배출된 DOG라는 값을 받아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;DogFragment()&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;fragment&lt;/code&gt; 변수에 넣어 줄 것이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;supportFragmentManager&lt;/code&gt;를 통하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;navigation&lt;/code&gt;이 일어나게 된다.&lt;/p&gt;

&lt;p&gt;정말 어렵고 복잡하다.. 안드로이드 고수가 되는 그날까지 최선을 다해보자..!&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/behavior-processor</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/behavior-processor</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 안드로이드 버전이 뭐예요?(targetSdkVersion, compileSdkVersion, API 레벨)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=110015332&quot;&gt;책 - 안드로이드 프로그래밍 Next Step&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/uses-sdk-element&quot;&gt;Android Developers 사이트 - API 레벨이란?&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/practices/compatibility?hl=ko#Versions&quot;&gt;Android Developers 사이트 - &amp;lt;uses-sdk&amp;gt;&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/basics/supporting-devices/platforms?hl=ko&quot;&gt;Android Developers 사이트 - 다양한 플랫폼 버전 지원&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/distribute/best-practices/develop/target-sdk?hl=ko#why-target&quot;&gt;Android Developers 사이트 - 최신 SDK를 타겟팅해야 하는 이유&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;기억 상 중학교 1학년 시절부터 스마트폰을 썼던 것 같습니다.. 갤럭시 노트 1이 처음 나왔을 때 큰 화면과 노트 펜을 보고 너무 가지고 싶었죠^^.. ㅋㅋㅋ 부모님을 졸라 손에 넣은 갤럭시 노트 1!! 1년 정도 쓰다가 변기통에 빠뜨려 사망하고 말았습니다..&lt;/p&gt;

&lt;p&gt;그 때 갤럭시 노트 1에 탑재된 안드로이드 운영체제 버전이 아마 진저브레드였던 것 같습니다.&lt;/p&gt;

&lt;p&gt;안드로이드 운영체제가 탑재된 모바일 디바이스를 사용하다보면 몇 년에 한 번씩 안드로이드 운영체제 버전이 업그레이드 되어 업데이트하면 더 세련된 화면들로 바뀌는 현상을 경험했을 것입니다.&lt;/p&gt;

&lt;p&gt;이번 포스팅에서는 ‘안드로이드 버전’과 관련된 내용을 공부해보겠습니다! 포스팅 내용에 잘못된 개념이나 잘못된 사용법이 작성되어 있다면 댓글로 알려주세요🧚🏻‍♀️&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-what-is-안드로이드-버전&quot;&gt;1️⃣ What is 안드로이드 버전?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android에도 Version이 있다?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;826&quot; alt=&quot;01&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111580326-ac773780-87fa-11eb-8367-27e5890b38fa.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;a href=&quot;https://developer.android.com/about?hl=ko&quot;&gt;Android Developers 사이트의 플랫폼 개요&lt;/a&gt;만 들어가도 최신 Android Version에 대해 소개하고 홍보하는 글을 볼 수 있습니다. 2021년 3월 기준 최신 버전은 Android 11 이네요!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;200&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111580561-12fc5580-87fb-11eb-987e-b31e21092e0c.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;a href=&quot;https://developer.android.com/about/versions/11?hl=ko&quot;&gt;Android Developers 사이트의 플랫폼 출시&lt;/a&gt;에서 볼 수 있는 버전 리스트를 보면 ‘롤리팝’, ‘마시멜로우’, ‘누가’, ‘오레오’, ‘파이’ 등 예전에 출시되었던 안드로이드 버전들에 대한 설명도 볼 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;앱 개발자는 앱을 처음 출시한 후 지속적으로 새로운 기능을 추가하거나 기존 기능을 개선하여 새로운 버전으로 업그레이드하는 경우가 많습니다. 따라서 해당 앱을 설치하여 사용하고 있던 사용자들은 앱이 제공하는 새로운 기능을 사용하기 위해 새로운 버전으로 업데이트하는 경우가 대부분 입니다. 안드로이드 앱만 봐도 지속적으로 새로운 버전이 등장하는 것처럼 ‘안드로이드 자체’도 새로운 기능과 개선된 기능을 포함한 NEW Version이 지속적으로 출시되고 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, 안드로이드 운영체제는 계속해서 발전해가고 있다는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android Version을 한 눈에 볼 수 있는 표&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;946&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111586467-37a8fb00-8804-11eb-8c7f-f9273767561e.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels&quot;&gt;출처 : Android Devlopers 사이트&lt;/a&gt;) 위 표는 안드로이드의 버전을 최신순부터 쭉~ 한 눈에 정리해놓은 표입니다. 앞으로 새로운 안드로이드 버전이 계속 출시된다면 이 표도 계속 업데이트 될 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 표를 보면 일반 사람들에게 익숙한 ‘롤리팝(LOLLIPOP)’, ‘젤리빈(JELLY_BEAN)’, ‘아이스크림 샌드위치(ICE_CREAEM_SANDWICH)’ 등의 이름들이 &lt;strong&gt;버전 코드(Version Code)&lt;/strong&gt; 라는 항목에 작성되어 있습니다. &lt;strong&gt;버전 코드라는 것은 숫자로 표시된 버전명을 문자열로 바꾸어 나타낸 것&lt;/strong&gt; 입니다. 예를 들어, 안드로이드 버전 ‘5.0’를 ‘LOLLIPOP’이라는 문자열로 바꾸어 부르는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 표를 보면 버전 코드 외에도 &lt;strong&gt;플랫폼 버전&lt;/strong&gt; 과 &lt;strong&gt;API 레벨&lt;/strong&gt; 이라는 항목이 있습니다. 심지어 하나의 API 레벨에 여러 개의 플랫폼 버전이 존재하기도 합니다. 예를 들어, 위 표를 보면 API 레벨 14에 해당하는 플랫폼 버전은 android 4.0, android 4.0.1, android 4.0.2 3개가 존재합니다. ‘플랫폼’ 이라는 것에 대해서는 &lt;a href=&quot;https://choheeis.github.io/newblog//articles/2021-03/android&quot;&gt;이 블로그의 다른 포스팅 - 안드로이드가 뭐예요?&lt;/a&gt;에서 설명하고 있습니다. 이 포스팅을 보고 온다면 ‘플랫폼’이 ‘안드로이드’를 말하는 것이며 동시에 ‘안드로이드 플랫폼’을 말하고 있음을 알 수 있을 것입니다. 따라서 ‘플랫폼 버전’은 ‘안드로이드 버전’을 나타냅니다. 플랫폼 버전 중 android 4.0 버전을 보면 처음엔 android 4.0이 출시되었다가 조금 더 개선하여 android 4.0.1 으로 버전 업그레이드를 했고, 마지막으로 android 4.0.2로 추가 업그레이드된 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 또 안드로이드는 각 플랫폼 버전에 대응되는 &lt;strong&gt;플랫폼 명(안드로이드 버전 명)&lt;/strong&gt; 을 만들어 일반 사람들에게 쉽게 안드로이드 버전을 소개합니다. 그러나 이러한 플랫폼 명과 API 레벨, 플랫폼 버전 등이 일대일 매칭이 되지 않아 혼동되는 경우가 많습니다. 혼동될 경우 위 표를 봅시다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;안드로이드 버전 별로 등장한 새로운 기능 및 개선된 기능을 자세히 알아보고 싶다면 &lt;a href=&quot;https://developer.android.com/about/versions?hl=ko&quot;&gt;여기&lt;/a&gt; 를 참고하면 됩니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-what-is-api-레벨&quot;&gt;2️⃣ What is API 레벨?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;API 레벨(API LEVEL)이 무엇인가?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;안드로이드 버전의 역사를 볼 수 있었던 위 표에는 ‘API 레벨’ 이라는 항목이 있었습니다. API 레벨은 가장 초창기 안드로이드 플랫폼 버전인 android 1.0 부터 가장 최신 안드로이드 플랫폼 버전까지 1부터 1씩 증가했음을 알 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;API 레벨&lt;/strong&gt; 은 Android 플랫폼 버전이 업데이트 될 때마다 수정되는 &lt;strong&gt;Android Framework(안드로이드 프레임워크)의 수정 버전을 고유하게 식별해주는 정수 값&lt;/strong&gt; 입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, Android 버전이 업데이트는 Android Framework 업데이트도 포함할 수 있기 때문에 Android Framework의 수정 히스토리를 Android 버전과 별도로 표시하는 것이 API 레벨입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;946&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111586467-37a8fb00-8804-11eb-8c7f-f9273767561e.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 표를 보면 Android 플랫폼 최초 출시 버전인 android 1.0 버전은 API Level 1을 제공했음을 알 수 있습니다. android 1.0 버전부터 계속 후속 릴리즈 버전이 나오면서 API 레벨도 1씩 증가했습니다. 또한 각 Android 플랫폼 버전별로 지원하는 API 레벨이 지정되어 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-android-앱-개발-시-앱이-어떤-안드로이드-버전에서-동작할-것인지-지정해야-한다&quot;&gt;3️⃣ Android 앱 개발 시 앱이 어떤 안드로이드 버전에서 동작할 것인지 지정해야 한다!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android 앱 개발 시 앱이 어떤 안드로이드 버전(플랫폼 버전)에서 동작할 것인지 지정해줘야 하는 이유?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;위에서 알아본 것처럼 안드로이드는 시간이 지날수록 새로운 기능과 개선된 기능이 추가되어 업데이트되고 발전해갑니다. 이러한 특징 때문에 개발자가 앱 개발 시 사용한 API 레벨이 모든 앱에서 동일하다는 보장이 없습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;한 가지 예를 들어봅시다. 예를 들어, 달력 기능과 관련된 API인 &lt;a href=&quot;https://developer.android.com/guide/topics/providers/calendar-provider?hl=ko&quot;&gt;CalendarProvider&lt;/a&gt; API는 android 4.0(API 레벨 14)버전이 출시될 때 새로 나온 API 입니다. 만약 내가 만든 앱이 달력 관련 기능을 제공하기 위해 CalendarProvider API를 사용했다면 이 앱은 android 4.0 이후 버전이 설치된 디바이스 기기에서만 설치되도록 해야 합니다. 만약 android 4.0 이전 버전이 설치된 디바이스에서 내가 만든 앱을 설치하여 실행한 경우, android 4.0 이전에는 CalendarProvider API가 존재하지 않기 때문에 앱이 정상적으로 실행되지 않을 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 문제에 대응하기 위해 안드로이드 프로젝트의 build.gradle 파일에 존재하는 minSdkVersion(최소 Sdk 버전)이라는 설정의 값을 14(API 레벨)로 지정해줘야 합니다. 이는 이 앱을 실행하려면 디바이스 기기에 최소한 API 레벨 14는 설치되어 있어야 함을 의미합니다. 다른 말로는, 이 앱이 API 레벨 14가 존재하는 디바이스 기기까지와는 &lt;strong&gt;호환&lt;/strong&gt; 된다고 말할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android 플랫폼의 버전이 계속 발전하고 있는 상황에서 &lt;strong&gt;앱 호환성&lt;/strong&gt; 이라는 것은 중요한 요소가 되었습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;앱 호환성이란?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112323966-9d5e2100-8cf5-11eb-8dcc-225f0fd2d43b.png&quot; alt=&quot;05&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/11?hl=ko&quot;&gt;출처&lt;/a&gt;) Android에서 말하는 &lt;strong&gt;앱 호환성은 앱이 Android 플랫폼 버전의 특정 버전에서 올바르게 실행되는 것&lt;/strong&gt; 을 말합니다. 새로운 Android 플랫폼 버전이 출시되었다는 것은 이전 버전에 비해 개선된 사항들이 새 버전에 추가되었다는 것입니다. 위 그림에서 볼 수 있듯이, 새 버전에는 ‘개인 정보 보호’와 ‘보안 향상’에 관련된 변경 사항이 추가될 수도 있고, Android 운영체제 전반에 걸쳐 사용자 환경을 개선하는 변경 사항이 추가될 수도 있습니다. 또 아예 기존에 없었던 새로운 기능이 추가될 수도 있습니다. 이러한 변경 사항은 앱에 영향을 줄 수 있습니다. 따라서 새로운 Android 플랫폼 버전이 출시되면 개발자는 출시 버전에 포함된 변경 사항을 살펴보고 해당 버전에서 앱이 잘 동작하는지 테스트한 다음, 사용자를 위해 호환성 업데이트를 하는 것이 중요합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또한 일반적으로 Android 플랫폼 버전이 새로 출시되면 사용자들은 이에 관심과 흥미를 가지고 자신의 기기에 Android 플랫폼을 업데이트하는 경우가 많습니다. 또 새 변경 사항을 자신이 사용하는 앱에서 경험해 보고 싶어 합니다. 사용자의 이러한 특성을 파악하고 개발자는 Android 플랫폼 버전이 새로 출시되면 앱이 새 버전에서 비정상적으로 동작하는 부분은 없는지 테스트하는 것이 좋습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;915&quot; alt=&quot;06&quot; src=&quot;https://user-images.githubusercontent.com/31889335/112324373-12315b00-8cf6-11eb-8812-5fbdfc4e9e21.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/12?hl=ko&quot;&gt;출처&lt;/a&gt;) 따라서 Google은 Android 플랫폼 최신 버전이 공식적으로 출시되기 전에 개발자 프리뷰(preview) 및 베터 버전을 먼저 출시하여 개발자들에게 테스트 기간을 주고 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;minSdkVersion 지정하기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;minSdkVersion은 &lt;strong&gt;앱을 실행하려면 필요한 최소 API 레벨&lt;/strong&gt; 을 의미합니다. 즉, ‘이 앱을 실행하려는 디바이스 기기에는 최소한 몇 API 레벨을 제공하는 Android 플랫폼 버전이 설치되어 있어야 한다’ 라는 의미입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만약 어떤 디바이스 기기에서 A라는 앱을 설치하려고 하는 상황을 가정해봅시다. 만약 이 디바이스 기기의 Android 플랫폼 버전이 A앱에 설정된 minSdkVersion보다 낮은 버전의 API 레벨을 제공한다면 Android 시스템은 자동으로 앱 설치를 방지합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minSdkVersion은 항상 지정해줘야 합니다. 만약 이 설정을 지정해주지 않을 경우 기본 값으로 API 레벨 1이 minSdkVersion으로 지정됩니다. API 레벨 1이 설정되었다는 것은 해당 앱이 모든 Android 버전과 호환된다는 의미입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만약 API 레벨 14부터 지원하는 CalendarProvider API를 사용한 앱의 minSdkVersion이 1일 경우(=minSdkVersion을 지정하지 않았을 경우) 해당 앱은 런타임 시 작동이 중단될 수 있습니다. API 레벨 14를 지원하지 않는 디바이스 기기에서도 이 앱을 설치할 수 있지만 정상적인 앱 작동에 필수인 CalendarProvider API를 제공하지 않기 때문입니다. 이렇게 minSdkVersion이 적절하지 않게 설정되면 앱이 중단될 수 있기 때문에 앱에 사용한 API 레벨을 고려하여 적절한 minSdkVersion을 지정해줘야 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;앱의 minSdkVersion을 설정할 수 있게 된 것은 API 레벨 4 이후였습니다.(애초에 minSdkVersion이라는 기능이 API 레벨 4 때 처음 추가되었기 때문)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;일반적인 Android 앱은 Android 플랫폼의 신규 버전과 호환된다!&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 Android 플랫폼 버전이 출시되면 Android Framework API에 관한 변경도 존재할 수 있습니다. 하지만 신규 Android 플랫폼 버전에 포함된 API 변경 사항은 이전 버전의 API를 Android Framework에서 완전히 삭제한 후 그것을 대체하는 것이 아닙니다. 이전 버전이 제공하는 API는 그대로 두고 거기에 추가로 새로운 API도 제공되는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;따라서 이미 이전 API 레벨을 사용하여 개발된 Android 앱이 최신 Android 플랫폼 버전을 설치한 디바이스 기기(최신 API 레벨을 제공)에서 실행된다고 하더라도 앱 실행에 있어서 문제가 되지 않습니다. 왜냐하면 최신 API 레벨은 바로 이전 API 레벨이 제공하는 API도 제공하고, 새롭게 추가된 API도 제공하기 때문입니다.  &lt;strong&gt;즉, 어떠한 이유나 이슈 발생으로  Android Framework에서 완전히 삭제된 API를 사용한 앱이 아니라면, 일반적인 Android 앱은 Android 플랫폼의 이후 버전 및 상위 API 레벨과 호환됩니다.&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;추가로 예를 들어 보자면, 사용자가 API 레벨 29를 사용하여 개발된 Android 앱을 설치하여 잘 사용하고 있었습니다. 그런데 API 레벨 30을 제공하는 새로운 Android 플랫폼 버전이 등장하여 이 사용자는 디바이스 기기에 설치된 Android 플랫폼 버전을 업데이트 설치했습니다. 이러한 경우는 어떻게 되는 걸까요? Android 플랫폼 업데이트가 정상적으로 설치되면 이 앱은 API 레벨 29와 새 시스템 기능을 가진 환경의 새로운 런타임 버전에서 실행됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112164521-4a229a80-8c31-11eb-8264-c90e479d30ef.png&quot; alt=&quot;04&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 사진 참고) 하지만 위에서 설명한 CalendarProvider API 예시처럼, 경우에 따라서는 어떤 Android 플랫폼 버전에서는 앱이 잘 동작하는데 어떤 Android 플랫폼 버전에서는 앱이 잘 동작하지 않는 경우가 있을 수 있습니다. 이러한 문제에 대응하기 위해 개발자는 다양한 Android 플랫폼에서 앱을 테스트해 볼 필요가 있습니다. 위 그림 처럼 Android SDK는 개발자가 여러 플랫폼 버전을 선택적으로 다운로드할 수 있게 제공되므로 필요한 버전을 다운로드하여 테스트해보면 됩니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;그러나 신규 API 레벨 버전을 사용한 앱을 Android 플랫폼 이전 버전에서 실행하면 100% 호환되지 않는다.&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;이전 API 레벨 버전을 사용하여 개발된 앱을 새로운 Android 플랫폼에서 실행시키는 것은 문제가 되지 않는다고 위에서 설명했습니다. 그러나 반대로 신규 API 레벨 버전을 사용한 앱을 이전 Android 플랫폼에서 실행시킬 경우, 이전 플랫폼은 신규 API를 제공하지 않기 때문에 앱이 제대로 동작하지 않을 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;디바이스 기기에 설치된 Android 플랫폼을 최신 버전으로 업데이트한 후에는 이전 플랫폼 버전으로 다운 그레이드될 가능성이 없습니다. 하지만 개발자는 항상 최신 버전으로 업데이트하지 않은 기기가 있을 수 있다는 인식을 해야 합니다.(실제로 제 주변 지인도 귀찮아서 Android 플랫폼 버전을 두 개 버전이 새로 출시될 동안 업데이트 안 한 사람이 있습니다^^..)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, 신규 API 레벨을 사용하여 앱을 개발한 후 배포했을 때, 이전 플랫폼 버전이 설치된 기기에서는 제대로 동작하지 않을 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;새로운 Android 플랫폼 버전이 출시되었을 때, 앱에 영향을 주는 변경 사항의 두 가지 유형&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 Android 플랫폼 버전이 출시되면 반드시 이전 버전보다 개선된 사항들이 존재합니다.(‘개선된 사항’이라는 단어를 앞으로 ‘변경 사항’이라고 언급하겠습니다)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 Android 플랫폼 버전이 제공하는 변경 사항의 유형은 두 가지로 나뉩니다. &lt;strong&gt;모든 앱에 적용되는 변경 사항&lt;/strong&gt; 과 &lt;strong&gt;타겟팅된 앱에 적용되는 변경 사항&lt;/strong&gt; 으로 나뉩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112330622-8c181300-8cfb-11eb-90cf-f4d9f1d9b5f0.png&quot; alt=&quot;07&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/11/behavior-changes-all?hl=ko&quot;&gt;출처&lt;/a&gt;) 위 그림은 2021년 3월 기준 가장 최신 Android 플랫폼 버전인 11 에서 제공하는 변경 사항 중 ‘모든 앱’에 적용되는 변경 사항을 소개하는 글입니다. 즉, Android 11이 설치된 디바이스 기기에서 실행되는 모든 앱에 적용되는 변경 사항인 것입니다. 그림의 출처 사이트에 접속해보면 어떤 변경 사항들이 ‘모든 앱’에 적용되는 변경 사항인지 알 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;위 그림의 내용에서 빨간색 박스 부분을 보면 ‘targetSdkVersion에 관계없이’라는 말이 있습니다. 아직 targetSdkVersion이라는 것이 무엇인지 설명하지는 않았지만 분홍색 박스 부분을 추가로 봐봅시다. ‘Android 11을 타겟팅하는 앱에만 영향을 주는 변경 사항을 검토해야 한다’는 말이 적혀있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;파란색 박스 부분과 분홍색 박스 부분을 통해 대충 유추해보자면.. 특정 Android 플랫폼 버전을 타겟팅하는 앱이 존재하는 것 같고, targetSdkVersion이라는 설정으로 타겟팅할 버전을 지정하는 것 같죠? &amp;gt;.&amp;lt; (targetSdkVersion에 대해서는 조금 아래에서 설명할 예정입니다)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112331866-a43c6200-8cfc-11eb-83bb-3b8808778266.png&quot; alt=&quot;08&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/11/behavior-changes-11?hl=ko&quot;&gt;출처&lt;/a&gt;) 위 그림의 내용에서 파란색 박스 부분을 보면 Android 11 이상을 타겟팅하는 앱에만 적용되는 변경 사항들이 존재한다는 것을 알 수 있습니다. 또 Android 11을 타겟팅하는 앱은 targetSdkVersion라는 것을 30으로 설정한 앱이라는 것도 알 수 있습니다. 만약 내가 개발한 앱의 targetSdkVersion을 30으로 설정했다면 이 앱이 Android 11에서 변경된 사항들을 반영하도록 수정해야 합니다.(Android 플랫폼 버전 11이 제공하는 API 레벨은 30입니다)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이처럼 새로운 Android 플랫폼 버전이 제공하는 변경 사항의 유형은 ‘모든 앱에 적용되는 변경 사항’ 과 ‘타겟팅된 앱에 적용되는 변경 사항’으로 두 가지 유형이 존재한다는 것을 알 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;targetSdkVersion 지정하기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;targetSdkVersion은 &lt;strong&gt;앱의 타겟 API 레벨&lt;/strong&gt; 을 지정하는 정수입니다. ‘타겟’이라는 말의 의미처럼 해당 앱이 타겟으로 하고 있는 API 레벨이라는 뜻입니다. 만약 targetSdkVersion이 30로 지정되어 있으면 개발자는 API 레벨 30이 제공되는 환경에서 해당 앱 테스트를 완료했고 앱을 실행하는데 문제가 없다는 의미입니다. 즉, &lt;a href=&quot;https://mrgamza.tistory.com/615&quot;&gt;이 블로그&lt;/a&gt;의 말을 인용하자면 “우리가 최종적으로 호환성을 맞춘 버전이 이 버전이다.” 라고 선언하는 것이 targetSdkVersion 입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;정리 )&lt;/strong&gt; minSdkVersion은 앱이 호환되는 가장 낮은 API 레벨을 말하고, targetSdkVersion은 앱을 개발하고 테스트한 가장 높은 API 레벨을 말합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만약 targetSdkVersion을 설정하지 않을 경우 minSdkVersion과 동일한 값으로 설정됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;신규 Android 플랫폼 버전이 제공하는 변경 사항 중 ‘타겟팅된 앱에만 적용되는 변경 사항’이 있다는 것을 위에서 언급했습니다. 이러한 변경 사항은 targetSdkVersion에 설정된 값을 보고 변경 사항을 적용할지 말지 결정됩니다.&lt;/p&gt;
        &lt;blockquote&gt;
          &lt;p&gt;이 위에서부터 다시 하자. 호환성 프레임워크 도구 부터 읽자.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;minsdkversion 어디서 작성하는지 , Android 11과 앱의 호환성 테스트(새로운 기능 출시됨)
https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels
https://developer.android.com/training/basics/supporting-devices/platforms?hl=ko
https://developer.android.com/distribute/best-practices/develop/target-sdk?hl=ko
https://developer.android.com/about/versions/11/test-changes?hl=ko#list
https://developer.android.com/guide/app-compatibility/test-debug?hl=ko
https://developer.android.com/guide/app-compatibility?hl=ko
얘네 참고 문서에 없는 것 추가하기&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;안드로이드 앱을 조회할 수 있고 설치할 수 있도록 해주는 &lt;a href=&quot;https://play.google.com/store?utm_source=apac_med&amp;amp;utm_medium=hasem&amp;amp;utm_content=Jan0421&amp;amp;utm_campaign=Evergreen&amp;amp;pcampaignid=MKT-EDR-apac-kr-1003227-med-hasem-py-Evergreen-Jan0421-Text_Search_BKWS-BKWS%7cONSEM_kwid_43700058439438031_creativeid_477136209046_device_c&amp;amp;gclid=CjwKCAjw9MuCBhBUEiwAbDZ-7oqhHVcoSbCI_MqISe9w1YogduL5vR2-m_9-9tKDaEleYvQBQKuBwBoCfx8QAvD_BwE&amp;amp;gclsrc=aw.ds&quot;&gt;Google Play&lt;/a&gt;에는 &lt;a href=&quot;https://developer.android.com/google/play/filters&quot;&gt;Google Play 필터&lt;/a&gt; 라는 기능이 적용되어 있습니다. Google Play는 Google Play Store에 업로드된 모든 앱의 minSdkVersion과 targetSdkVersion을 확인하여 각 앱이 요구하는 Android 버전을 파악합니다. 앱이 요구하는 버전과 맞지 않는 디바이스 기기를 가진 사용자가 Google Play Store를 실행하여 앱을 조회할 경우, Google Play는 해당 앱을 앱 리스트에 아예 표시하지 않습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/android-version</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/android-version</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[RxKotlin] RxKotlin 연산자 02</title>
        <description>&lt;h1 id=&quot;take-함수&quot;&gt;take 함수&lt;/h1&gt;
&lt;p&gt;take 연산자는 take 연산자 괄호 내에 지정된 갯수 만큼의 값을 발행한다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;~~~&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와같이 인자로 3이 들어가있다면 interval로 계속해서 값을 발행하더라도 최초 발행한 3개의 값만 발행시킨다.&lt;/p&gt;

&lt;h1 id=&quot;map-연산자&quot;&gt;map 연산자&lt;/h1&gt;
&lt;p&gt;map() 함수는 어떠한 입력 값을 함수에 넣어서 원하는 값으로 변환시키는 함수이다.
String을 String, Integer, 다른 객체 등으로 변환 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@CheckReturnValue&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//반환값을 확인하다는 의미
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@SchedulerSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//스케줄러를 지원하지 않는다는 의미로 현재 스레드에서 실행
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OBservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 BaseCode를 살펴보면 Function 인터페이스를 통해 값이 T로 들어오면 R이라는 결과로 반환 해 주는 것을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과 : 10 20 30 40 50
이처럼 기존에 생성되었던 배열이 10씩 곱해진 값으로 변환되어 배출 된 것을 알 수 있다.
조금 더 자세한 예시를 살펴보자면&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 숫자 자료형을 가공된 문자열 형태로 변환시키는 map 함수
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Transforming Int to String $number&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 위에서 변형된 형태의 자료들을 print해준다
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 즉 items가 각각의 &quot;Transforming ~~~&quot; 형태의 문자열을 가지게 된다
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Recived $Item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;출력결과&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Received Transforming Int to String 10&lt;br /&gt;
Received Transforming Int to String 9&lt;br /&gt;
Received Transforming Int to String 8&lt;br /&gt;
Received Transforming Int to String 7&lt;br /&gt;
Received Transforming Int to String 6&lt;br /&gt;
Received Transforming Int to String 5&lt;br /&gt;
Received Transforming Int to String 4&lt;br /&gt;
Received Transforming Int to String 3&lt;br /&gt;
Received Transforming Int to String 2&lt;br /&gt;
Received Transforming Int to String 1&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;flatmap-연산자&quot;&gt;flatmap 연산자&lt;/h1&gt;
&lt;p&gt;위에서 map이 가공된 향태의 String, Int 형식을 제공 해 주었다면, flatmap 함수는 이러한 자료형들을 Observable 형태로 제공 해 준다.
map은 각 배출을 가져와서 변환하지만 flatMap 연산자는 새로운 프로듀서를 만들고 원천 프로듀서에 전달한 함수를 각 배출에 적용한다.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Transforming Int to String $number&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Recived $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 놓고 봤을 때는 map 연산자와 거의 동일한 출력 결과를 볼 수 있다. 하지만 비슷하긴 해도 적용된 로직에는 차이가 존재한다. 단순히 문자열 형태라 아니라 문자열 형태의 옵저버블을 반환해준다.
이 예제에서는 장점이 잘 보이지 않지만 단일 배출에서 한번에 여러 아이템을 가져와야 하는 경우에는 이야기가 달라진다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The number $number&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The number/2 ${number/2}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The number%2 ${number%2}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribeBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Recieved $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;onComplete&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Complete&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;출력결과&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Recieved The number 10&lt;br /&gt;
Recieved The number/2 5&lt;br /&gt;
Recieved The number%2 0&lt;br /&gt;
…&lt;br /&gt;
…&lt;br /&gt;
Recieved The number 1&lt;br /&gt;
Recieved The number/2 0&lt;br /&gt;
Recieved The number%2 1&lt;br /&gt;
Complete&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;flatmap 연산자 안에 Observable 형태의 또 다른 인스턴스를 생성하고 이 인스턴스는 세 개의 문자열을 반환하게 되어있다. 
create 연산자로 3개의 문자열을 배출하도록 하고 그 후에 onComplete 알림을 보낸다.&lt;/p&gt;

&lt;p&gt;출력을 더 자세히 살펴보면 마지막에 onComplete가 불려오고, 그 전에 모든 항목들을 배출 해 준다는 것을 알 수 있다.
flatMap 연산자는 내부적으로 merge 연산자를 사용하기 때문에 먼저 여러 옵저버블들을 결합 후 내보낸다.&lt;/p&gt;

&lt;h1 id=&quot;repeat-연산자&quot;&gt;repeat 연산자&lt;/h1&gt;
&lt;p&gt;아이템을 N번 발행한다. 파라미터로 아무 값이 들어가지 않을 시 값을 무한히 발행시킨다.&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/rx-kotlin-02</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/rx-kotlin-02</guid>
        
        
        <category>RxKotlin</category>
        
      </item>
    
      <item>
        <title>[RxKotlin] RxKotlin 연산자 01</title>
        <description>&lt;p&gt;옵저버 패턴을 적용하여 구독자에게 변경사항을 알려주는 programming 기법.&lt;/p&gt;

&lt;p&gt;하나의 값 보다는 data stream을 반환한다.&lt;/p&gt;

&lt;h1 id=&quot;rxjava의-푸시-메커니즘과-풀-메커니즘-비교&quot;&gt;RxJava의 푸시 메커니즘과 풀 메커니즘 비교&lt;/h1&gt;

&lt;p&gt;RxKotlin은 프로그램에서 사용되는 반복자 패턴(Iterator)의 풀 메커니즘 대신 푸시 메커니즘의 데이터 / 이벤트 시스템으로 대표되는 옵저버블 패턴을 중심으로 작동한다.
여기서 Iterator 패턴은 아래와 같은 로직을 의미한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// iterator 방식
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;One&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Three&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Four&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Five&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;알아두어야 할 점이 데이터가 사용 준비 될 때 까지 기존 스레드는 블로킹 상태가 된다.
즉 네트워크 호출이나 데이터베이스 쿼리를 이용해서 데이터를 가져온다면 스레드가 얼마나 블로킹 돼있을지 생각 해 보자.
위와 같은 방법은 그다지 효율적이지 않은 코드라고 할 수 있겠다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;observable 함수의 종류&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onNext(item T)&lt;/code&gt; : 값을 전달할 때 호출하여 값을 넘겨준다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onError(e: Throwable)&lt;/code&gt; : 에러가 발생할 경우에 호출.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onSubscribe(d: Disposable)&lt;/code&gt; : 구독을 신청하면 호출해준다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onComplete()&lt;/code&gt; : 가지고 있는 값을 모두 전달하면 호출한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onComplete()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext() - $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError() - $e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Disposable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onSubscribe() - $d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;1-observablecreate을-이용하여-observable을-생성하는-방법&quot;&gt;1 Observable.create을 이용하여 Observable을 생성하는 방법&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observable1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observable2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onComplete()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext() - $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError() - $e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Disposable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onSubscribe() - $d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;observable1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;observable2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-observablefrom을-이용하여-observable을-생성하는-방법&quot;&gt;2 Observable.from~~~을 이용하여 Observable을 생성하는 방법&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;listOb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callOb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromCallable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;future&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isCancellable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;futureOb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromFuture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onComplete()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext() - $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError() - $e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Disposable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onSubscribe() - $d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;listOb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;callOb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;futureOb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;from 함수의 다양한 형태&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fromIterable()&lt;/code&gt; : list처럼 iterable을 지원하는 instance를 Observable 형태로 변환해준다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;각 개별 아이템이 하나씩 전달 됨.
 &lt;code class=&quot;highlighter-rouge&quot;&gt;fromCallable()&lt;/code&gt; : Callable 객체를 Observable 형태로 전달한다.&lt;/li&gt;
  &lt;li&gt;call() 함수의 return 값이 전달 된다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;fromFuture()&lt;/code&gt; : Future 객체를 Observable 형태로 변환한다.&lt;/li&gt;
  &lt;li&gt;get() 함수의 return 값이 전달된다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;from()&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt; 또는 배열의 아이템을 순차적으로 발행하는 옵저버블을 생성한다. 예를들어 Observable.from(list) list 배열이 가지고 있는 요소들을 순차적으로 발행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;3-observablejust를-이용하여-observable을-생성하는-방법&quot;&gt;3 Observable.just를 이용하여 Observable을 생성하는 방법&lt;/h1&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;){&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wow!&quot;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;one&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;two&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;justOb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onComplete()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext() - $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError() - $e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Disposable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onSubscribe() - $d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;justOb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;just는 인자로 들어온 모든 타입의 요소들을 전부 한꺼번에 반환 해 준다.
list처럼 각 인덱스 값이 따로따로 필요하다면 fromIterable()을 사용해야 한다.
즉, List 타입의 요소를 사용하려면 fromIteravle()을 사용 하라는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;range&quot;&gt;range&lt;/h1&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onComplete()&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext() - $item&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError() - $e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Disposable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onSubscribe() - $d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 range는 특정 범위 만큼 수를 생성하여 전달한다.&lt;/p&gt;

&lt;h1 id=&quot;empty&quot;&gt;empty&lt;/h1&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;empty는 어떠한 값을 전달하지는 않지만 onComplete()를 호출 해 준다. 아 물론 observer가 호출될 때 실행되는 onSubscribe() 함수가 먼저 실행된다.&lt;/p&gt;

&lt;h1 id=&quot;interval&quot;&gt;interval&lt;/h1&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 여기부터 thread 시작
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;th1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;th1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;th1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;interval은 단어 뜻 그대로 시간차 간격을 두고 다음 로직을 처리하는 연산자이다.&lt;/p&gt;

&lt;h1 id=&quot;never&quot;&gt;never&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/img/09-13-rxKotlin/never.jpg&quot; alt=&quot;never&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
아무런 아이템도 발행하지 않고, 완료도 발행하지 않는 옵저버블을 생성한다.
결과 값으로는 onNest, onComplete, onSubscribe, onError 이 중에 아무것도 실행되지 않는다.&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/rx-kotlin-01</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/rx-kotlin-01</guid>
        
        
        <category>RxKotlin</category>
        
      </item>
    
      <item>
        <title>[Algorithm] 개선된 Bubble Sort💧</title>
        <description>&lt;p&gt;학부 시절 때 부터 정렬에 대한 문제들은 정말 많이 접해보았을 것이다.&lt;br /&gt;
버블정렬과 이 버블 정렬의 시간 복잡도를 최대로 보완한 로직도 살펴보기로 하자.&lt;br /&gt;
가장 기본적인 버블정렬 알고리즘에서 파생된 알고리즘이다.&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// k를 0으로 초기화 해 주는 이유는 함수가 처음 실행될 때&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 전체를 훑으면서 마지막에 교환된 위치를 반환하여&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 범위를 좁혀줘야 하기 때문이다.&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//while : 처음 실행 한번 이후에는 k보다 큰 범위로 범위를 좁힌다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 마지막으로 교환된 위치를 저장하는 last&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// for문은 위치변경이 일어났을 때 &lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 현재 위치변경이 일어난 우측 방향으로 k값을 정한다.&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//while문의 범위를 좁혀준다.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 살펴보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;를 0으로 초기화 해 주는 이유는 함수가 처음 실행될 때 전체를 훑으면서 마지막에 교환된 위치를 반환하여 범위를 좁혀줘야 하기 때문이다. &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; 문에서는 맨 처음 한 번 실행된 이후에는 비교하고자 하는 인덱스를 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;보다 큰 범위로 범위를 좁힌다.&lt;br /&gt;
마지막으로 교환된 위치를 저장하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;last&lt;/code&gt;는 k로 넘어가게 되어 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;의 값을 증가시키는 역할을 하게 된다.&lt;br /&gt;
즉, for문은 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;보다 큰 변수를 항상 &lt;code class=&quot;highlighter-rouge&quot;&gt;last&lt;/code&gt;에 넣어주며 while문의 범위를 좁혀준다.&lt;br /&gt;
쉽게 말해, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;의 값은 정렬이 될 때 마다 오른쪽으로 이동하게 된다는 것이다.&lt;br /&gt;
&lt;br /&gt;
기존에 for문 2개를 사용했을 때는 1개의 for문 요소들을 나머지 안쪽 1개의 for문에 계속해서 넣어줬다는 것을 알 수 있다.&lt;br /&gt;
&lt;br /&gt;
for문 2개를 사용하는 일반적인 버블정렬과 비교했을 때 시간 복잡도가 보완됐다는 것을 알 수 있다.&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-09/bubble-sort</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-09/bubble-sort</guid>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>[Kotlin] 코틀린의 object 키워드 잘 알고 사용하기(feat. companion object)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/object-declarations.html&quot;&gt;Kotlin Document - Object expressions and declarations&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=KUk6k865Vgg&quot;&gt;Youtube Android Developers - Object - Kotlin Vocabulary&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. object expression VS object declaration&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. object expression이 뭐예요?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;3. object expression 더 알아보기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;#4&quot;&gt;4. object declaration가 뭐예요?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#5&quot;&gt;5. object declaration 더 알아보기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#6&quot;&gt;6. companion object가 뭐예요?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#7&quot;&gt;7. companion object 더 알아보기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/125470357-c2ffd2d5-b7a3-437b-b3ff-a7b465de7cf2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-프롤로그&quot;&gt;✍🏻 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;코틀린으로 코드를 작성하다보면(저는 안드로이드 앱 개발을 코틀린으로 합니다) &lt;strong&gt;object&lt;/strong&gt; 라는 키워드를 사용하게 되는 몇 가지 경우가 있다!&lt;br /&gt;
하지만 그동안 대충 구글링하여 짧은 순간 습득한 지식으로 이해한 후 사용했었는데..(으이구~) 좀 제대로 알고 사용하려는 목적으로 공부해본다..ㅎㅎ&lt;br /&gt;
(아! 그리고 object 키워드에 대해서 공부하게 된 가장 큰 목적은 companion object를 제대로 이해해보고자 시작하게 된 것이다..ㅋㅋㅋ)&lt;/p&gt;

&lt;h2 id=&quot;-object-expression-vs-object-declaration&quot;&gt;✅ object expression VS object declaration&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 사용법을 알려면 object expression 이랑 object declaration 라는 걸 구분할 수 있어야 함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 이 두 가지 모두에서 사용하기 때문&lt;/li&gt;
  &lt;li&gt;용어 한글 번역
    &lt;ul&gt;
      &lt;li&gt;object expression = 객체 표현식&lt;/li&gt;
      &lt;li&gt;object declaration = 객체 선언&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;object expression와 object declaration의 공통점
    &lt;ul&gt;
      &lt;li&gt;개발을 하다 보면 A 클래스의 모습에서 아주 살짝만 수정된 모습인 B 클래스를 작성해야 하는 경우가 있을 수 있다. 이런 경우, B 클래스를 만들면 A 클래스와 거의 비슷한 클래스를 하나 더 작성하는 꼴이 되어 비효율적이다.&lt;/li&gt;
      &lt;li&gt;B 클래스를 새로 작성하지 않고 B 클래스의 객체를 생성할 수 있을까?&lt;/li&gt;
      &lt;li&gt;코틀린은 딱 이런 상황에서 사용할 수 있도록 object expression와 object declaration라는 것을 지원함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-expression이-뭐예요&quot;&gt;✅ object expression이 뭐예요?&lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;object expression(객체 표현식)는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 사용하여 익명 클래스의 객체를 생성할 때 사용&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;익명 클래스&lt;/code&gt; = 클래스를 작성할 때 클래스 이름이 명시적으로 작성되어 있지 않은 클래스. 즉, 이름이 없는 클래스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바로 아래 코드를 보면 무슨 말인지 한 방에 이해됨&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;yourName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{
        &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LastName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Kim&quot;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FirstName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Chohee&quot;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// object expressions는 내부적으로 코틀린의 Any 클래스를 default 부모 클래스로 상속하고 있기 때문에 toString() 메소드를 오버라이딩할 수 있다!
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Your name is $LastName $FirstName&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 뒤에 나오는 코드를 보면 LastName, FirstName라는 멤버 변수가 선언되어 있고, toString()라는 멤버 메소드를 가지는 익명 클래스가 작성되어 있음&lt;/li&gt;
      &lt;li&gt;이런 식으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;익명 클래스&lt;/code&gt;를 작성하고 그 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 붙여주면 그 시점에서 해당 익명 클래스의 &lt;strong&gt;객체가 바로 생성됨&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;객체가 바로 생성된다 = 해당 클래스의 생성자 함수 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;01&quot; src=&quot;https://user-images.githubusercontent.com/31889335/125470357-c2ffd2d5-b7a3-437b-b3ff-a7b465de7cf2.png&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;(위 그림 참고) &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;익명 클래스&lt;/code&gt; 앞에 붙여줌으로써 익명 클래스의 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 작성 시점에서 바로 생성함&lt;/li&gt;
      &lt;li&gt;생성한 객체가 yourName 변수에 할당됨&lt;/li&gt;
      &lt;li&gt;위 코드의 main 함수를 실행해보면 Your name is Kim Chohee가 출력됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;object expression = &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 뒤에 익명 클래스를 선언하면 그 시점에서 바로 객체화해주는 것&lt;/li&gt;
      &lt;li&gt;이렇게 특정 코드 라인에서 익명 클래스를 작성하고 바로 객체로 만드는 경우는, 해당 익명 클래스를 프로젝트 내에서 여러번 재사용하지 않고 딱 한 번만 사용해야 하는 경우에 유용&lt;/li&gt;
      &lt;li&gt;obejct expression에서 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드는 한글 해석한 그대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;객체&lt;/code&gt; 라고 생각하기 = 키워드 작성 시점에서 바로 객체로 생성되므로!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;생각
    &lt;ul&gt;
      &lt;li&gt;왜 이름이 object expression 일까?&lt;/li&gt;
      &lt;li&gt;object expression = 객체 표현식 인 것을 떠올려보자&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어 분야에서 “표현식” = “수식” 임&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어에서 “수식” = 1+2와 같은 수식 / 함수 호출식 / 변수 이름 등 포함&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어에서 “수식” = 모양과 형태가 다를 수 있지만 모두 하나의 단일 값이 될 수 있는 것을 의미&lt;/li&gt;
      &lt;li&gt;따라서 익명 클래스를 객체화하는 행위인 object expression도 익명 클래스를 객체화하여 하나의 단일 값으로 만들 수 있기 때문에 object “expression” 라는 이름이라고 추측해 봄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-expression-더-알아보기&quot;&gt;✅ object expression 더 알아보기&lt;a id=&quot;3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;object expression은 기본적으로 &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/&quot;&gt;Any&lt;/a&gt;라는 코틀린 클래스를 상속함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Any 클래스 말고도 다른 클래스나 다른 인터페이스를 상속한 익명 클래스도 object expression로 객체화 가능&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Person 인터페이스를 상속하는 익명 클래스를 object expressions 사용해서 객체화시키기
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;yourName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LastName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;당신은&quot;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FirstName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;천재!&quot;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Person 인터페이스에 정의된 getYourName 구현
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getYourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Your name is $LastName $FirstName&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getYourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getYourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;위 코드처럼 Person 이라는 인터페이스를 하나 만듬&lt;/li&gt;
      &lt;li&gt;Person 인터페이스를 상속하는 익명 클래스를 object expressions로 객체화 가능&lt;/li&gt;
      &lt;li&gt;main 함수 실행시키면 Your name is 당신은 천재!가 출력됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드 앱 개발에서 언제 object expression를 쓰면 좋을까?
    &lt;ul&gt;
      &lt;li&gt;&lt;img width=&quot;650&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/125475693-b3260e6d-0d4f-4f2f-b50c-5703c9f40a2c.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;XXOnXXXListener() 라는 메소드를 호출할 때 많이 사용함&lt;/li&gt;
      &lt;li&gt;XXOnXXXListener() 메소드는 인자로 특정 인터페이스를 구현한 클래스의 객체를 넘겨줘야 하는 경우가 많음&lt;/li&gt;
      &lt;li&gt;위 코드에서는 View.OnClickListener라는 인터페이스를 구현한 클래스의 객체를 setOnClickListener() 메소드의 인자로 넘겨야 함&lt;/li&gt;
      &lt;li&gt;보통 이럴 때 object expressions을 사용해서(람다로 대체할 수도 있긴 하지만..) 인자로 전달해야 하는 객체를 생성&lt;/li&gt;
      &lt;li&gt;특정 인터페이스를 구현한 클래스를 더 이상 프로젝트 다른 곳에서 재사용하지 않기 때문에 익명 클래스를 만들어 구현하는 것!&lt;/li&gt;
      &lt;li&gt;예를 들어, 텍스트 뷰를 클릭한 결과로 실행되어야 하는 작업은 모든 텍스트 뷰에서 동일하지 않을 것이다. 각각 다른 텍스트 뷰의 클릭 리스너를 호출하는 순간 순간마다 각기 다른 작업을 실행하는 코드를 매번 구현해야 하기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-declaration가-뭐예요&quot;&gt;✅ object declaration가 뭐예요?&lt;a id=&quot;4&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;object declaration는 &lt;strong&gt;소프트웨어 디자인 패턴 중 &lt;a href=&quot;https://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;싱글톤 패턴&lt;/a&gt;을 만드는 작업을 할 때 사용&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;싱글톤 패턴
    &lt;ul&gt;
      &lt;li&gt;객체 지향 언어에서는 필요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;클래스&lt;/code&gt; 들을 만들어놓고 실제로 사용할 때는 클래스를 토대로 만들어지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;객체&lt;/code&gt; 라는 것을 생성해서 메모리에 할당함&lt;/li&gt;
      &lt;li&gt;이 때, 똑같은 클래스를 토대로 하여 만들어지는 객체를 이곳 저곳에서 여러번 생성한다면?
        &lt;ul&gt;
          &lt;li&gt;여러 번 생성된 객체는 모두 따로 따로 메모리 공간을 차지하게 됨&lt;/li&gt;
          &lt;li&gt;즉, 생성된 객체 수 만큼 따로 따로 메모리에 할당됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 으로 클래스를 만들어 놓으면 해당 클래스를 토대로 생성되는 객체는 여러 번 생성할 수 없음&lt;/li&gt;
      &lt;li&gt;따라서 딱 한 번만 객체로 생성되어 메모리에 할당됨&lt;/li&gt;
      &lt;li&gt;싱글톤 패턴이 적용된 클래스의 객체를 여러 곳에서 사용하더라도 이 객체는 항상 같은 메모리 주소를 바라봄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스 만드는 기존 방법(자바)&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 자바에서 싱글톤 패턴이 적용된 클래스 만들기&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;자바에서는 싱글톤 패턴이 적용된 클래스를 만들기 위해서 위와 같은 코드를 작성해야 했음&lt;/li&gt;
      &lt;li&gt;INSTANCE라는 static 변수를 만들어 놓고 이 변수의 값을 null 체크하는 방식&lt;/li&gt;
      &lt;li&gt;만약 INSTANCE가 null이 아니면(즉, 단 한 번이라도 객체가 생성된 적이 있으면) 기존의 생성되어 있던 객체를 반환해줌으로써 새로운 객체가 여러 번 생성되는 것을 막는 방식&lt;/li&gt;
      &lt;li&gt;하지만 이 방식은 thread-safe 하지 않았음
        &lt;ul&gt;
          &lt;li&gt;쓰레드 A에서 위 코드의 if (INSTANCE == null) 코드줄을 실행하고 있다고 해보자.&lt;/li&gt;
          &lt;li&gt;쓰레드 A가 이 코드줄을 실행할 시점에서 INSTANCE는 null 이였다고 가정&lt;/li&gt;
          &lt;li&gt;이 때 갑자기 운영체제에 의해 쓰레드 B에게 제어권이 넘어가게 되었다고 하면 쓰레드 A는 다음 코드줄을 실행하지 못하고 실행을 멈추게 된다.&lt;/li&gt;
          &lt;li&gt;즉, INSTANE = new MySingleTon(); 을 실행하지 못하고 이 줄에서 멈춤&lt;/li&gt;
          &lt;li&gt;그런데 쓰레드 B에서도 MySingleTon 클래스의 코드 실행하는 작업이 실행된다면?&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/130348819-b55a69f1-b353-47d0-89b6-95c6859f5fa7.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;즉, 두 개의 쓰레드가 동시에 MySingleTon 클래스에 접근하게 될 경우임&lt;/li&gt;
          &lt;li&gt;쓰레드 A가 멈춘 동안 쓰레드 B가 INSTANCE null 체크를 하는 순간에도 INSTANCE는 null이다.(쓰레드 A에서 new MySingleTon(); 이 실행되지 못했으므로)&lt;/li&gt;
          &lt;li&gt;쓰레드 B에서 INSTANCE = new MySingleTon(); 이 실행되어 INSTANCE에 MySingleTon 클래스의 객체가 할당됨&lt;/li&gt;
          &lt;li&gt;이 후 다시 쓰레드 A에게 제어권이 돌아오면 쓰레드 A는 실행 멈춤되었던 코드 줄을 실행하기 시작함&lt;/li&gt;
          &lt;li&gt;쓰레드 A에 의해서 INSTANCE = new MySingleTon(); 이 또 실행되어 결국 두 개의 메모리 주소에 MySingleTon 클래스의 객체가 할당됨&lt;/li&gt;
          &lt;li&gt;이는 싱글톤 패턴이 아님 (메모리에 한 번만 할당되어야 하기 때문)&lt;/li&gt;
          &lt;li&gt;thread-safe를 보장하기 위해 위 코드에 쓰레드 여러 개에서 더블 체크하는 경우를 방지하는 코드가 더 추가되게 됨&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/130349171-b3964d08-3c1b-46c9-be82-69aa6bf1ef39.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;이 외에도 여러 가지 문제를 방지하기 위한 코드가 붙여져 싱글톤 패턴 적용된 클래스를 자바로 작성하는 방법이 복잡해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자바에서 싱글톤 패턴 클래스 하나 작성하는데 긴 코드를 작성해야 했고, 싱글톤 패턴을 만들 때 마다 반복적으로 작성해야 하는 불편함 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스 만드는 쉬운 방법(코틀린)&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 코틀린에서 싱글톤 패턴이 적용된 클래스 만들기
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;코틀린에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스를 자바보다 더 쉽게 만들 수 있도록 지원해줌&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 사용하면 되고, 이러한 행위를 object decalaration라고 부름&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt; 키워드를 사용하여 클래스를 정의하는 모습과 비슷하지만 class 키워드 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 붙여서 클래스를 생성해주면 싱글톤 패턴이 적용된 클래스가 생성됨&lt;/li&gt;
      &lt;li&gt;코틀린 언어 내부적으로 이렇게 클래스 생성 시 thread-safe한 싱글톤 패턴이 되도록 처리 다 되어있음&lt;/li&gt;
      &lt;li&gt;자바보다 훨씬 간단&lt;/li&gt;
      &lt;li&gt;이렇게 클래스 작성하면 작성 시점에 바로 해당 클래스의 객체를 단 한 개 생성해놓음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;object declaration = 싱글톤 패턴 적용된 클래스 만들 때 사용하는 것&lt;/li&gt;
      &lt;li&gt;obejct declaration에서 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드는 한글 해석한 그대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;객체&lt;/code&gt; 라고 생각하기
        &lt;ul&gt;
          &lt;li&gt;òbject` 키워드를 붙여 생성한 클래스는 싱글톤 패턴이 적용된 클래스라 딱 한 번만 객체화 되기 때문&lt;/li&gt;
          &lt;li&gt;또 클래스 작성 시점에 바로 해당 클래스의 객체를 단 한 개 생성하기 때문&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;생각
    &lt;ul&gt;
      &lt;li&gt;왜 이름이 object declaration 일까?&lt;/li&gt;
      &lt;li&gt;declaration = 선언 인 것을 떠올려보자&lt;/li&gt;
      &lt;li&gt;사용법이 클래스를 “선언”하는 모습과 비슷하기 때문에 object “declaration” 이 아닐까 추측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-declaration-더-알아보기&quot;&gt;✅ object declaration 더 알아보기&lt;a id=&quot;5&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스의 객체 사용법&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 코틀린에서 MySingleTon 클래스의 객체 사용하기
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;mySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Kimchohee 출력됨
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;VS&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;// 자바에서 MySingleTon 클래스의 객체 사용하기
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Kimchohee 출력됨
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;코틀린에서 싱글톤 패턴이 적용된 클래스의 객체를 사용하기 위해서는 해당 클래스 이름 자체를 사용하면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 사용해 싱글톤 패턴이 적용된 클래스를 만들 때는 부모 클래스 상속도 가능&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SuperClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;superExample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-companion-object가-뭐예요&quot;&gt;✅ companion object가 뭐예요?&lt;a id=&quot;6&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;companion object = object declaration을 일반 클래스 내부에서 바로 작성하는 것&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;companion&lt;/code&gt; 라는 키워드를 object declaration 앞에 붙여줌&lt;/li&gt;
  &lt;li&gt;companion 한글 번역 = “동반자”&lt;/li&gt;
  &lt;li&gt;companion object = “동반자 객체”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바로 아래 코드 봐보자!&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// MySingleTon 이라는 이름 안 써도 됨
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;MyClass라는 일반 클래스 내부에서 바로 싱글톤 패턴이 적용된 MySingleTon 클래스를 작성하는 모습&lt;/li&gt;
      &lt;li&gt;companion object의 이름은 생략 가능(이름 없어도 됨)&lt;/li&gt;
      &lt;li&gt;MyClass 안에 작성된 MySingleTon 객체는 작성 시점에서 바로 객체로 생성됨&lt;/li&gt;
      &lt;li&gt;또 딱 한 번만 생성되어 메모리에 한 번만 할당됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;companion object 안에 선언된 멤버 변수/메소드 호출법&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// companion object 클래스의 이름이 있는 경우
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      
    &lt;span class=&quot;c1&quot;&gt;// companion object 클래스의 이름이 없는 경우
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;companion object 안에 선언된 변수/메소드 호출할 때는 위 코드와 같이 호출&lt;/li&gt;
      &lt;li&gt;클래스 이름 자체가 companion object로 작성한 클래스의 객체 참조자 이름으로 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-companion-object-더-알아보기&quot;&gt;✅ companion object 더 알아보기&lt;a id=&quot;7&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;companion object 사용시 주의점
    &lt;ul&gt;
      &lt;li&gt;companion object가 자바의 static처럼 보이지만 진정한 static은 아님&lt;/li&gt;
      &lt;li&gt;자바의 static 변수/메소드
        &lt;ul&gt;
          &lt;li&gt;싱글톤 패턴과 비슷한 개념&lt;/li&gt;
          &lt;li&gt;어떤 클래스의 객체 생성 시 객체가 생성되는 횟수에 상관 없이 static으로 선언된 변수/메소드는 딱 한 번만 생성되어 메모리에 한 번만 할당됨&lt;/li&gt;
          &lt;li&gt;static 변수는 컴파일 시(런타임 때가 아님) 메모리에 할당됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;companion object로 선언한 클래스는 왜 자바의 static처럼 보일까?
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;companion object&lt;/code&gt; 로 선언한 클래스는 작성 시점에서 바로 객체화되고, 단 한 번만 메모리에 할당되기 때문&lt;/li&gt;
          &lt;li&gt;static 변수와 동일하다고 생각할 수 있음&lt;/li&gt;
          &lt;li&gt;심지어 자바로 작성된 static 변수를 코틀린 언어으로 변환시키면 companion object 안에 static으로 선언했던 변수들이 선언되어 있는 모습으로 바뀜&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하지만 companion object와 자바의 static 변수/메소드는 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 static 변수/메소드 예시&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// static 변수&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      
    &lt;span class=&quot;c1&quot;&gt;// static 메소드&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;companion object의 실체&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 멤버 변수
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
          
        &lt;span class=&quot;c1&quot;&gt;// 멤버 메소드
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;MyClass라는 일반 클래스 내부에 Counter라는 이름의 companion object가 선언되어 있다고 가정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위 companion object를 자바로 변환하면 아래와 같음&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Counter 클래스 생성&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// inner class로 작성되는 Counter 클래스&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 첫 번째, 생성자 함수 = private&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
          
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;c1&quot;&gt;// 두 번째 생성자 함수 = public&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultConstructorMarker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// = Counter();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;companion object로 선언된 Counter 클래스는 자바에서는 사실 MyClass의 inner class로 작성됨&lt;/li&gt;
      &lt;li&gt;inner class = 클래스 내에 또 클래스가 작성되는 것&lt;/li&gt;
      &lt;li&gt;Counter 클래스의 생성자 함수가 private과 public 두 가지로 생성되어 있음&lt;/li&gt;
      &lt;li&gt;MyClass에서 Counter 클래스의 public 생성자 함수를 호출해 Counter 클래스의 객체를 생성하는 코드가 있음&lt;/li&gt;
      &lt;li&gt;Counter 클래스의 객체는 static final 변수에 할당됨(final 변수 = 값을 바꿀 수 없음)&lt;/li&gt;
      &lt;li&gt;static final 변수에 할당되므로 결국 싱글톤 패턴처럼 메모리에 딱 한번 할당되는 것은 맞음&lt;/li&gt;
      &lt;li&gt;즉, Counter 클래스의 객체는 MyClass 클래스의 객체가 생성될 때 자동으로 생성되는 “객체”임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;companion object가 자바의 static 변수/메소드와 같지 않은 이유&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;위와 같이 변환되어야 자바의 static 변수/메소드랑 같다고 할 수 있음&lt;/li&gt;
      &lt;li&gt;static 메소드일 것 같았던 count() 메소드는 Counter 클래스의 멤버 메소드이기 때문에 static과 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;그러나 companion object 작성 시 멤버 메소드에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;@JvmStatic&lt;/code&gt; 어노테이션을 붙이고, 멤버 변수에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;@JvmField&lt;/code&gt; 어노테이션을 붙이면 JVM이 companion object로 선언한 클래스의 멤버 변수/메소드를 진짜 자바의 static 변수/메소드처럼 변환해줌&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;@JvmStatic&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;n&quot;&gt;@JvmField&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;즉, companion object로 선언한 클래스의 멤버 변수/메소드를 inner class로 만들지 않고 static 변수/메소드와 같은 모습으로 변환함&lt;/li&gt;
      &lt;li&gt;어노테이션 관련해서는 &lt;a href=&quot;https://kotlinlang.org/docs/java-to-kotlin-interop.html#static-fields&quot;&gt;여기&lt;/a&gt; 보기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝&quot;&gt;끝!&lt;/h1&gt;

&lt;p&gt;마지막 수정일 : 2021/08/22&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-07/kotlin-object-keyword</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/kotlin-object-keyword</guid>
        
        
        <category>kotlin</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 자주 쓰는 안드로이드 스튜디오 단축키 모음</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/projects?hl=ko&quot;&gt;Android Developers Document - 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. 프로젝트 모든 파일에서 찾기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. 프로젝트 내에서 원하는 파일 찾기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;3. 지금 보고 있는 파일이 프로젝트 구조 상 어디에 있는지 확인하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#4&quot;&gt;4. 마구잡이로 펼쳐놓은 폴더들 다시 처음 구조로 접기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;#5&quot;&gt;5. 사용하지 않는 import 삭제하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#6&quot;&gt;6. 앱 Run 단축키&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#7&quot;&gt;7. 모든 텍스트 한 번에 변경하기&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;이 포스팅의 모든 단축키들은 맥북 기준입니다…!&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-프로젝트-모든-파일에서-찾기&quot;&gt;1️⃣ 프로젝트 모든 파일에서 찾기&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;보통 하나의 파일 안에서 특정 문자열을 찾을 때는 command + f 단축키를 누를 것이다! 그런데 문자열을 하나의 파일 내에서가 아니라 프로젝트 모든 파일 안에서 찾고 싶다면?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;command + shift + f&lt;/strong&gt; 단축키 누르기~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;스크린샷 2021-07-05 오후 11 24 17&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124486056-2d792f80-dde8-11eb-8d3a-9bb3d8a2bd62.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-전체-프로젝트-내에서-원하는-파일-및-메소드-찾기-&quot;&gt;2️⃣ 전체 프로젝트 내에서 원하는 파일 및 메소드 찾기 &lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로젝트 규모가 별로 크지 않다면 마우스로 폴더를 하나하나 클릭해서 내가 찾고자 하는 파일이 어디에 있는지 찾을 수 있다. 하지만 프로젝트 규모가 너무 크면(폴더도 막 20개 넘고,, 폴더 안에 또 폴더 엄청 많고,,) 마우스로 직접 찾기는 쉽지 않다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럴 땐 &lt;strong&gt;shift 두번 누르기&lt;/strong&gt; ~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;스크린샷 2021-07-05 오후 11 28 20&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124486589-b728fd00-dde8-11eb-8b46-6833eab2d430.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 검색창에 파일 이름 검색하면 바로 나옴!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마찬가지로, 전체 프로젝트 내에서 어떤 특정 메소드가 정의되어 있는 파일을 찾고 싶다면 쉬프트 두 번 누르고 메소드 이름 검색하면 됨~!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-지금-보고-있는-파일이-프로젝트-구조-상-어디에-있는지-확인하기&quot;&gt;3️⃣ 지금 보고 있는 파일이 프로젝트 구조 상 어디에 있는지 확인하기&lt;a id=&quot;3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;현재 내가 보고 있는 파일이 Android Studio 왼쪽에 보이는 프로젝트 구조 내에서 어디에 위치하는지 확인하고 싶다면?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;04&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124487012-2868b000-dde9-11eb-97b5-eead50e3c7b5.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 빨간 박스 부분 클릭 (이거에 대응하는 단축키가 option + F1이라는데.. 왜 내 맥북에선 option + F1이 안 먹지)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4️⃣-마구잡이로-펼쳐놓은-폴더들-다시-처음-구조로-접기&quot;&gt;4️⃣ 마구잡이로 펼쳐놓은 폴더들 다시 처음 구조로 접기&lt;a id=&quot;4&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;여러 파일들 이것 저것을 열다보면 여러 폴더들이 열려있게 된다. 그럼 Android Studio의 왼쪽에 보이는 프로젝트 구조가 정리가 안 되어 있게 되는데 이것을 한 번에 원상복귀할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;400&quot; alt=&quot;스크린샷 2021-07-05 오후 11 44 48&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124488598-007a4c00-ddeb-11eb-9762-cedaae29660f.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) &lt;strong&gt;빨간 박스 부분 클릭&lt;/strong&gt; 하거나 &lt;strong&gt;command + -&lt;/strong&gt; 단축키 누르기!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5️⃣-사용하지-않는-import-삭제하기&quot;&gt;5️⃣ 사용하지 않는 import 삭제하기&lt;a id=&quot;5&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;482&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/125306593-4fcff780-e36a-11eb-9ec5-344790bb2f92.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 개발을 하다보면 사용하지 않는 import 문들이 지저분하게 보여 일일이 삭제하는 경우가 있을 것이다. 지워야할 import 들이 많으면 참 귀찮다! 이럴땐?!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;control + option + o&lt;/strong&gt; 단축키 누르기~~ 한 방에 사용하지 않는 import 문들이 싹~ 지워진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6️⃣-앱-run-단축키&quot;&gt;6️⃣ 앱 Run 단축키&lt;a id=&quot;6&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;402&quot; alt=&quot;스크린샷 2021-08-10 오전 12 00 14&quot; src=&quot;https://user-images.githubusercontent.com/31889335/128728072-55752539-599d-4fca-9a38-7bc37d9742d2.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 앱 실행(Run) 버튼 누르기 은근 귀찮다… &lt;strong&gt;control + r&lt;/strong&gt; 누르기~&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7️⃣-모든-텍스트-한-번에-변경하기&quot;&gt;7️⃣ 모든 텍스트 한 번에 변경하기&lt;a id=&quot;7&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;개발하다 보면 예를 들어, 변수 이름을 textViewTitle 에서 tvTitle로 바꾸고 싶을 때가 있을 것이다.. 클래스 내 코드 상에서 textViewTitle 변수가 한두번 작성되어 있다면 하나하나 찾아가서 바꾸면 되겠지만 만약 100번 이상 작성되어 있다면? 어떻게 100개를 다 tvTitle로 하나하나 고치고 앉아있을까..?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;command + shift + r&lt;/strong&gt; 로 한 번에 바꾸자!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;498&quot; alt=&quot;스크린샷 2021-08-10 오전 12 07 22&quot; src=&quot;https://user-images.githubusercontent.com/31889335/128729194-6ff8f451-155b-4358-ba97-a0362901ec6f.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 빨간 박스 안의 윗 줄이 바꾸기 전 문자열이고, 아래 줄이 바꾼 후 문자열이다. 즉, 윗 줄의 문자열을 아래 줄의 문자열로 대체(replace)한다는 의미이고 왼쪽 하단 버튼 중 Replace All을 누르면 모두 한 번에 바뀐다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝-아님-&quot;&gt;끝 아님 ~&lt;/h1&gt;

&lt;p&gt;계속 추가 중 ..&lt;br /&gt;
마지막 수정일 : 2021년 8월 10일&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-07/android-studio-keyboard-shortcut</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/android-studio-keyboard-shortcut</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 안드로이드 프로젝트 구조(Android Project Structure)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/projects?hl=ko&quot;&gt;Android Developers Document - 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. 안드로이드 스튜디오에서 프로젝트 구조 보는 두 가지 방법&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. 안드로이드 프로젝트를 이해하려면 모듈을 알아야 한다&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;지인 개발자가 개발한 안드로이드 프로젝트를 구경하던 중,, 프로젝트 구조가 신기하게 생긴 것을 보게되었다! 프로젝트 구조에서 app 폴더와 같은 depth에 다른 폴더들이 있는 구조였다. 찾아보니 &lt;strong&gt;라이브러리 모듈&lt;/strong&gt; 이라는 것이었고, 이참에 안드로이드 프로젝트 구조를 공부해서 남겨본다 :)&lt;br /&gt;
&lt;img width=&quot;292&quot; alt=&quot;스크린샷 2021-07-05 오후 9 10 54&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124469604-88edf200-ddd5-11eb-8190-dcec8cf496e0.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-안드로이드-스튜디오에서-프로젝트-구조-보는-두-가지-방법&quot;&gt;1️⃣ 안드로이드 스튜디오에서 프로젝트 구조 보는 두 가지 방법&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Android Studio에서 프로젝트 구조를 볼 수 있는 방법은 두 가지이다. &lt;strong&gt;Android 뷰로 보기&lt;/strong&gt; 와 &lt;strong&gt;Project 뷰로 보기&lt;/strong&gt; 이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android 뷰로 보기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/124470178-42e55e00-ddd6-11eb-9b74-ec18f0196eac.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 하늘색 박스 부분을 Android로 선택해주면, Android 뷰로 프로젝트 구조를 확인할 수 있다. 어떤 프로젝트를 Android Studio로 실행하면 기본적으로 해당 프로젝트의 구조를 Android 뷰로 보여준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;292&quot; alt=&quot;스크린샷 2021-07-05 오후 9 10 54&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124471474-db301280-ddd7-11eb-8c48-814b7064e1a2.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) Android 뷰로 프로젝트 구조를 보게 되면, 해당 프로젝트가 컴퓨터에 연결된 디스크에 실제로 저장되는 구조(계층)와는 다르게 보인다. 하지만 가장 상위 폴더가 모듈별로 보여지기 때문에 프로젝트 구조를 한 눈에 보기 쉬운 장점이 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android 뷰로 프로젝트 구조를 볼 때의 특징은 프로젝트의 모든 빌드 관련 구성 파일을 &lt;strong&gt;Gradle Scripts&lt;/strong&gt; 라는 최상위 폴더로 묶어서 보여준다는 것이다. 하지만 실제 디스크 상에서는 이렇게 묶여있지 않다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;292&quot; alt=&quot;&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124473428-4844a780-ddda-11eb-829f-2a48464b6266.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 또한 앱 런처 아이콘의 여러 밀도별 대체 리소스가 ic_launcher.png 그룹에 묶여서 보여지는 것처럼, Android 뷰에서는 하나의 파일당 여러 대체 리소스 파일이 존재할 경우 하나의 그룹에 넣어서 보여준다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Project 뷰로 보기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;239&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124474975-23513400-dddc-11eb-9189-7298220c9e64.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 하늘색 박스 부분을 Project로 선택해주면, Project 뷰로 프로젝트 구조를 확인할 수 있다. Android 뷰에서 편의상 숨겨진 모든 파일을 모두 보여주고, 실제 디스크에 저장되는 프로젝트 구조로 보여준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Project 뷰에서의 빌드 구성 파일은 하나의 폴더로 묶여있지 않다. App의 빌드 구성 파일은 App 폴더 안에 있으며, 프로젝트 전체의 빌드 구성 파일은 App 폴더와 같은 depth에 위치한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-안드로이드-프로젝트를-이해하려면-모듈을-알아야-한다&quot;&gt;2️⃣ 안드로이드 프로젝트를 이해하려면 모듈을 알아야 한다&lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;What is 모듈(Module)?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;모듈은 소스 파일과 빌드 구성 파일 등으로 구성된 모음집(Collection)이다. 따라서 Project 뷰로 프로젝트 구조를 보았을 때, app 폴더 하위에는 소스 파일과 빌드 구성 파일이 모두 포함되어 있었으므로 app 폴더도 하나의 모듈이 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 모듈을 통해 하나의 프로젝트를 기능 단위로, 여러 개로, &lt;strong&gt;분할&lt;/strong&gt; 할 수 있게 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;하나의 프로젝트에는 여러 개의 모듈이 포함될 수 있고, 어떤 하나의 모듈이 다른 모듈을 종속 항목으로 사용할 수도 있다. 또한 각 모듈은 개별적으로 빌드하고 테스트, 디버그할 수 있다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;특히, Android Studio에서는 3가지의 서로 다른 Module Type(유형)을 지원한다. -&amp;gt; app 모듈, feature 모듈, library 모듈&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;app 모듈&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;app 모듈은 앱의 소스 코드, 리소스 파일, 빌드 구성 파일, Android Manifest 파일 등을 포함하고 있는 모듈이다. Android Studio에서 새로운 프로젝트를 만들면 기본적으로 app 모듈이 자동으로 생성된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;feature 모듈&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;feature 모듈은 Google Play에서 지원하는 &lt;a href=&quot;https://developer.android.com/guide/app-bundle/play-feature-delivery?hl=ko&quot;&gt;Play Feature Delivery&lt;/a&gt; 를 사용할 수 있는 모듈이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Play Feature Delivery를 간단히 설명해보자면.. 예를 들어, 결제 기능이 있는 앱에 feature 모듈로서 결제 모듈을 만들어 놓았다고 하자. 이 앱을 사용하는 어떤 사용자는 앱을 사용하긴 하지만 유료로 무언가를 결제하지는 않는 성향의 사용자일 수 있다. 또 다른 사용자는 이 앱에서 유료로 무언가를 결제까지 하는 사용자일 수 있다. 이런 경우, Play Feature Delivery를 활용하면 첫 번째 사용자에게는 결제 모듈을 제공하지 않고, 두 번째 사용자에게만 결제 모듈을 제공한다. 즉, 첫 번째 사용자는 사용하지도 않을 결제 모듈을 다운받게 되는 불상사를 당하지 않게 되어 다운로드 받을 총 apk 크기를 줄이는 효과를 얻을 수 있다!&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;library 모듈&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;library 모듈은 구조적으로 app 모듈과 동일한 모듈이다. 그러나 사용 목적이 다른데, library 모듈은 app 모듈에서 종속 항목으로 사용하기 위한 모듈이기도 하고 프로젝트1과 프로젝트2에서 공통으로 사용해야 하는 코드를 library 모듈로 만들어서 어떤 프로젝트에서든지 재사용할 수 있는 코드를 제공하기 위한 모듈이기도 하다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;library 모듈의 중요한 특징은 빌드될 때 APK로 만들어지는 것이 아니라 code archive 파일로 만들어지기 때문에 library 모듈을 안드로이드 기기에 설치할 수는 없다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android 프로젝트에 적용할 수 있는 library 모듈은 또 두 가지 종류로 나뉘는데 Android Library와 Java Library이다. 이 둘에 대해서는 나중에 조금 더 자세히 알아보기로 하고 일단 넘어가자 ㅎㅎ..&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:my-library-module&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(위 코드 참고) 위에서 알아본 &lt;strong&gt;모듈&lt;/strong&gt; 이라는 것을 &lt;strong&gt;하위 프로젝트(sub-project)&lt;/strong&gt; 라고도 부른다. 따라서 Gradle 설정에서도 모듈을 프로젝트로 취급한다. 예를 들어, 라이브러리 모듈을 생성하고 app 모듈의 종속 항목으로 추가할 때는 위와 같은 코드를 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝-&quot;&gt;끝 ~&lt;/h1&gt;

&lt;p&gt;이렇게 공부해보니.. 지인의 프로젝트 구조에는 여러 개의 library 모듈이 포함되어 있는 것이였다! :)&lt;br /&gt;
마지막 수정일 : 2021년 7월 5일&lt;/p&gt;
</description>
        <pubDate>2021-09-15</pubDate>
        <link>http://localhost:4000/articles/2021-07/android-project-structure</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/android-project-structure</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
  </channel>
</rss>

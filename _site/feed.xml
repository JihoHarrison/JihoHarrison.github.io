<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>choheeis</title>
    <description>안드로이드 개발자를 목표로 달려나가는 김초희의 블로그입니다😍</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>2021-09-13</pubDate>
    <lastBuildDate>Mon, 13 Sep 2021 10:58:16 +0200</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>[Kotlin] 코틀린의 object 키워드 잘 알고 사용하기(feat. companion object)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/object-declarations.html&quot;&gt;Kotlin Document - Object expressions and declarations&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=KUk6k865Vgg&quot;&gt;Youtube Android Developers - Object - Kotlin Vocabulary&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. object expression VS object declaration&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. object expression이 뭐예요?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;3. object expression 더 알아보기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;#4&quot;&gt;4. object declaration가 뭐예요?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#5&quot;&gt;5. object declaration 더 알아보기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#6&quot;&gt;6. companion object가 뭐예요?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#7&quot;&gt;7. companion object 더 알아보기&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-프롤로그&quot;&gt;✍🏻 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;코틀린으로 코드를 작성하다보면(저는 안드로이드 앱 개발을 코틀린으로 합니다) &lt;strong&gt;object&lt;/strong&gt; 라는 키워드를 사용하게 되는 몇 가지 경우가 있다!&lt;br /&gt;
하지만 그동안 대충 구글링하여 짧은 순간 습득한 지식으로 이해한 후 사용했었는데..(으이구~) 좀 제대로 알고 사용하려는 목적으로 공부해본다..ㅎㅎ&lt;br /&gt;
(아! 그리고 object 키워드에 대해서 공부하게 된 가장 큰 목적은 companion object를 제대로 이해해보고자 시작하게 된 것이다..ㅋㅋㅋ)&lt;/p&gt;

&lt;h2 id=&quot;-object-expression-vs-object-declaration&quot;&gt;✅ object expression VS object declaration&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 사용법을 알려면 object expression 이랑 object declaration 라는 걸 구분할 수 있어야 함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 이 두 가지 모두에서 사용하기 때문&lt;/li&gt;
  &lt;li&gt;용어 한글 번역
    &lt;ul&gt;
      &lt;li&gt;object expression = 객체 표현식&lt;/li&gt;
      &lt;li&gt;object declaration = 객체 선언&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;object expression와 object declaration의 공통점
    &lt;ul&gt;
      &lt;li&gt;개발을 하다 보면 A 클래스의 모습에서 아주 살짝만 수정된 모습인 B 클래스를 작성해야 하는 경우가 있을 수 있다. 이런 경우, B 클래스를 만들면 A 클래스와 거의 비슷한 클래스를 하나 더 작성하는 꼴이 되어 비효율적이다.&lt;/li&gt;
      &lt;li&gt;B 클래스를 새로 작성하지 않고 B 클래스의 객체를 생성할 수 있을까?&lt;/li&gt;
      &lt;li&gt;코틀린은 딱 이런 상황에서 사용할 수 있도록 object expression와 object declaration라는 것을 지원함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-expression이-뭐예요&quot;&gt;✅ object expression이 뭐예요?&lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;object expression(객체 표현식)는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 사용하여 익명 클래스의 객체를 생성할 때 사용&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;익명 클래스&lt;/code&gt; = 클래스를 작성할 때 클래스 이름이 명시적으로 작성되어 있지 않은 클래스. 즉, 이름이 없는 클래스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바로 아래 코드를 보면 무슨 말인지 한 방에 이해됨&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;yourName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{
        &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LastName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Kim&quot;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FirstName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Chohee&quot;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// object expressions는 내부적으로 코틀린의 Any 클래스를 default 부모 클래스로 상속하고 있기 때문에 toString() 메소드를 오버라이딩할 수 있다!
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Your name is $LastName $FirstName&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 뒤에 나오는 코드를 보면 LastName, FirstName라는 멤버 변수가 선언되어 있고, toString()라는 멤버 메소드를 가지는 익명 클래스가 작성되어 있음&lt;/li&gt;
      &lt;li&gt;이런 식으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;익명 클래스&lt;/code&gt;를 작성하고 그 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 붙여주면 그 시점에서 해당 익명 클래스의 &lt;strong&gt;객체가 바로 생성됨&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;객체가 바로 생성된다 = 해당 클래스의 생성자 함수 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;01&quot; src=&quot;https://user-images.githubusercontent.com/31889335/125470357-c2ffd2d5-b7a3-437b-b3ff-a7b465de7cf2.png&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;(위 그림 참고) &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;익명 클래스&lt;/code&gt; 앞에 붙여줌으로써 익명 클래스의 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 작성 시점에서 바로 생성함&lt;/li&gt;
      &lt;li&gt;생성한 객체가 yourName 변수에 할당됨&lt;/li&gt;
      &lt;li&gt;위 코드의 main 함수를 실행해보면 Your name is Kim Chohee가 출력됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;object expression = &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드 뒤에 익명 클래스를 선언하면 그 시점에서 바로 객체화해주는 것&lt;/li&gt;
      &lt;li&gt;이렇게 특정 코드 라인에서 익명 클래스를 작성하고 바로 객체로 만드는 경우는, 해당 익명 클래스를 프로젝트 내에서 여러번 재사용하지 않고 딱 한 번만 사용해야 하는 경우에 유용&lt;/li&gt;
      &lt;li&gt;obejct expression에서 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드는 한글 해석한 그대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;객체&lt;/code&gt; 라고 생각하기 = 키워드 작성 시점에서 바로 객체로 생성되므로!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;생각
    &lt;ul&gt;
      &lt;li&gt;왜 이름이 object expression 일까?&lt;/li&gt;
      &lt;li&gt;object expression = 객체 표현식 인 것을 떠올려보자&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어 분야에서 “표현식” = “수식” 임&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어에서 “수식” = 1+2와 같은 수식 / 함수 호출식 / 변수 이름 등 포함&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어에서 “수식” = 모양과 형태가 다를 수 있지만 모두 하나의 단일 값이 될 수 있는 것을 의미&lt;/li&gt;
      &lt;li&gt;따라서 익명 클래스를 객체화하는 행위인 object expression도 익명 클래스를 객체화하여 하나의 단일 값으로 만들 수 있기 때문에 object “expression” 라는 이름이라고 추측해 봄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-expression-더-알아보기&quot;&gt;✅ object expression 더 알아보기&lt;a id=&quot;3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;object expression은 기본적으로 &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/&quot;&gt;Any&lt;/a&gt;라는 코틀린 클래스를 상속함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Any 클래스 말고도 다른 클래스나 다른 인터페이스를 상속한 익명 클래스도 object expression로 객체화 가능&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Person 인터페이스를 상속하는 익명 클래스를 object expressions 사용해서 객체화시키기
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;yourName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LastName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;당신은&quot;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FirstName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;천재!&quot;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Person 인터페이스에 정의된 getYourName 구현
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getYourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Your name is $LastName $FirstName&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getYourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getYourName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;위 코드처럼 Person 이라는 인터페이스를 하나 만듬&lt;/li&gt;
      &lt;li&gt;Person 인터페이스를 상속하는 익명 클래스를 object expressions로 객체화 가능&lt;/li&gt;
      &lt;li&gt;main 함수 실행시키면 Your name is 당신은 천재!가 출력됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드 앱 개발에서 언제 object expression를 쓰면 좋을까?
    &lt;ul&gt;
      &lt;li&gt;&lt;img width=&quot;650&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/125475693-b3260e6d-0d4f-4f2f-b50c-5703c9f40a2c.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;XXOnXXXListener() 라는 메소드를 호출할 때 많이 사용함&lt;/li&gt;
      &lt;li&gt;XXOnXXXListener() 메소드는 인자로 특정 인터페이스를 구현한 클래스의 객체를 넘겨줘야 하는 경우가 많음&lt;/li&gt;
      &lt;li&gt;위 코드에서는 View.OnClickListener라는 인터페이스를 구현한 클래스의 객체를 setOnClickListener() 메소드의 인자로 넘겨야 함&lt;/li&gt;
      &lt;li&gt;보통 이럴 때 object expressions을 사용해서(람다로 대체할 수도 있긴 하지만..) 인자로 전달해야 하는 객체를 생성&lt;/li&gt;
      &lt;li&gt;특정 인터페이스를 구현한 클래스를 더 이상 프로젝트 다른 곳에서 재사용하지 않기 때문에 익명 클래스를 만들어 구현하는 것!&lt;/li&gt;
      &lt;li&gt;예를 들어, 텍스트 뷰를 클릭한 결과로 실행되어야 하는 작업은 모든 텍스트 뷰에서 동일하지 않을 것이다. 각각 다른 텍스트 뷰의 클릭 리스너를 호출하는 순간 순간마다 각기 다른 작업을 실행하는 코드를 매번 구현해야 하기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-declaration가-뭐예요&quot;&gt;✅ object declaration가 뭐예요?&lt;a id=&quot;4&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;object declaration는 &lt;strong&gt;소프트웨어 디자인 패턴 중 &lt;a href=&quot;https://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;싱글톤 패턴&lt;/a&gt;을 만드는 작업을 할 때 사용&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;싱글톤 패턴
    &lt;ul&gt;
      &lt;li&gt;객체 지향 언어에서는 필요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;클래스&lt;/code&gt; 들을 만들어놓고 실제로 사용할 때는 클래스를 토대로 만들어지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;객체&lt;/code&gt; 라는 것을 생성해서 메모리에 할당함&lt;/li&gt;
      &lt;li&gt;이 때, 똑같은 클래스를 토대로 하여 만들어지는 객체를 이곳 저곳에서 여러번 생성한다면?
        &lt;ul&gt;
          &lt;li&gt;여러 번 생성된 객체는 모두 따로 따로 메모리 공간을 차지하게 됨&lt;/li&gt;
          &lt;li&gt;즉, 생성된 객체 수 만큼 따로 따로 메모리에 할당됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 으로 클래스를 만들어 놓으면 해당 클래스를 토대로 생성되는 객체는 여러 번 생성할 수 없음&lt;/li&gt;
      &lt;li&gt;따라서 딱 한 번만 객체로 생성되어 메모리에 할당됨&lt;/li&gt;
      &lt;li&gt;싱글톤 패턴이 적용된 클래스의 객체를 여러 곳에서 사용하더라도 이 객체는 항상 같은 메모리 주소를 바라봄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스 만드는 기존 방법(자바)&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 자바에서 싱글톤 패턴이 적용된 클래스 만들기&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;자바에서는 싱글톤 패턴이 적용된 클래스를 만들기 위해서 위와 같은 코드를 작성해야 했음&lt;/li&gt;
      &lt;li&gt;INSTANCE라는 static 변수를 만들어 놓고 이 변수의 값을 null 체크하는 방식&lt;/li&gt;
      &lt;li&gt;만약 INSTANCE가 null이 아니면(즉, 단 한 번이라도 객체가 생성된 적이 있으면) 기존의 생성되어 있던 객체를 반환해줌으로써 새로운 객체가 여러 번 생성되는 것을 막는 방식&lt;/li&gt;
      &lt;li&gt;하지만 이 방식은 thread-safe 하지 않았음
        &lt;ul&gt;
          &lt;li&gt;쓰레드 A에서 위 코드의 if (INSTANCE == null) 코드줄을 실행하고 있다고 해보자.&lt;/li&gt;
          &lt;li&gt;쓰레드 A가 이 코드줄을 실행할 시점에서 INSTANCE는 null 이였다고 가정&lt;/li&gt;
          &lt;li&gt;이 때 갑자기 운영체제에 의해 쓰레드 B에게 제어권이 넘어가게 되었다고 하면 쓰레드 A는 다음 코드줄을 실행하지 못하고 실행을 멈추게 된다.&lt;/li&gt;
          &lt;li&gt;즉, INSTANE = new MySingleTon(); 을 실행하지 못하고 이 줄에서 멈춤&lt;/li&gt;
          &lt;li&gt;그런데 쓰레드 B에서도 MySingleTon 클래스의 코드 실행하는 작업이 실행된다면?&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/130348819-b55a69f1-b353-47d0-89b6-95c6859f5fa7.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;즉, 두 개의 쓰레드가 동시에 MySingleTon 클래스에 접근하게 될 경우임&lt;/li&gt;
          &lt;li&gt;쓰레드 A가 멈춘 동안 쓰레드 B가 INSTANCE null 체크를 하는 순간에도 INSTANCE는 null이다.(쓰레드 A에서 new MySingleTon(); 이 실행되지 못했으므로)&lt;/li&gt;
          &lt;li&gt;쓰레드 B에서 INSTANCE = new MySingleTon(); 이 실행되어 INSTANCE에 MySingleTon 클래스의 객체가 할당됨&lt;/li&gt;
          &lt;li&gt;이 후 다시 쓰레드 A에게 제어권이 돌아오면 쓰레드 A는 실행 멈춤되었던 코드 줄을 실행하기 시작함&lt;/li&gt;
          &lt;li&gt;쓰레드 A에 의해서 INSTANCE = new MySingleTon(); 이 또 실행되어 결국 두 개의 메모리 주소에 MySingleTon 클래스의 객체가 할당됨&lt;/li&gt;
          &lt;li&gt;이는 싱글톤 패턴이 아님 (메모리에 한 번만 할당되어야 하기 때문)&lt;/li&gt;
          &lt;li&gt;thread-safe를 보장하기 위해 위 코드에 쓰레드 여러 개에서 더블 체크하는 경우를 방지하는 코드가 더 추가되게 됨&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/130349171-b3964d08-3c1b-46c9-be82-69aa6bf1ef39.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;이 외에도 여러 가지 문제를 방지하기 위한 코드가 붙여져 싱글톤 패턴 적용된 클래스를 자바로 작성하는 방법이 복잡해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자바에서 싱글톤 패턴 클래스 하나 작성하는데 긴 코드를 작성해야 했고, 싱글톤 패턴을 만들 때 마다 반복적으로 작성해야 하는 불편함 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스 만드는 쉬운 방법(코틀린)&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 코틀린에서 싱글톤 패턴이 적용된 클래스 만들기
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;코틀린에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스를 자바보다 더 쉽게 만들 수 있도록 지원해줌&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 사용하면 되고, 이러한 행위를 object decalaration라고 부름&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt; 키워드를 사용하여 클래스를 정의하는 모습과 비슷하지만 class 키워드 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 붙여서 클래스를 생성해주면 싱글톤 패턴이 적용된 클래스가 생성됨&lt;/li&gt;
      &lt;li&gt;코틀린 언어 내부적으로 이렇게 클래스 생성 시 thread-safe한 싱글톤 패턴이 되도록 처리 다 되어있음&lt;/li&gt;
      &lt;li&gt;자바보다 훨씬 간단&lt;/li&gt;
      &lt;li&gt;이렇게 클래스 작성하면 작성 시점에 바로 해당 클래스의 객체를 단 한 개 생성해놓음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;object declaration = 싱글톤 패턴 적용된 클래스 만들 때 사용하는 것&lt;/li&gt;
      &lt;li&gt;obejct declaration에서 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드는 한글 해석한 그대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;객체&lt;/code&gt; 라고 생각하기
        &lt;ul&gt;
          &lt;li&gt;òbject` 키워드를 붙여 생성한 클래스는 싱글톤 패턴이 적용된 클래스라 딱 한 번만 객체화 되기 때문&lt;/li&gt;
          &lt;li&gt;또 클래스 작성 시점에 바로 해당 클래스의 객체를 단 한 개 생성하기 때문&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;생각
    &lt;ul&gt;
      &lt;li&gt;왜 이름이 object declaration 일까?&lt;/li&gt;
      &lt;li&gt;declaration = 선언 인 것을 떠올려보자&lt;/li&gt;
      &lt;li&gt;사용법이 클래스를 “선언”하는 모습과 비슷하기 때문에 object “declaration” 이 아닐까 추측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-object-declaration-더-알아보기&quot;&gt;✅ object declaration 더 알아보기&lt;a id=&quot;5&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;싱글톤 패턴&lt;/code&gt; 이 적용된 클래스의 객체 사용법&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 코틀린에서 MySingleTon 클래스의 객체 사용하기
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;mySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Kimchohee 출력됨
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;VS&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;// 자바에서 MySingleTon 클래스의 객체 사용하기
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Kimchohee 출력됨
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;코틀린에서 싱글톤 패턴이 적용된 클래스의 객체를 사용하기 위해서는 해당 클래스 이름 자체를 사용하면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 키워드를 사용해 싱글톤 패턴이 적용된 클래스를 만들 때는 부모 클래스 상속도 가능&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SuperClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;superExample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-companion-object가-뭐예요&quot;&gt;✅ companion object가 뭐예요?&lt;a id=&quot;6&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;companion object = object declaration을 일반 클래스 내부에서 바로 작성하는 것&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;companion&lt;/code&gt; 라는 키워드를 object declaration 앞에 붙여줌&lt;/li&gt;
  &lt;li&gt;companion 한글 번역 = “동반자”&lt;/li&gt;
  &lt;li&gt;companion object = “동반자 객체”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바로 아래 코드 봐보자!&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// MySingleTon 이라는 이름 안 써도 됨
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kimchohee&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;MyClass라는 일반 클래스 내부에서 바로 싱글톤 패턴이 적용된 MySingleTon 클래스를 작성하는 모습&lt;/li&gt;
      &lt;li&gt;companion object의 이름은 생략 가능(이름 없어도 됨)&lt;/li&gt;
      &lt;li&gt;MyClass 안에 작성된 MySingleTon 객체는 작성 시점에서 바로 객체로 생성됨&lt;/li&gt;
      &lt;li&gt;또 딱 한 번만 생성되어 메모리에 한 번만 할당됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;companion object 안에 선언된 멤버 변수/메소드 호출법&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// companion object 클래스의 이름이 있는 경우
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MySingleTon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      
    &lt;span class=&quot;c1&quot;&gt;// companion object 클래스의 이름이 없는 경우
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;companion object 안에 선언된 변수/메소드 호출할 때는 위 코드와 같이 호출&lt;/li&gt;
      &lt;li&gt;클래스 이름 자체가 companion object로 작성한 클래스의 객체 참조자 이름으로 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-companion-object-더-알아보기&quot;&gt;✅ companion object 더 알아보기&lt;a id=&quot;7&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;companion object 사용시 주의점
    &lt;ul&gt;
      &lt;li&gt;companion object가 자바의 static처럼 보이지만 진정한 static은 아님&lt;/li&gt;
      &lt;li&gt;자바의 static 변수/메소드
        &lt;ul&gt;
          &lt;li&gt;싱글톤 패턴과 비슷한 개념&lt;/li&gt;
          &lt;li&gt;어떤 클래스의 객체 생성 시 객체가 생성되는 횟수에 상관 없이 static으로 선언된 변수/메소드는 딱 한 번만 생성되어 메모리에 한 번만 할당됨&lt;/li&gt;
          &lt;li&gt;static 변수는 컴파일 시(런타임 때가 아님) 메모리에 할당됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;companion object로 선언한 클래스는 왜 자바의 static처럼 보일까?
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;companion object&lt;/code&gt; 로 선언한 클래스는 작성 시점에서 바로 객체화되고, 단 한 번만 메모리에 할당되기 때문&lt;/li&gt;
          &lt;li&gt;static 변수와 동일하다고 생각할 수 있음&lt;/li&gt;
          &lt;li&gt;심지어 자바로 작성된 static 변수를 코틀린 언어으로 변환시키면 companion object 안에 static으로 선언했던 변수들이 선언되어 있는 모습으로 바뀜&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하지만 companion object와 자바의 static 변수/메소드는 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 static 변수/메소드 예시&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// static 변수&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      
    &lt;span class=&quot;c1&quot;&gt;// static 메소드&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;companion object의 실체&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 멤버 변수
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
          
        &lt;span class=&quot;c1&quot;&gt;// 멤버 메소드
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;MyClass라는 일반 클래스 내부에 Counter라는 이름의 companion object가 선언되어 있다고 가정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위 companion object를 자바로 변환하면 아래와 같음&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Counter 클래스 생성&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// inner class로 작성되는 Counter 클래스&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 첫 번째, 생성자 함수 = private&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
          
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;c1&quot;&gt;// 두 번째 생성자 함수 = public&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultConstructorMarker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// = Counter();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;companion object로 선언된 Counter 클래스는 자바에서는 사실 MyClass의 inner class로 작성됨&lt;/li&gt;
      &lt;li&gt;inner class = 클래스 내에 또 클래스가 작성되는 것&lt;/li&gt;
      &lt;li&gt;Counter 클래스의 생성자 함수가 private과 public 두 가지로 생성되어 있음&lt;/li&gt;
      &lt;li&gt;MyClass에서 Counter 클래스의 public 생성자 함수를 호출해 Counter 클래스의 객체를 생성하는 코드가 있음&lt;/li&gt;
      &lt;li&gt;Counter 클래스의 객체는 static final 변수에 할당됨(final 변수 = 값을 바꿀 수 없음)&lt;/li&gt;
      &lt;li&gt;static final 변수에 할당되므로 결국 싱글톤 패턴처럼 메모리에 딱 한번 할당되는 것은 맞음&lt;/li&gt;
      &lt;li&gt;즉, Counter 클래스의 객체는 MyClass 클래스의 객체가 생성될 때 자동으로 생성되는 “객체”임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;companion object가 자바의 static 변수/메소드와 같지 않은 이유&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;위와 같이 변환되어야 자바의 static 변수/메소드랑 같다고 할 수 있음&lt;/li&gt;
      &lt;li&gt;static 메소드일 것 같았던 count() 메소드는 Counter 클래스의 멤버 메소드이기 때문에 static과 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;그러나 companion object 작성 시 멤버 메소드에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;@JvmStatic&lt;/code&gt; 어노테이션을 붙이고, 멤버 변수에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;@JvmField&lt;/code&gt; 어노테이션을 붙이면 JVM이 companion object로 선언한 클래스의 멤버 변수/메소드를 진짜 자바의 static 변수/메소드처럼 변환해줌&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;@JvmStatic&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;n&quot;&gt;@JvmField&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;즉, companion object로 선언한 클래스의 멤버 변수/메소드를 inner class로 만들지 않고 static 변수/메소드와 같은 모습으로 변환함&lt;/li&gt;
      &lt;li&gt;어노테이션 관련해서는 &lt;a href=&quot;https://kotlinlang.org/docs/java-to-kotlin-interop.html#static-fields&quot;&gt;여기&lt;/a&gt; 보기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝&quot;&gt;끝!&lt;/h1&gt;

&lt;p&gt;마지막 수정일 : 2021/08/22&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-07/kotlin-object-keyword</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/kotlin-object-keyword</guid>
        
        
        <category>kotlin</category>
        
      </item>
    
      <item>
        <title>[Kotlin] 코틀린 Enum Class란?</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/enum-classes.html&quot;&gt;Kotlin Document - Enum Classes&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=SKosPXHLT5Q&quot;&gt;Youtube 테크과학! DiMo - Kotlin 강좌 #25 - Data Class와 Enum Class&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. What is Enum Class?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. Enum Class만의 특징&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;3. 코틀린 Enum Class가 제공하는 스페셜 메소드들&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;프롤로그까지는 아니지만…  요즘 회사 다니면서 느낀점… 저녁시간과 주말은 정말 소중한 시간이다..!! 퇴근하면 부족한 부분 공부하거나 좋아하는 책들 읽으면서 시간을 보내는데 이 시간이 너무 짧게만 느껴진다.&lt;br /&gt;
그치만 이제 곧 시간 날 때마다.. 캡디 개발도 해야하고 이사갈 집도 구하러 다녀야할텐데 ,, 미래의 나에게 맡기자..(ㅎㅎ?)&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-what-is-enum-class&quot;&gt;1️⃣ What is Enum Class?&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이 포스팅에서는 코틀린 버전 v1.5.20 기준에서 공부한 Enum Class에 대해 설명한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enum Class의 &lt;strong&gt;“Enum”&lt;/strong&gt; 은 Enumerated(=’열거’라는 뜻)의 줄임말이다. 이름에서 알 수 있듯이 Enum class는 열거형 클래스이다. Enum Class를 설명하는 유튜브 영상을 몇 개 봐보니 한국말로는 이늄 클래스 또는 이넘 클래스로 읽는 듯하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코틀린에서는 일반 Class 외에 Data Class라는 것과 Enum Class라는 것을 따로 제공하는데 이 두 클래스는 일반 클래스가 제공하지 않는 특정한 용도의 기능들을 각각 제공한다. 이 두 클래스 중 Enum Class에 대해 알아보자!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;COKE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SNACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WATER&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) Enum Class의 가장 기본적인 사용법은 위와 같다. 뭔진 몰라도 5개의 상수(?)들이 한줄로 쭈루룩 열거되고 있는 모습이다. ‘Enum = 열거’라는 의미에 딱 맞는 모습이다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 Enum Class에 선언된 5가지 상수들은 사실 &lt;strong&gt;Store 클래스의 객체(object)&lt;/strong&gt; 이다. 즉, 위 5개의 상수같이 보이는 것들은 모두 Store 클래스의 객체를 선언한 것이다. 이 때, 각 객체 이름을 Store 외의 다른 이름으로 자유롭게 지을 수 있다. Enum Class에 객체를 선언할 때는 상수를 선언할 때처럼 객체 이름의 모든 문자를 대문자로 쓰고, 여러 개의 객체를 선언할 때는 콤마(,)를 찍어 선언하는 것이 규칙이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;따라서 위 Store Enum Class 안에는 Store 클래스의 객체 5개가 선언되어 있는 것이다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 가게에서 파는 5가지 상품에 가격 부여하여 객체 초기화
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;COKE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SNACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;900&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;WATER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(위 코드 참고) Enum Class에 생성자를 만들어주고, 각 객체 선언 시 초기화를 해줄 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-enum-class만의-특징&quot;&gt;2️⃣ Enum Class만의 특징&lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;COKE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SNACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;900&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;WATER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 새미콜론 찍기
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isExpensive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;standardPrice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;standardPrice&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 가격 비교 대상이 객체 자기 자신의 가격이므로 this.price임
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) Enum Class는 일반 클래스의 특징도 가지고 있기 때문에 멤버 객체 외에 멤버 메소드도 선언할 수 있다. 대신 이런 경우에는 멤버 객체 선언부 마지막에 새미콜론(;)을 찍어 객체 선언부와 메소드 선언부를 분리시켜줘야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;selectedItem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selectedItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isExpensive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000원 밖에 없음.. 비싸ㅠ&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;싸네! 살래~&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;selectedItem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COKE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selectedItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isExpensive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000원 밖에 없음.. 비싸ㅠ&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;싸네! 살래~&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) main() 함수를 위와 같이 작성하여 실행해보면 첫 번째 출력은 싸다고 나오고 두 번째 출력은 비싸다고 나온다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;우유 샀음&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아이스크림 샀음&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 새미콜론 찍기
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 추상 메소드(정의만 된 상태의 메소드이므로 어딘가에서 구현이 필요)
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) Enum Class의 또 다른 특징은 Enum Class에 선언된 객체는 자신만의 익명 클래스(anonymous class)로 선언될 수도 있다는 점이다. 익명 클래스는 위 코드와 같이 메소드를 오버라이딩할 수도 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myPick&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myPick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;myPick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myPick2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myPick2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;myPick2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) main 함수를 위와 같이 작성하고 실행시키면 우유 샀음만 출력된다. 이렇게 enum class의 장점은 상태에 따라(MILK냐 ICECREAM이냐) 수행해야 할 로직을 분리하기 좋다는 점이다 !&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Buying&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;우유 샀음&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아이스크림 샀음&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 새미콜론 찍기
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Buying&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(위 코드 참고) 위와 같이 인터페이스를 만들고, enum class의 각 익명 클래스에서 오버라이딩하여 구현하는 것도 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-코틀린-enum-class가-제공하는-스페셜-기능들&quot;&gt;3️⃣ 코틀린 Enum Class가 제공하는 스페셜 기능들&lt;a id=&quot;3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EnumClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EnumClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EnumClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnumClass&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;객체&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;EnumClass&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;객체&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;EnumClass&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;객체&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordinal&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// original 아님 ㅋㅋ,,,
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) 코틀린 Enum Class는 자체적으로 위 4가지 기능을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__EnumClass.values(): Array&lt;EnumClass&gt;__&lt;/EnumClass&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [MILK 객체, ICECREAM 객체] 배열 반환됨
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Buying&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;우유 샀음&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아이스크림 샀음&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 새미콜론 찍기
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Buying&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isRemain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;(위 코드 참고) main 함수를 실행시킨 결과는 우유 샀음 개행 아이스크림 샀음이다! 즉, values()는 해당 Enum Class에 선언된 객체들을 배열로 반환해주는 메소드임을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EnumClass.valueOf(value: String): EnumClass객체&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myPickIsMilk&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MILK&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;(위 코드 참고) main 함수를 실행시키면 우유 샀음이 출력된다! 즉, valueOf()는 Enum Class에 선언되어 있는 객체들 중 특정 객체만을 반환해주는 메소드임을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EnumClass객체.name&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;(위 코드 참고) main 함수를 실행시키면 MILK가 출력된다. 즉, EnumClass객체.name 은 해당 객체의 이름을 String형으로 반환한다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EnumClass객체.ordinal&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;milkOrdinal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MILK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordinal&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;iceCreamOrdinal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ICECREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordinal&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;milkOrdinal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iceCreamOrdinal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;(위 코드 참고) main 함수를 실행시키면 0 개행 1이 출력된다. ordinal은 “순서를 나타내는” 이라는 의미를 가진 영어다. Enum Class는 내부에 나열된 객체들에게 자체적으로 순서를 매긴다. 첫 번째 객체에 순서 0번을 부여하고 그 다음 객체부터 1씩 증가시켜 순서 번호를 부여한다. 따라서 위 코드를 보면 EnumClass객체.ordinal은 해당 객체의 순서(정수)를 반환해줌을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝-&quot;&gt;끝 ~&lt;/h1&gt;

&lt;p&gt;공부해보고 나니 Enum Class는 상태별로 로직을 구분해야하거나 상태별로 다른 것을 저장하고 있어야할 때 사용하면 유용할 것 같다!&lt;br /&gt;
마지막 수정일 : 2021년 7월 7일&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-07/kotlin-enum-class</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/kotlin-enum-class</guid>
        
        
        <category>kotlin</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 자주 쓰는 안드로이드 스튜디오 단축키 모음</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/projects?hl=ko&quot;&gt;Android Developers Document - 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. 프로젝트 모든 파일에서 찾기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. 프로젝트 내에서 원하는 파일 찾기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;3. 지금 보고 있는 파일이 프로젝트 구조 상 어디에 있는지 확인하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#4&quot;&gt;4. 마구잡이로 펼쳐놓은 폴더들 다시 처음 구조로 접기&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;#5&quot;&gt;5. 사용하지 않는 import 삭제하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#6&quot;&gt;6. 앱 Run 단축키&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#7&quot;&gt;7. 모든 텍스트 한 번에 변경하기&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;규모가 큰 프로젝트(클래스 수 엄청 많음,,)에 코드 수정을 하다보니 자연스럽게 Android Studio에서 사용할 수 있는 단축키를 찾게 되어 공유합니댕~ :)&lt;br /&gt;
앞으로 꿀 단축키 발견할 때마다 추가할 예정입니다. 댓글로도 공유해주시면 아주 아주 감사드립니다 ~.~&lt;br /&gt;
그리고,, 이 포스팅의 모든 단축키들은 맥북 기준입니다…!&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-프로젝트-모든-파일에서-찾기&quot;&gt;1️⃣ 프로젝트 모든 파일에서 찾기&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;보통 하나의 파일 안에서 특정 문자열을 찾을 때는 command + f 단축키를 누를 것이다! 그런데 문자열을 하나의 파일 내에서가 아니라 프로젝트 모든 파일 안에서 찾고 싶다면?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;command + shift + f&lt;/strong&gt; 단축키 누르기~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;스크린샷 2021-07-05 오후 11 24 17&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124486056-2d792f80-dde8-11eb-8d3a-9bb3d8a2bd62.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-전체-프로젝트-내에서-원하는-파일-및-메소드-찾기-&quot;&gt;2️⃣ 전체 프로젝트 내에서 원하는 파일 및 메소드 찾기 &lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로젝트 규모가 별로 크지 않다면 마우스로 폴더를 하나하나 클릭해서 내가 찾고자 하는 파일이 어디에 있는지 찾을 수 있다. 하지만 프로젝트 규모가 너무 크면(폴더도 막 20개 넘고,, 폴더 안에 또 폴더 엄청 많고,,) 마우스로 직접 찾기는 쉽지 않다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럴 땐 &lt;strong&gt;shift 두번 누르기&lt;/strong&gt; ~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;스크린샷 2021-07-05 오후 11 28 20&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124486589-b728fd00-dde8-11eb-8b46-6833eab2d430.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 검색창에 파일 이름 검색하면 바로 나옴!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마찬가지로, 전체 프로젝트 내에서 어떤 특정 메소드가 정의되어 있는 파일을 찾고 싶다면 쉬프트 두 번 누르고 메소드 이름 검색하면 됨~!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-지금-보고-있는-파일이-프로젝트-구조-상-어디에-있는지-확인하기&quot;&gt;3️⃣ 지금 보고 있는 파일이 프로젝트 구조 상 어디에 있는지 확인하기&lt;a id=&quot;3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;현재 내가 보고 있는 파일이 Android Studio 왼쪽에 보이는 프로젝트 구조 내에서 어디에 위치하는지 확인하고 싶다면?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;04&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124487012-2868b000-dde9-11eb-97b5-eead50e3c7b5.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 빨간 박스 부분 클릭 (이거에 대응하는 단축키가 option + F1이라는데.. 왜 내 맥북에선 option + F1이 안 먹지)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4️⃣-마구잡이로-펼쳐놓은-폴더들-다시-처음-구조로-접기&quot;&gt;4️⃣ 마구잡이로 펼쳐놓은 폴더들 다시 처음 구조로 접기&lt;a id=&quot;4&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;여러 파일들 이것 저것을 열다보면 여러 폴더들이 열려있게 된다. 그럼 Android Studio의 왼쪽에 보이는 프로젝트 구조가 정리가 안 되어 있게 되는데 이것을 한 번에 원상복귀할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;400&quot; alt=&quot;스크린샷 2021-07-05 오후 11 44 48&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124488598-007a4c00-ddeb-11eb-9762-cedaae29660f.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) &lt;strong&gt;빨간 박스 부분 클릭&lt;/strong&gt; 하거나 &lt;strong&gt;command + -&lt;/strong&gt; 단축키 누르기!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5️⃣-사용하지-않는-import-삭제하기&quot;&gt;5️⃣ 사용하지 않는 import 삭제하기&lt;a id=&quot;5&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;482&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/125306593-4fcff780-e36a-11eb-9ec5-344790bb2f92.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 개발을 하다보면 사용하지 않는 import 문들이 지저분하게 보여 일일이 삭제하는 경우가 있을 것이다. 지워야할 import 들이 많으면 참 귀찮다! 이럴땐?!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;control + option + o&lt;/strong&gt; 단축키 누르기~~ 한 방에 사용하지 않는 import 문들이 싹~ 지워진다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6️⃣-앱-run-단축키&quot;&gt;6️⃣ 앱 Run 단축키&lt;a id=&quot;6&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;402&quot; alt=&quot;스크린샷 2021-08-10 오전 12 00 14&quot; src=&quot;https://user-images.githubusercontent.com/31889335/128728072-55752539-599d-4fca-9a38-7bc37d9742d2.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 앱 실행(Run) 버튼 누르기 은근 귀찮다… &lt;strong&gt;control + r&lt;/strong&gt; 누르기~&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7️⃣-모든-텍스트-한-번에-변경하기&quot;&gt;7️⃣ 모든 텍스트 한 번에 변경하기&lt;a id=&quot;7&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;개발하다 보면 예를 들어, 변수 이름을 textViewTitle 에서 tvTitle로 바꾸고 싶을 때가 있을 것이다.. 클래스 내 코드 상에서 textViewTitle 변수가 한두번 작성되어 있다면 하나하나 찾아가서 바꾸면 되겠지만 만약 100번 이상 작성되어 있다면? 어떻게 100개를 다 tvTitle로 하나하나 고치고 앉아있을까..?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;command + shift + r&lt;/strong&gt; 로 한 번에 바꾸자!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img width=&quot;498&quot; alt=&quot;스크린샷 2021-08-10 오전 12 07 22&quot; src=&quot;https://user-images.githubusercontent.com/31889335/128729194-6ff8f451-155b-4358-ba97-a0362901ec6f.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 빨간 박스 안의 윗 줄이 바꾸기 전 문자열이고, 아래 줄이 바꾼 후 문자열이다. 즉, 윗 줄의 문자열을 아래 줄의 문자열로 대체(replace)한다는 의미이고 왼쪽 하단 버튼 중 Replace All을 누르면 모두 한 번에 바뀐다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝-아님-&quot;&gt;끝 아님 ~&lt;/h1&gt;

&lt;p&gt;계속 추가 중 ..&lt;br /&gt;
마지막 수정일 : 2021년 8월 10일&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-07/android-studio-keyboard-shortcut</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/android-studio-keyboard-shortcut</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 안드로이드 프로젝트 구조(Android Project Structure)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/projects?hl=ko&quot;&gt;Android Developers Document - 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;#0&quot;&gt;0. 프롤로그&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;1. 안드로이드 스튜디오에서 프로젝트 구조 보는 두 가지 방법&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;2. 안드로이드 프로젝트를 이해하려면 모듈을 알아야 한다&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;a id=&quot;0&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;지인 개발자가 개발한 안드로이드 프로젝트를 구경하던 중,, 프로젝트 구조가 신기하게 생긴 것을 보게되었다! 프로젝트 구조에서 app 폴더와 같은 depth에 다른 폴더들이 있는 구조였다. 찾아보니 &lt;strong&gt;라이브러리 모듈&lt;/strong&gt; 이라는 것이었고, 이참에 안드로이드 프로젝트 구조를 공부해서 남겨본다 :)&lt;br /&gt;
&lt;img width=&quot;292&quot; alt=&quot;스크린샷 2021-07-05 오후 9 10 54&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124469604-88edf200-ddd5-11eb-8190-dcec8cf496e0.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-안드로이드-스튜디오에서-프로젝트-구조-보는-두-가지-방법&quot;&gt;1️⃣ 안드로이드 스튜디오에서 프로젝트 구조 보는 두 가지 방법&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Android Studio에서 프로젝트 구조를 볼 수 있는 방법은 두 가지이다. &lt;strong&gt;Android 뷰로 보기&lt;/strong&gt; 와 &lt;strong&gt;Project 뷰로 보기&lt;/strong&gt; 이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android 뷰로 보기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/124470178-42e55e00-ddd6-11eb-9b74-ec18f0196eac.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 하늘색 박스 부분을 Android로 선택해주면, Android 뷰로 프로젝트 구조를 확인할 수 있다. 어떤 프로젝트를 Android Studio로 실행하면 기본적으로 해당 프로젝트의 구조를 Android 뷰로 보여준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;292&quot; alt=&quot;스크린샷 2021-07-05 오후 9 10 54&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124471474-db301280-ddd7-11eb-8c48-814b7064e1a2.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) Android 뷰로 프로젝트 구조를 보게 되면, 해당 프로젝트가 컴퓨터에 연결된 디스크에 실제로 저장되는 구조(계층)와는 다르게 보인다. 하지만 가장 상위 폴더가 모듈별로 보여지기 때문에 프로젝트 구조를 한 눈에 보기 쉬운 장점이 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android 뷰로 프로젝트 구조를 볼 때의 특징은 프로젝트의 모든 빌드 관련 구성 파일을 &lt;strong&gt;Gradle Scripts&lt;/strong&gt; 라는 최상위 폴더로 묶어서 보여준다는 것이다. 하지만 실제 디스크 상에서는 이렇게 묶여있지 않다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;292&quot; alt=&quot;&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124473428-4844a780-ddda-11eb-829f-2a48464b6266.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 또한 앱 런처 아이콘의 여러 밀도별 대체 리소스가 ic_launcher.png 그룹에 묶여서 보여지는 것처럼, Android 뷰에서는 하나의 파일당 여러 대체 리소스 파일이 존재할 경우 하나의 그룹에 넣어서 보여준다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Project 뷰로 보기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;239&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/124474975-23513400-dddc-11eb-9189-7298220c9e64.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 하늘색 박스 부분을 Project로 선택해주면, Project 뷰로 프로젝트 구조를 확인할 수 있다. Android 뷰에서 편의상 숨겨진 모든 파일을 모두 보여주고, 실제 디스크에 저장되는 프로젝트 구조로 보여준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Project 뷰에서의 빌드 구성 파일은 하나의 폴더로 묶여있지 않다. App의 빌드 구성 파일은 App 폴더 안에 있으며, 프로젝트 전체의 빌드 구성 파일은 App 폴더와 같은 depth에 위치한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-안드로이드-프로젝트를-이해하려면-모듈을-알아야-한다&quot;&gt;2️⃣ 안드로이드 프로젝트를 이해하려면 모듈을 알아야 한다&lt;a id=&quot;2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;What is 모듈(Module)?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;모듈은 소스 파일과 빌드 구성 파일 등으로 구성된 모음집(Collection)이다. 따라서 Project 뷰로 프로젝트 구조를 보았을 때, app 폴더 하위에는 소스 파일과 빌드 구성 파일이 모두 포함되어 있었으므로 app 폴더도 하나의 모듈이 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 모듈을 통해 하나의 프로젝트를 기능 단위로, 여러 개로, &lt;strong&gt;분할&lt;/strong&gt; 할 수 있게 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;하나의 프로젝트에는 여러 개의 모듈이 포함될 수 있고, 어떤 하나의 모듈이 다른 모듈을 종속 항목으로 사용할 수도 있다. 또한 각 모듈은 개별적으로 빌드하고 테스트, 디버그할 수 있다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;특히, Android Studio에서는 3가지의 서로 다른 Module Type(유형)을 지원한다. -&amp;gt; app 모듈, feature 모듈, library 모듈&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;app 모듈&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;app 모듈은 앱의 소스 코드, 리소스 파일, 빌드 구성 파일, Android Manifest 파일 등을 포함하고 있는 모듈이다. Android Studio에서 새로운 프로젝트를 만들면 기본적으로 app 모듈이 자동으로 생성된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;feature 모듈&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;feature 모듈은 Google Play에서 지원하는 &lt;a href=&quot;https://developer.android.com/guide/app-bundle/play-feature-delivery?hl=ko&quot;&gt;Play Feature Delivery&lt;/a&gt; 를 사용할 수 있는 모듈이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Play Feature Delivery를 간단히 설명해보자면.. 예를 들어, 결제 기능이 있는 앱에 feature 모듈로서 결제 모듈을 만들어 놓았다고 하자. 이 앱을 사용하는 어떤 사용자는 앱을 사용하긴 하지만 유료로 무언가를 결제하지는 않는 성향의 사용자일 수 있다. 또 다른 사용자는 이 앱에서 유료로 무언가를 결제까지 하는 사용자일 수 있다. 이런 경우, Play Feature Delivery를 활용하면 첫 번째 사용자에게는 결제 모듈을 제공하지 않고, 두 번째 사용자에게만 결제 모듈을 제공한다. 즉, 첫 번째 사용자는 사용하지도 않을 결제 모듈을 다운받게 되는 불상사를 당하지 않게 되어 다운로드 받을 총 apk 크기를 줄이는 효과를 얻을 수 있다!&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;library 모듈&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;library 모듈은 구조적으로 app 모듈과 동일한 모듈이다. 그러나 사용 목적이 다른데, library 모듈은 app 모듈에서 종속 항목으로 사용하기 위한 모듈이기도 하고 프로젝트1과 프로젝트2에서 공통으로 사용해야 하는 코드를 library 모듈로 만들어서 어떤 프로젝트에서든지 재사용할 수 있는 코드를 제공하기 위한 모듈이기도 하다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;library 모듈의 중요한 특징은 빌드될 때 APK로 만들어지는 것이 아니라 code archive 파일로 만들어지기 때문에 library 모듈을 안드로이드 기기에 설치할 수는 없다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android 프로젝트에 적용할 수 있는 library 모듈은 또 두 가지 종류로 나뉘는데 Android Library와 Java Library이다. 이 둘에 대해서는 나중에 조금 더 자세히 알아보기로 하고 일단 넘어가자 ㅎㅎ..&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:my-library-module&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(위 코드 참고) 위에서 알아본 &lt;strong&gt;모듈&lt;/strong&gt; 이라는 것을 &lt;strong&gt;하위 프로젝트(sub-project)&lt;/strong&gt; 라고도 부른다. 따라서 Gradle 설정에서도 모듈을 프로젝트로 취급한다. 예를 들어, 라이브러리 모듈을 생성하고 app 모듈의 종속 항목으로 추가할 때는 위와 같은 코드를 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝-&quot;&gt;끝 ~&lt;/h1&gt;

&lt;p&gt;이렇게 공부해보니.. 지인의 프로젝트 구조에는 여러 개의 library 모듈이 포함되어 있는 것이였다! :)&lt;br /&gt;
마지막 수정일 : 2021년 7월 5일&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-07/android-project-structure</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-07/android-project-structure</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[독서] 훌륭한 프로그래머 되는 법(3편)</title>
        <description>&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://choheeis.github.io/newblog//articles/2021-04/becoming-a-better-programmer-2&quot;&gt;훌륭한 프로그래머 되는 법(2편)&lt;/a&gt; 에 이어 쓰는 포스팅!&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-테스트-라는게-무엇일까&quot;&gt;1️⃣ ‘테스트’ 라는게 무엇일까.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;사람들은 TDD(Test-Driven Development)라는 용어를 사용하며 테스트 코드를 짜야한다고 말한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 테스트가 대체 뭔가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테스트 = 프로그램에 대한 사용자 피드백을 예측하는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예를 들어, 사용자가 실 서비스를 사용하다가 버그를 발견하거나 불편한 점을 발견하면 서비스 리뷰에 피드백을 남길 수도 있고, 개발자에게 직접 메일을 보내 고쳐달라고 요청할 수도 있다. 이렇게 사용자에게 직접 피드백을 받는 경우도 많다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그런데 대부분 회사에는 QA팀이 있어서 서비스 배포 전에 QA팀이 먼저 버그를 발견하거나 정상적으로 작동하는지 점검한다. 즉, 서비스를 테스트해본다는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 개발자는 QA팀에게 자신의 코드가 넘어가기 전에 먼저 본인이 직접 테스트 해보는 경우도 있다. 테스트용 브랜치를 따서 여러가지 테스트를 해볼 것이다. 예를 들어, 어떤 상황에서도 함수의 결과 값이 올바른가? 네트워크가 불안정한 상황에서 UI에 보이는 데이터가 불편하지 않은가? 등을 직접 테스트해볼 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위와 같은 것들을 모두 ‘테스트’ 라고 하는 것이다!!!!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-테스트를-자동화할-수-없을까&quot;&gt;2️⃣ 테스트를 자동화할 수 없을까?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위에서 언급한 테스트들은 뭔가 수동적인 느낌이 난다,,! 직접 에러가 나는 상황에 대비하기 위해 테스트를 하는 건데~.~ 이런 걸 자동으로 할 수 없을까? 라는 생각에서 나온 것이 바로 &lt;strong&gt;테스트 코드를 작성&lt;/strong&gt; 하여 &lt;strong&gt;자동으로 테스트&lt;/strong&gt; 를 하는 작업이다!!! (아 헐 이렇게 이해하니까 테스트 자동화가 필요한 이유를 알겠다!.!!.!)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자동화된 테스트는 기존에 사람이 직접 했던 테스트 작업을 컴퓨터가 빠르고 반복적으로 대신 수행해주는 것과 같은 것!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-테스트에도-종류가-있음&quot;&gt;3️⃣ 테스트에도 종류가 있음~&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;유닛 테스트, 통합 테스트, 시스템 테스트!!! (판교뚜벅쵸님 유튜브 보면서 통합 테스팅에 대해서 들어봤던 거 같음ㅋㅋㅋ)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;유닛 테스트(Unit Test)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;유닛 = 가장 작은 단위의 기능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;유닛 테스트 = 가장 작은 단위의 기능이 잘 작동하는지 테스트&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;각각의 함수 또는 클래스가 정확히 작동하는지 확인하기 위한 테스트다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;유닛 테스트는 가장 작은 단위의 기능에 대한 테스트이므로 외부에 접속하는 기능을 테스트하면 안된다. 즉, 테스트 시 데이터베이스와 네트워크, 파일 시스템 등에 연결된 기능을 테스트하는 건 아니라는 것.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;보통 유닛 테스트를 위한 테스트 코드는 xUnit 형태의 프레임워크를 이용하여 작성된다. 모든 언어와 환경에는 이런 형태의 프레임워크가 있을 것이다!!&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;통합 테스트(Integration Test)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;유닛 테스트에서 테스트했던 단위들을 더 큰 집합으로 통합하여 작동했을 때 생기는 문제를 테스트하기 위한 테스트!!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;통합 테스트를 통해 통합된 단위 요소들이 서로 잘 통합되어 있고 정확히 상호 작용하며 작동하는지 확인할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;통합 테스트도 보통 유닛 테스트와 같이 어떤 프레임워크를 사용하여 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사실 통합 테스트는 테스트 대상이 하나 이상의 객체들이 모여있는 집합을 테스트하는 것이라서 많은 사람들이 유닛 테스트라고 부르며 하는 테스트가 통합 테스트인 경우가 있다.(아~ 오케이)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시스템 테스트(System Test)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;종단 간 테스트(end-to-end test)라고도 부르는데 시스템의 시작점에서 끝점을 치고 다시 시작점으로 돌아오는 것에 대한 테스트이다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;예를 들면, 어떤 배달 어플의 분식 메뉴 중 하나를 주문하여 결제 후, 결제 완료 화면이 보이는 과정을 처음부터 끝까지 테스트하는 것이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;따라서 시스템 테스트는 서비스의 기능 수에 따라 범위가 넓어서 전체 테스트를 수행하는데 많은 시간이 걸리기도 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;테스트를 위해 많은 네트워크 트래픽이 유발되거나 느린 데이터 베이스 접속이 필요할 수도 있음!&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마지막 수정일 : 2021/06/18&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-06/becoming-a-better-programmer-3</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-06/becoming-a-better-programmer-3</guid>
        
        
        <category>books</category>
        
      </item>
    
      <item>
        <title>[독서] 훌륭한 프로그래머 되는 법(2편)</title>
        <description>&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://choheeis.github.io/newblog//articles/2021-03/becoming-a-better-programmer-1&quot;&gt;훌륭한 프로그래머 되는 법(1편)&lt;/a&gt; 에 이어 쓰는 포스팅!&lt;/p&gt;

&lt;p&gt;이 책을 읽다보니 느낀 점은.. 번역본이라 한글 번역이 약간 어색한 부분들이 많다. 예를 들면 “청결은 감염을 막는다” 라는 문장이 있는데 ‘버그가 있으면 방치하지 말고 최대한 빨리 해결하라’ 라는 뜻으로 쓰여진 문장이다 ㅎㅎ 후,,&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-hoxy-오래전에-작성한-너의-코드를-방치하고-있니&quot;&gt;1️⃣ Hoxy,, 오래전에 작성한 너의 코드를 방치하고 있니?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;개발자들은 발전을 위해 노력하는 경향이 많은 사람들이다. 그래서 &lt;strong&gt;새로운 도전&lt;/strong&gt; 에 뛰어들고, &lt;strong&gt;더 흥미로운 문제를 해결&lt;/strong&gt; 하고, &lt;strong&gt;새로운 기술을 배우는 것&lt;/strong&gt; 에 관심을 갖는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하지만 보통의 개발자들은 &lt;strong&gt;오랜 시간 동안 자신이 작성한 코드를 관리하지 않는 경향이 있다!!&lt;/strong&gt; (뜨끔,,)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작가님 왈 ) 보통의 개발자는 자신이 싼 똥을 치우지 않고 남의 똥을 치우거나 새로운 똥을 싸려고 한다..&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애정 가득했던 프로젝트도 기간이 끝나거나 흥미가 사라지면 방치하는 경향이 있다..&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자신의 오래된 코드를 지속적으로 들여다보고 개선하는 것은 또 다른 새로운 경험을 가져다 줄 것!.!.! (예를 들어 새로운 라이브러리가 등장하여 이제는 직접 코드 구현을 할 필요가 없는 부분을 발견할 수도 있다~)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예전에 작성했던 코드를 보면서 ‘내가 이 때 무슨 생각으로 이렇게 작성했을까?’, ‘그냥 내장 라이브러리 함수 사용하면 되는데 이걸 직접 짰다고?’, ‘더 깔끔한 API를 만들 수 없었나?’, ‘이걸 클라이언트에게 관리하도록 했단 말이야?’ 등의 질문을 스스로에게 하면서 자신이 성장했음을 알 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존의 코드를 돌아보는 것은 &lt;strong&gt;자신을 위한 코드 리뷰&lt;/strong&gt; 이자 &lt;strong&gt;가치 있는 행동&lt;/strong&gt; 이다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-프로젝트에-중간-투입될-경우-적응하기-위해-해야할-것들&quot;&gt;2️⃣ 프로젝트에 중간 투입될 경우 적응하기 위해 해야할 것들!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;새로운 개발자가 팀에 투입되는 경우는 많다. 새로운 개발자는 기존의 프로젝트의 코드를 둘러볼 계획을 어떻게 세워야 할까?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;적응을 위해서는 다음과 같은 작업들을 빠르게 해내야 한다!&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;코드의 어느 부분부터 보아야 하는지 파악하기&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;코드의 부분별 기능을 알아내고, 그 기능을 어떻게 수행하고 있는지 살펴보기&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;코드의 품질을 가늠하기&lt;/strong&gt; (코드의 품질을 왜 가늠해보아야 하지..? 약간 이 프로젝트에 내 코드가 녹아들게 하려면 이 정도 코드 퀄리티는 나와줘야 하는구나.. 라고 생각하는건가)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;시스템 내부를 어떻게 탐색할 것인지 계획하기&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;코딩 관례를 이해하고, 본인의 수정 사항이 그것과 어울리도록 만들기&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;테스트 코드 및 이미 작성되어 있는 문서 등 살펴보기&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하지만 만약 기존의 코드를 잘 알고 있는 누군가와 함께 일을 한다면 물어보기를 주저하지 말자!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-오류-및-경고-무시하지-않기&quot;&gt;3️⃣ 오류 및 경고 무시하지 않기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;가끔 개발자들은 귀차니즘에 의해 오류나 경고를 무시하고 고치지 않는 경우가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하지만 오류나 경고는 그때 그때 해결해 놓아야 나중에 큰 문제를 일으키지 않고 더욱 복잡한 오류가 발생하지 않을 것!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4️⃣-예상치-못한-것을-예상해내는-능력-키우기&quot;&gt;4️⃣ 예상치 못한 것을 예상해내는 능력 키우기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드 작성시 예상되는 상황에 대한 대비만으로는 부족하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 단계에서 조금이라도 발생할 가능성이 있는 특이 사항들은 모두 고려한다는 마인드를 갖자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수가 예상대로 작동하지 않을 경우 오류 코드를 반환하도록 하고, 해당 함수를 호출하는 부분에서는 항상 반환 값을 확인하게 하자.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5️⃣-코드를-작성하고-있다면-버그를-만들고-있는-것&quot;&gt;5️⃣ 코드를 작성하고 있다면 버그를 만들고 있는 것!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머가 코드를 작성한다. 하지만 프로그래머는 사람인지라 완벽하지 않고, 프로그래머의 코드 역시 완벽하지 않다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;즉, 프로그래머가 코드를 작성하면 무조건 버그가 생긴다. 만약 더 나은 프로그래머가 나타난다면 더 나은 버그를 키워낼 뿐이다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;버그를 피할 수 있는 가장 좋은 충고는 &lt;strong&gt;영리한 코드를 만들지 말라&lt;/strong&gt; 는 것! (영리한 코드? 왜 이렇게 말을 어렵게 써놓았어…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;왜냐? 영리한 코드는 디버깅도 힘들기 때문.. (아 걍 있어보이는 코드 짜려고 하지 말고 남이 봤을 때도 이해하기 쉬운 코드를 짜라는 거군)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“미련한 프로그래머는 컴퓨터가 이해할 수 있는 코드를 만들고, 좋은 프로그래머는 사람이 이해할 수 있는 코드를 만든다!”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6️⃣-예리한-도구-배우기에-시간을-투자해라&quot;&gt;6️⃣ 예리한 도구 배우기에 시간을 투자해라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예리한 도구란… 예를 들어, 메모리를 확인해주는 도구나 디버거 같은 도구를 말한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;즉, 코드 짤 때 도움을 주는 사이드 프로그램을 잘 사용할 줄 알아야 한다는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 맨 처음 다루게 되어 이미 익숙해진 도구에만 전적으로 의존하지도 말자. 세상은 항상 더 성능 좋고 편리한 것들이 나오기 때문!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7️⃣-오류-해결이-안-된다고-끙끙대지-말고-쉬어가자&quot;&gt;7️⃣ 오류 해결이 안 된다고 끙끙대지 말고 쉬어가자&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;작업이 더 이상 진전이 없어 끙끙대고 있다고 느껴지면 작업을 멈추고 아래와 같은 것들을 하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;문제에 대해 글 또는 말로 서술해보기&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;코드 구조를 생각해보기&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;문제를 다른 사람 또는 아무 물건에게 설명해보기&lt;/code&gt; -&amp;gt; 다른 사람한테 설명하다보면 동시에 자신에게도 설명하게 되면서 해결 방법이 떠오를 수 있다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마지막 수정일 : 2021/06/18&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-04/becoming-a-better-programmer-2</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-04/becoming-a-better-programmer-2</guid>
        
        
        <category>books</category>
        
      </item>
    
      <item>
        <title>[독서] 훌륭한 프로그래머 되는 법(1편)</title>
        <description>&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112961151-0fb08480-9180-11eb-8149-1487cdf20431.png&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원래 취미가 진짜 없는 사람인데 요새 그나마 생긴 취미가 독서다! 소설보다는 자기계발서나 관심있는 분야에 대한 책을 좋아한다. 훌륭한 프로그래머 되는 법이라는 책은 남자 친구네 집에 있길래 몇 장 넘겨보고 맘에 들어서 읽어보려 가져왔다 ㅋㅋㅋㅋ&lt;/p&gt;

&lt;p&gt;아무래도 개발 서적이기 때문에 나에게 적용하면 좋은 것이나 감명 받은 것들이 있다면 블로그에 기록해보려고 한다! 대신 책의 모든 내용을 요약하지는 않을 것이다.🌟 (이 포스팅은 ‘나’에게 하는 말을 거는 것처럼 아주 자유로운 말투로 쓸 예정이다.)&lt;/p&gt;

&lt;p&gt;포스팅 내용에 포함된 코드는 모두 코틀린으로 작성한 것~&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-코드에-신경-좀-써&quot;&gt;1️⃣ 코드에 신경 좀 써!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드 작성할 때 내가 작성한 코드가 좋은 코드인지 고민해 본 적… 있어? 있긴 하지만 솔직히 이 정도면 괜찮지 않나? 라고 귀찮아서 근거 없이 넘어갈 때 많았지^^.. 이 책에서는 좋은 코드를 작성하는 개발자가 좋은 개발자래. 하지만 좋은 코드는 그냥 뚝딱하고 작성되는게 아니라 &lt;strong&gt;개발자가 코드에 엄청난 노력과 신경, 관심을 들여야 좋은 코드를 작성할 수 있는 거래.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 개발자는 실제로 기술적인 역량이 뛰어나지만 막상 작성하는 코드는 읽기도 어렵고 사용하기도 어렵고 수정하기도 어렵게 작성하는 사람이 있대. 반면 또 어떤 개발자는 기술적인 역량은 부족하지만 그 사람이 작성한 코드는 훌륭하고 표현력이 넘쳐서 함께 일하기 쉬운 경우도 있대.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 두 개발자의 차이는 &lt;strong&gt;태도&lt;/strong&gt; 였대. 좋은 코드를 작성하는 개발자는 회사에 존재할 수 있는 여러 가지 제약, 압박 속에서도 &lt;strong&gt;프로다운 접근 방식을 취하고 최고의 코드를 작성하려는 태도&lt;/strong&gt; 를 가지고 있었대.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 &lt;strong&gt;좋은 코드란 뭘까?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;의도가 드러나는 코드가 좋은 코드래. 즉, 다른 개발자들이 내가 작성한 코드를 보고 쉽게 이해할 수 있어야 한다는 거지. 자신이 작성한 코드를 다른 사람이 보았을 때 자신이 개쩌는 개발자라고 생각하도록 어렵고 복잡한 코드를 작성한다? 글러먹은거야.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;유지 보수가 가능한 코드가 좋은 코드래. 다른 개발자들이 코드를 쉽게 수정할 수 있어야 한다는 거야.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내가 짠 코드를 사용해야 하는 다른 사람의 입장이 되어보자. 어려운 문법, 복잡한 로직으로 구현된 코드를 보고 어떤 생각을 할까? 와.. 이 개발자 알고 있는거 엄청 많네? 진짜 GOD이다.. 라고 생각할까? ㄴㄴㄴ 아니 이 코드 뭔 소리야? 왜 이렇게 복잡하게 짠거지? 뭐야 대체? 라고 생각하는 사람이 대부분일거야. 즉, 코드만 보고도 사람들은 감정적 반응을 한다는 거지. 따라서 훌륭한 코드를 자랑스러워하거나 더러운 코드에 혐오감을 느끼는 것은 아주 당연한 현상이야!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-정돈된-코드-유지하기&quot;&gt;2️⃣ 정돈된 코드 유지하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;정돈된 코드를 유지하라는 것은 &lt;strong&gt;눈으로 코드나 파일을 딱 봤을 때 외관상 정돈되어 있다는 느낌&lt;/strong&gt; 을 줘야 한다는 거야! 좀 더 자세히 말해보자면 ‘코드의 레이아웃’을 깔끔하게 유지하라는 것이고 탭이나 스페이스를 &lt;strong&gt;‘일관성있게’&lt;/strong&gt; 사용하면 어느 정도 정돈된 느낌을 줄 수 있지.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 개발자가 정돈된 코드를 유지하는데 신경을 쓰지 않는다? 즉, 이 개발자가 작성한 코드는 코드 레이아웃이 일관적이지 않고 자기 맘대로 파일마다 또는 몇 줄 간격으로 코드 레이아웃의 모양이 바뀐다면 그 개발자는 코드 레이아웃 뿐 아니라 코드 품질에도 당연히 신경쓰지 않는 개발자일 가능성이 커.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정돈된 코드를 유지해야 하는 이유는 코딩이라는 것이 ‘내 코드를 봐주고 고쳐줄 다른 사람을 위해’ 하는 작업이기 때문이야. 나만 보는게 아니라고!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정돈된 코드에는 주석의 레이아웃도 포함될 수 있어. 아래와 같은 주석이 있다고 해보자. 눈으로 보기 깔끔하고 이쁘니까 좋은 레이아웃일까?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*********************************************************&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;우리의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;주석&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;스타일입니다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;                                     &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;다른&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;분들도&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;주석을&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;쓸&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;때는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;레이아웃을&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;지켜주세요&lt;/span&gt;                 &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;다들&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;해피코딩&lt;/span&gt;                                              &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이렇게&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;기호로&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이쁘게&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;꾸미는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;행위를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'아스키아트'라고&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;해요&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;....&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;하지&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;말것&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;**********************************************************/&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분명 정돈된 코드를 유지해야 하는 이유가 내 코드를 봐주고 고쳐줄 다른 사람을 위해 코딩하기 때문이라고 했다! 위와 같은 주석 레이아웃을 사용하기로 했다면 다른 개발자도 주석 스타일을 위와 같이 써야한다는 것인데 이 주석 레이아웃은 주석 내용의 길이에 따라 * 개수를 수동적으로 맞춰줘야 하기 때문에 은근히 짜증나는 주석 스타일이다. 즉, 보기에만 좋지 유지 보수에는 노동적인 스타일이다….!!!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 주석 레이아웃을 쓰자고 하는 사람은 다른 동료 개발자의 시간과 마음을 중요하게 생각하는 사람이 아닐 것ㅠㅠ(인성…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정돈된 코드 레이아웃의 최종 목적은 &lt;strong&gt;코드를 훑어보는 것만으로도 전체 형태와 구조를 파악할 수 있게 하는 것&lt;/strong&gt; 이다! 그럼 어떻게 코드를 작성해야 정돈된 코드 레이아웃을 만들 수 있는걸까?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113166622-e70eb480-927d-11eb-95f3-29c75935ce2a.png&quot; alt=&quot;02&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림 참고) 함수 안에서는 ‘문단’을 나누듯이 서로 연관성이 없는 코드 사이에 빈줄을 넣어 구분해주자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;또 내 코드를 읽는 사람의 입장을 고려해보면 그 사람은 빠른 시간 내에 내 코드에서 중요한 것을 캐치하거나 자신이 사용할 만한 것을 발견하고 싶어할거야. 따라서 함수를 배치하는 순서도 합리적인 순서로 중요한 것부터 위에 배치하거나 private 보다 public을 위에 배치하는게 좋대! 또 함수 내에 코드가 길어지는 경우(문단이 5개 이상 넘어가는 경우)는 다섯 함수로 나누는 것이 좋대~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 레이아웃은 자신이 자주 사용하거나 익숙한 스타일이 있을 수도 있지만 다른 사람과 협업을 할 때는 자신만의 코드 스타일을 고수해서는 절대 절대 안돼!!! 다른 동료 개발자들과 합의된 동일한 코드 레이아웃을 지키자. 이러기 위해서는 팀 전체의 소스 코드 편집기를 같은 환경으로 설정하는게 가장 좋긴해.(소스 코드 편집기의 탭 사이즈, 괄호와 주석 형태 등을 동일하게 설정하는 거지!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-훌륭하게-이름-짓기&quot;&gt;3️⃣ 훌륭하게 이름 짓기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;개발자들이 이름을 지어야 하는 상황에는 어떤 것들이 있을까? &lt;strong&gt;프로젝트 이름, 변수 이름, 함수 이름, 클래스 이름, 인터페이스 이름, API 이름, 파일 이름, 패키지 이름 등&lt;/strong&gt; 다양한 상황에서 이름을 고민하게 될거야.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이름은 &lt;strong&gt;사물의 정체성을 의미&lt;/strong&gt; 한다는 것을 잊지마렴^^! 즉, 이름을 통해 사물을 설명하고, 행위나 사용법을 나타냄으로써 해당 사물의 정체를 밝히는 것! 따라서 사물의 정체성에 맞지 않는 잘못된 이름을 지으면 오해를 불러 일으킬 수 있음을 기억하자!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;좋은 이름이란 뭘까? 좋은 이름은 &lt;strong&gt;서술적이고, 정확하며 관용적이어야 해&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관용적인 이름들(=오랜 시간 동안 비슷하게 사용되어 규칙화 된 것들)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;보통 첫 글자가 대문자로 된 이름은 자료형을 나타내거나 클래스 이름에 쓰여왔다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;첫 글자가 소문자로 된 이름은 함수 이름이나 변수 이름에 쓰여왔다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;훌륭하게 이름을 짓기 위해서는 끊임없이 이름에 대해 피드백을 받는 것이 좋다. 피드백을 받으며 경험을 쌓으면 된다!! 또한 지속적으로 다른 사람이 작성한 코드를 읽는 것도 도움이 많이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개인적으로 선호하는 이름 스타일이 아니더라도 프로젝트의 공통 관습을 따르는 것이 best~~!! 다만, 어떤 스타일이 왜 좋은지에 대해서는 개인적인 의견을 갖고 있는 것이 깐지,,&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4️⃣-조건문은-논리적으로-간결하게-작성할-수-있다&quot;&gt;4️⃣ 조건문은 논리적으로 간결하게 작성할 수 있다!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// express는 boolean 형 변수입니다.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;express&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) 위와 같은 코드는 아래와 같이 더 단순하고 직관적으로 변경할 수 있다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;express&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2번째 코드가 더 단순한 건 알겠다. 근데 왜 더 직관적이라고 하는 걸까? 코드라기보다는 &lt;strong&gt;영어 문장처럼 보여서&lt;/strong&gt; 편하게 읽을 수 있기 때문! 또한 boolean 값은 1비트(true면 1, false면 0)인데 첫 번째 코드처럼 작성했을 땐 컴파일러가 express가 1인지 0인지를 판단해야 하지만 두 번째 코드처럼 작성하면 &lt;strong&gt;컴파일러는 1비트도 신경 쓰지 않게&lt;/strong&gt; 되기 때문!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;something&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) 위와 같은 코드는 아래와 같은 표현이 더 낫대&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// false 일 경우
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조건문을 작성할 때는 논리적인 생각을 하면 할수록 더욱 간결한 코드를 짤 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// 고릴라가 배고프고, 동시에 바나나가 익어있는 경우 true 반환하는 함수
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shouldWePickBananas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gorillaIsHungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bananasAreRipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(위 코드 참고) 위 코드는 조건문이 여러 개 들어있는 코드이므로 조금 더 논리적인 생각을 해보자! 그럼 아래와 같이 정말 간결해진 코드를 작성할 수 있다~~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shouldWePickBananas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gorillaIsHungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bananasAreRipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(위 코드 참고) 그리고 언어에서 삼항 연산자가 제공된다면 &lt;strong&gt;써라!&lt;/strong&gt; 조건문의 길이를 줄여주고 심지어 더욱 직관적일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5️⃣-리팩토링이라는-용어의-잘못된-사용-예시&quot;&gt;5️⃣ 리팩토링이라는 용어의 잘못된 사용 예시&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;‘리팩토링(Refactoring)’&lt;/strong&gt; 이라는 용어는 1990년대에 프로그램 개발 분야에 처음 등장했고, 그 이후로 많이 사용되는 용어다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리팩토링이라는 용어의 의미는 &lt;strong&gt;‘결과의 변경 없이 기존 코드의 구조를 재조정하는 것’&lt;/strong&gt; 이다. 즉, 리팩토링은 작동은 그대로 유지한 채 소스 코드만 수정하는 것을 가리킨대.(오…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램의 작동 방식을 바꾸는 것은 리팩토링이 아니라 ‘개선’이라고 해야 정확한 용어로 대화할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6️⃣-약간-다르지만-비슷한-코드가-있다-하나의-함수로&quot;&gt;6️⃣ 약간 다르지만 비슷한 코드가 있다? 하나의 함수로!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;코드의 중복&lt;/strong&gt; 은 최악의 코드다! 왜? 만약 어떤 코드가 버그를 품고 있는 코드임이 밝혀졌고, 이 코드를 여러 다른 곳에서 중복하여 사용하고 있는 경우.. 버그가 사방 팔방 널려있는 것과 똑같기 때문!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러나 만약 여러 곳에서 사용되는 똑같은 코드를 하나의 함수로 만들어 놓았고, 필요한 곳에서는 이 함수 호출을 통해 사용하고 있다면? 함수 안의 코드만 고치면 되고 다른 곳의 수정은 필요하지 않다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;약간 다르지만 비슷한 코드가 있다면, &lt;strong&gt;일단 하나의 함수로 만들고 다른 부분은 매개변수로 전달하여 매개변수에 따른 분기 처리를 해주자.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드의 중복은 지금 내가 작성하려는 코드가 어딘가에서 이미 쓰여진 코드인지 모르는 경우 때문에 발생하기도 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7️⃣-좋은-주석--주석을-달지-않는-것&quot;&gt;7️⃣ 좋은 주석 = 주석을 달지 않는 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;좋은 코드&lt;/strong&gt; 는 작동법을 설명하는 &lt;strong&gt;주석 조차 필요로 하지 않는다.&lt;/strong&gt; 변수 이름, 함수 이름, 클래스 이름, 매개 변수 이름 등이 올바르다면 주석을 달 필요가 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주석을 달아야 코드에 가치가 더해진다고 생각하나? 진~짜 잘못된 생각이니까 고쳐먹어라!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 경우에는 뭔가 필요할 것 같은 코드, 대체될 수 있을 것 같은 코드를 주석 처리해 놓는 경우가 있다. 절대 하지 말아야 하는 행동이다.. 왜? 나는 이 코드에 자신이 없다는 소리이기 때문. 이 코드가 문제가 생긴다면 주석 처리된 코드를 사용할 것이라는 심리가 반영되어 있다는 것!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8️⃣-변수를-선언하기-좋은-위치&quot;&gt;8️⃣ 변수를 선언하기 좋은 위치&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;옛날 C언어 스타일을 안다면.. 모든 변수를 맨 상단에 모두 선언해놓고 나중에 가져다 쓰는 방식을 알 것이다. (나도 C나 C++로 알고리즘 문제 풀 때 무조건 이렇게 했음,,,ㅠ,,) 이런 스타일은 요즘 시대로 보면 옛날 방식~!! &lt;strong&gt;세상이 추구하는 코드 스타일이 변하면 내 코드 스타일도 따라서 변해야 한다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;isCheck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 선언 부분
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isCheck&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 정의 부분
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(위 코드 참고) 변수 선언 부분과 정의 부분을 같은 위치에 쓰자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝&quot;&gt;끝!&lt;/h1&gt;

&lt;p&gt;마지막 수정일 : 2021/04/11&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-03/becoming-a-better-programmer-1</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-03/becoming-a-better-programmer-1</guid>
        
        
        <category>books</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 안드로이드가 뭐예요?(Android, Android Platform, Android Framework)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=110015332&quot;&gt;책 - 안드로이드 프로그래밍 Next Step&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://source.android.com/&quot;&gt;Android Open Source 사이트 - 안드로이드란 무엇인가&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/platform?hl=ko&quot;&gt;Android Developers 사이트 - Android 플랫폼 아키텍처&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QBGfUs9mQYY&quot;&gt;Android Youtube 영상 - Android Architecture 개요&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C_(%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C)&quot;&gt;위키백과 - Android(운영체제)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;저는 안드로이드 앱 개발의 첫 시작은 ‘안드로이드가 무엇인가?’를 아는 것부터 시작해야 한다고 생각하는 사람 중 하나입니다. 하지만.. 저는 ‘안드로이드가 무엇인가?’ 보다는 안드로이드 앱을 만드려고 하는데 ‘텍스트 뷰는 어떻게 만드는가?’ 부터 공부했던 것 같습니다..&lt;/p&gt;

&lt;p&gt;안드로이드 앱 개발을 시작한지 2년이 지나서야 ‘안드로이드가 무엇인가?’를 궁금해하는 이상 현상이 발생했지만 지금이라도 궁금증이 생기고 공부해보려는 의지가 생긴 것에 감사합니다^!^ 휴..&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-what-is-안드로이드android&quot;&gt;1️⃣ What is 안드로이드(Android)?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android가 무엇일까?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;350&quot; alt=&quot;01&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111596692-c6bc1000-8810-11eb-8660-22b80e59023f.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android는 휴대할 수 있는 디바이스 기기를 위한 &lt;strong&gt;오픈소스 소프트웨어 스택(Stack)&lt;/strong&gt; 입니다. 여기서 ‘스택(Stack)’이라는 것은 컴퓨터공학에서 데이터를 저장할 수 있는 구조(자료구조)의 여러 종류 중 하나입니다. 자료 구조 ‘스택’에 비유하여 Android를 ‘오픈소스 소프트웨어 스택’이라고 부릅니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;strong&gt;‘소프트웨어 스택’&lt;/strong&gt; 이라는 것에만 집중해봅시다. ‘스택’이라는 자료 구조의 모습처럼 무엇인가가 아래에서부터 위로 쌓여있는 모양에 비유했고, 쌓여있는 것이 바로 ‘소프트웨어’라는 의미입니다. 위 그림을 보면 가장 아래에 &lt;strong&gt;리눅스 커널(Linux Kernel)&lt;/strong&gt; 라는 소프트웨어가 있고, 그 위에 &lt;strong&gt;HAL/HIDL&lt;/strong&gt; 라는 소프트웨어가 쌓여있습니다. 또 그 위에는 &lt;strong&gt;Native Libraries&lt;/strong&gt; 라는 소프트웨어가 쌓여 있고 Native Libraries와 같은 층에 &lt;strong&gt;Android Runtime&lt;/strong&gt; 라는 소프트웨어가 쌓여있습니다. 그 위에 &lt;strong&gt;Android Framework&lt;/strong&gt; 라는 소프트웨어가 쌓여있고 가장 최상단에는 &lt;strong&gt;Apps(안드로이드 앱)&lt;/strong&gt; 이 쌓여있는 구조입니다. &lt;strong&gt;이 구조를 통틀어 ‘소프트웨어 스택’이라고 하며 결국 이 구조가 ‘Android’인 것입니다.&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;위에서 Android는 오픈소스 소프트웨어 스택이라고 했습니다. 소프트웨어 스택이라는 것은 바로 위 설명을 통해 이해했을 것입니다. 그렇다면 ‘오픈소스 소프트웨어 스택’라는 것은 무엇일까요? 소프트웨어 스택이 비공개가 아니라 공개되어 있다는 것입니다. 즉, 누구나 Android를 구성하고 있는 각 소프트웨어(스택의 각 층에 존재)의 소스 코드를 볼 수 있다는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;마지막으로 Android는 &lt;strong&gt;Google이 주도&lt;/strong&gt; 하여 관리하고 개발하는 오픈소스 프로젝트이기도 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;393&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111599924-2e278f00-8814-11eb-9a9a-3cc23ec7b166.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위에서 3차원 입체적인 모습으로 소프트웨어 스택을 보여준 그림을 2차원 평면으로 보면 위 그림과 같습니다. 아쉽지만 소프트웨어 스택의 각 층에 존재하는 소프트웨어(Apps, Android Framework, Native Libraries 등등)에 대해서는 이 포스팅에서 다루지 않을 예정입니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android vs Android 플랫폼 vs Android 프레임워크 vs Android 운영체제 vs Android 시스템&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;‘Android’, ‘Android 플랫폼(Platform)’, ‘Android 프레임워크(Framework)’, ‘Android 운영체제(OS)’, ‘Android 시스템’ 이 5가지 용어가 혼동될 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;먼저 &lt;strong&gt;Android와 Android 플랫폼은 동일한 말&lt;/strong&gt; 입니다. 위에서 Android는 휴대할 수 있는 디바이스 기기를 위한 오픈소스 소프트웨어 스택이라고 설명했지만 이는 ‘스택’이라는 단어를 사용하여 ‘무엇인가가 쌓여있는 구조’를 더 강조한 설명입니다. 따라서 Android를 스택이라는 단어를 사용하지 않고 설명할 때는 Android는 ‘오픈소스 소프트웨어 플랫폼’이라고도 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;833&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111600486-d0e00d80-8814-11eb-93e0-1b1101012a33.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 그림의 3차원 입체 모양을 보면 위에서부터 2번째에 &lt;strong&gt;Android Framework(안드로이드 프레임워크)&lt;/strong&gt; 라는 것이 쌓여 있는 것을 볼 수 있습니다. Android Framework는 &lt;strong&gt;Java API Framework&lt;/strong&gt; 라고도 부릅니다. Android Framework는 모든 안드로이드 앱(App)들이 사용하는 toolkit 입니다. 따라서 구글에서 만든 앱이든 나 자신이 만든 앱이든 모든 앱은 같은 Java API들(=Android Framework)을 사용하여 만들어집니다. 또한 이 Android Framework는 모두 Java로 구현되어 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;289&quot; alt=&quot;04&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111603315-8f049680-8817-11eb-84ae-529217ae6602.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) ‘그래서 Android Framework가 정확히 뭔데?’라는 추가 질문이 있을 수 있습니다. 이에 답을 하기 위해 Android Framework에 속해 있는 Components(구성요소)들 중 ‘Activity Manager’라는 것에 대해 간단히 알아봅시다. ‘Activity Manager’는 앱의 수명 주기를 관리해주는 곳입니다. 즉, Activity Manager는 Activity를 생성해주고 상황에 맞게 Activity 수명 주기 콜백 메소드를 호출하여 Activity 수명 주기를 관리합니다.(개발자가 Activity의 모든 수명 주기 콜백 메소드를 ‘직접’ 호출해주지 않는 사실을 생각하면 쉽습니다. 개발자는 단지 수명 주기 콜백 메소드를 오버라이드하여 메소드 내에 작업을 추가해주는 것 뿐 입니다.) 또 ‘Activity Manager’는 ‘백 스택(backstack)’이라는 것을 관리하여 사용자가 여러 개의 서로 다른 앱(=프로세스)을 동시에 사용할 때도 자연스러운 사용 경험을 제공할 수 있도록 관리해줍니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;456&quot; alt=&quot;05&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111607265-6d0d1300-881b-11eb-8c76-48615c1e16e8.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/742a67127366c376fdf188ff99ba30b27d3bf90c/core/java/android/app/ActivityManager.java&quot;&gt;여기&lt;/a&gt;를 보면 ActivityManager의 실제 코드 구현을 볼 수 있습니다.(Android는 오픈 소스 소프트웨어 플랫폼이기 때문입니다!) ActivityManager 클래스에 구현되어 있는 moveTaskToFront() 메소드는 ‘인자로 전달된 task ID에 해당하는 task를 stack의 가장 앞으로 이동시켜 사용자의 눈에 해당 task가 보이게 하라’는 메소드입니다. 이렇듯, ActivityManager에는 Activity를 관리하는데 사용되는 모든 것들이 구현되어 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Activity Manager 외에도 Android Framework는 여러 Manager들로 구성되어 있습니다. 안드로이드 앱 개발자는 Android Framework가 제공하는 API들을 사용하여 사용법에 맞게 코드만 작성해주면 될 뿐입니다. 나머지 내부 동작들은 Android Framework의 몫입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Android 운영체제&lt;/strong&gt; 라는 말은 ‘Android’를 휴대할 수 있는 디바이스 기기(=모바일 디바이스)의 운영체제로 채택하여 사용하기 때문에 ‘Android 운영체제’라고 부르기도 합니다. 즉, Android를 운영체제라고 하는 것은 Android 플랫폼을 모바일 기기의 운영체제로 사용한다는 의미입니다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;운영체제&lt;/strong&gt; : &lt;a href=&quot;https://choheeis.github.io/newblog//articles/2020-05/OSstart&quot;&gt;이 블로그의 다른 포스팅 - 운영체제가 무엇인가&lt;/a&gt;를 보면 알 수 있듯이, 운영체제는 컴퓨터에서 하드웨어 자원(CPU, 메인 메모리 등)를 제어 및 관리하고, 사용자가 컴퓨터를 쉽게 사용할 수 있도록 편의성을 제공해주는 것입니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Android 시스템&lt;/strong&gt; 이라는 말은 Android 운영체제와 동일한 말입니다. 운영체제를 영어로 ‘Operating System’ 이라고 하기 때문에 ‘Operating’을 빼고 Android 시스템이라고 부르기도 합니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;끝&quot;&gt;끝!&lt;/h1&gt;

&lt;p&gt;마지막 수정일 : 2021년 3월 18일&lt;/p&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-03/android</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-03/android</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[안드로이드] 안드로이드 버전이 뭐예요?(targetSdkVersion, compileSdkVersion, API 레벨)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=110015332&quot;&gt;책 - 안드로이드 프로그래밍 Next Step&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/uses-sdk-element&quot;&gt;Android Developers 사이트 - API 레벨이란?&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/practices/compatibility?hl=ko#Versions&quot;&gt;Android Developers 사이트 - &amp;lt;uses-sdk&amp;gt;&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/basics/supporting-devices/platforms?hl=ko&quot;&gt;Android Developers 사이트 - 다양한 플랫폼 버전 지원&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/distribute/best-practices/develop/target-sdk?hl=ko#why-target&quot;&gt;Android Developers 사이트 - 최신 SDK를 타겟팅해야 하는 이유&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;기억 상 중학교 1학년 시절부터 스마트폰을 썼던 것 같습니다.. 갤럭시 노트 1이 처음 나왔을 때 큰 화면과 노트 펜을 보고 너무 가지고 싶었죠^^.. ㅋㅋㅋ 부모님을 졸라 손에 넣은 갤럭시 노트 1!! 1년 정도 쓰다가 변기통에 빠뜨려 사망하고 말았습니다..&lt;/p&gt;

&lt;p&gt;그 때 갤럭시 노트 1에 탑재된 안드로이드 운영체제 버전이 아마 진저브레드였던 것 같습니다.&lt;/p&gt;

&lt;p&gt;안드로이드 운영체제가 탑재된 모바일 디바이스를 사용하다보면 몇 년에 한 번씩 안드로이드 운영체제 버전이 업그레이드 되어 업데이트하면 더 세련된 화면들로 바뀌는 현상을 경험했을 것입니다.&lt;/p&gt;

&lt;p&gt;이번 포스팅에서는 ‘안드로이드 버전’과 관련된 내용을 공부해보겠습니다! 포스팅 내용에 잘못된 개념이나 잘못된 사용법이 작성되어 있다면 댓글로 알려주세요🧚🏻‍♀️&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-what-is-안드로이드-버전&quot;&gt;1️⃣ What is 안드로이드 버전?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;먼저 읽고 오면 좋은 포스팅&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://choheeis.github.io/newblog//articles/2021-03/android&quot;&gt;이 블로그의 다른 포스팅 - 안드로이드가 뭐예요?&lt;/a&gt;를 먼저 읽고 오면 이 포스팅에서 자주 사용할 ‘안드로이드’, ‘안드로이드 운영체제’ 라는 용어에 대해 혼동하지 않고 잘 이해할 수 있을 것입니다 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android에도 Version이 있다?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;826&quot; alt=&quot;01&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111580326-ac773780-87fa-11eb-8367-27e5890b38fa.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;a href=&quot;https://developer.android.com/about?hl=ko&quot;&gt;Android Developers 사이트의 플랫폼 개요&lt;/a&gt;만 들어가도 최신 Android Version에 대해 소개하고 홍보하는 글을 볼 수 있습니다. 2021년 3월 기준 최신 버전은 Android 11 이네요!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;200&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111580561-12fc5580-87fb-11eb-987e-b31e21092e0c.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;a href=&quot;https://developer.android.com/about/versions/11?hl=ko&quot;&gt;Android Developers 사이트의 플랫폼 출시&lt;/a&gt;에서 볼 수 있는 버전 리스트를 보면 ‘롤리팝’, ‘마시멜로우’, ‘누가’, ‘오레오’, ‘파이’ 등 예전에 출시되었던 안드로이드 버전들에 대한 설명도 볼 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;앱 개발자는 앱을 처음 출시한 후 지속적으로 새로운 기능을 추가하거나 기존 기능을 개선하여 새로운 버전으로 업그레이드하는 경우가 많습니다. 따라서 해당 앱을 설치하여 사용하고 있던 사용자들은 앱이 제공하는 새로운 기능을 사용하기 위해 새로운 버전으로 업데이트하는 경우가 대부분 입니다. 안드로이드 앱만 봐도 지속적으로 새로운 버전이 등장하는 것처럼 ‘안드로이드 자체’도 새로운 기능과 개선된 기능을 포함한 NEW Version이 지속적으로 출시되고 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, 안드로이드 운영체제는 계속해서 발전해가고 있다는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android Version을 한 눈에 볼 수 있는 표&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;946&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111586467-37a8fb00-8804-11eb-8c7f-f9273767561e.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels&quot;&gt;출처 : Android Devlopers 사이트&lt;/a&gt;) 위 표는 안드로이드의 버전을 최신순부터 쭉~ 한 눈에 정리해놓은 표입니다. 앞으로 새로운 안드로이드 버전이 계속 출시된다면 이 표도 계속 업데이트 될 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 표를 보면 일반 사람들에게 익숙한 ‘롤리팝(LOLLIPOP)’, ‘젤리빈(JELLY_BEAN)’, ‘아이스크림 샌드위치(ICE_CREAEM_SANDWICH)’ 등의 이름들이 &lt;strong&gt;버전 코드(Version Code)&lt;/strong&gt; 라는 항목에 작성되어 있습니다. &lt;strong&gt;버전 코드라는 것은 숫자로 표시된 버전명을 문자열로 바꾸어 나타낸 것&lt;/strong&gt; 입니다. 예를 들어, 안드로이드 버전 ‘5.0’를 ‘LOLLIPOP’이라는 문자열로 바꾸어 부르는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 표를 보면 버전 코드 외에도 &lt;strong&gt;플랫폼 버전&lt;/strong&gt; 과 &lt;strong&gt;API 레벨&lt;/strong&gt; 이라는 항목이 있습니다. 심지어 하나의 API 레벨에 여러 개의 플랫폼 버전이 존재하기도 합니다. 예를 들어, 위 표를 보면 API 레벨 14에 해당하는 플랫폼 버전은 android 4.0, android 4.0.1, android 4.0.2 3개가 존재합니다. ‘플랫폼’ 이라는 것에 대해서는 &lt;a href=&quot;https://choheeis.github.io/newblog//articles/2021-03/android&quot;&gt;이 블로그의 다른 포스팅 - 안드로이드가 뭐예요?&lt;/a&gt;에서 설명하고 있습니다. 이 포스팅을 보고 온다면 ‘플랫폼’이 ‘안드로이드’를 말하는 것이며 동시에 ‘안드로이드 플랫폼’을 말하고 있음을 알 수 있을 것입니다. 따라서 ‘플랫폼 버전’은 ‘안드로이드 버전’을 나타냅니다. 플랫폼 버전 중 android 4.0 버전을 보면 처음엔 android 4.0이 출시되었다가 조금 더 개선하여 android 4.0.1 으로 버전 업그레이드를 했고, 마지막으로 android 4.0.2로 추가 업그레이드된 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 또 안드로이드는 각 플랫폼 버전에 대응되는 &lt;strong&gt;플랫폼 명(안드로이드 버전 명)&lt;/strong&gt; 을 만들어 일반 사람들에게 쉽게 안드로이드 버전을 소개합니다. 그러나 이러한 플랫폼 명과 API 레벨, 플랫폼 버전 등이 일대일 매칭이 되지 않아 혼동되는 경우가 많습니다. 혼동될 경우 위 표를 봅시다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;안드로이드 버전 별로 등장한 새로운 기능 및 개선된 기능을 자세히 알아보고 싶다면 &lt;a href=&quot;https://developer.android.com/about/versions?hl=ko&quot;&gt;여기&lt;/a&gt; 를 참고하면 됩니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-what-is-api-레벨&quot;&gt;2️⃣ What is API 레벨?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;API 레벨(API LEVEL)이 무엇인가?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;안드로이드 버전의 역사를 볼 수 있었던 위 표에는 ‘API 레벨’ 이라는 항목이 있었습니다. API 레벨은 가장 초창기 안드로이드 플랫폼 버전인 android 1.0 부터 가장 최신 안드로이드 플랫폼 버전까지 1부터 1씩 증가했음을 알 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;API 레벨&lt;/strong&gt; 은 Android 플랫폼 버전이 업데이트 될 때마다 수정되는 &lt;strong&gt;Android Framework(안드로이드 프레임워크)의 수정 버전을 고유하게 식별해주는 정수 값&lt;/strong&gt; 입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://choheeis.github.io/newblog//articles/2021-03/android&quot;&gt;이 블로그의 다른 포스팅 - 안드로이드가 뭐예요?&lt;/a&gt;를 읽어보면 ‘Android Framework’가 무엇인지에 대해서 알 수 있기 때문에 이 포스팅에서는 따로 설명하지 않겠습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, Android 버전이 업데이트는 Android Framework 업데이트도 포함할 수 있기 때문에 Android Framework의 수정 히스토리를 Android 버전과 별도로 표시하는 것이 API 레벨입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;946&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111586467-37a8fb00-8804-11eb-8c7f-f9273767561e.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 위 표를 보면 Android 플랫폼 최초 출시 버전인 android 1.0 버전은 API Level 1을 제공했음을 알 수 있습니다. android 1.0 버전부터 계속 후속 릴리즈 버전이 나오면서 API 레벨도 1씩 증가했습니다. 또한 각 Android 플랫폼 버전별로 지원하는 API 레벨이 지정되어 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3️⃣-android-앱-개발-시-앱이-어떤-안드로이드-버전에서-동작할-것인지-지정해야-한다&quot;&gt;3️⃣ Android 앱 개발 시 앱이 어떤 안드로이드 버전에서 동작할 것인지 지정해야 한다!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android 앱 개발 시 앱이 어떤 안드로이드 버전(플랫폼 버전)에서 동작할 것인지 지정해줘야 하는 이유?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;위에서 알아본 것처럼 안드로이드는 시간이 지날수록 새로운 기능과 개선된 기능이 추가되어 업데이트되고 발전해갑니다. 이러한 특징 때문에 개발자가 앱 개발 시 사용한 API 레벨이 모든 앱에서 동일하다는 보장이 없습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;한 가지 예를 들어봅시다. 예를 들어, 달력 기능과 관련된 API인 &lt;a href=&quot;https://developer.android.com/guide/topics/providers/calendar-provider?hl=ko&quot;&gt;CalendarProvider&lt;/a&gt; API는 android 4.0(API 레벨 14)버전이 출시될 때 새로 나온 API 입니다. 만약 내가 만든 앱이 달력 관련 기능을 제공하기 위해 CalendarProvider API를 사용했다면 이 앱은 android 4.0 이후 버전이 설치된 디바이스 기기에서만 설치되도록 해야 합니다. 만약 android 4.0 이전 버전이 설치된 디바이스에서 내가 만든 앱을 설치하여 실행한 경우, android 4.0 이전에는 CalendarProvider API가 존재하지 않기 때문에 앱이 정상적으로 실행되지 않을 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 문제에 대응하기 위해 안드로이드 프로젝트의 build.gradle 파일에 존재하는 minSdkVersion(최소 Sdk 버전)이라는 설정의 값을 14(API 레벨)로 지정해줘야 합니다. 이는 이 앱을 실행하려면 디바이스 기기에 최소한 API 레벨 14는 설치되어 있어야 함을 의미합니다. 다른 말로는, 이 앱이 API 레벨 14가 존재하는 디바이스 기기까지와는 &lt;strong&gt;호환&lt;/strong&gt; 된다고 말할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Android 플랫폼의 버전이 계속 발전하고 있는 상황에서 &lt;strong&gt;앱 호환성&lt;/strong&gt; 이라는 것은 중요한 요소가 되었습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;앱 호환성이란?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112323966-9d5e2100-8cf5-11eb-8dcc-225f0fd2d43b.png&quot; alt=&quot;05&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/11?hl=ko&quot;&gt;출처&lt;/a&gt;) Android에서 말하는 &lt;strong&gt;앱 호환성은 앱이 Android 플랫폼 버전의 특정 버전에서 올바르게 실행되는 것&lt;/strong&gt; 을 말합니다. 새로운 Android 플랫폼 버전이 출시되었다는 것은 이전 버전에 비해 개선된 사항들이 새 버전에 추가되었다는 것입니다. 위 그림에서 볼 수 있듯이, 새 버전에는 ‘개인 정보 보호’와 ‘보안 향상’에 관련된 변경 사항이 추가될 수도 있고, Android 운영체제 전반에 걸쳐 사용자 환경을 개선하는 변경 사항이 추가될 수도 있습니다. 또 아예 기존에 없었던 새로운 기능이 추가될 수도 있습니다. 이러한 변경 사항은 앱에 영향을 줄 수 있습니다. 따라서 새로운 Android 플랫폼 버전이 출시되면 개발자는 출시 버전에 포함된 변경 사항을 살펴보고 해당 버전에서 앱이 잘 동작하는지 테스트한 다음, 사용자를 위해 호환성 업데이트를 하는 것이 중요합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또한 일반적으로 Android 플랫폼 버전이 새로 출시되면 사용자들은 이에 관심과 흥미를 가지고 자신의 기기에 Android 플랫폼을 업데이트하는 경우가 많습니다. 또 새 변경 사항을 자신이 사용하는 앱에서 경험해 보고 싶어 합니다. 사용자의 이러한 특성을 파악하고 개발자는 Android 플랫폼 버전이 새로 출시되면 앱이 새 버전에서 비정상적으로 동작하는 부분은 없는지 테스트하는 것이 좋습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;915&quot; alt=&quot;06&quot; src=&quot;https://user-images.githubusercontent.com/31889335/112324373-12315b00-8cf6-11eb-8812-5fbdfc4e9e21.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/12?hl=ko&quot;&gt;출처&lt;/a&gt;) 따라서 Google은 Android 플랫폼 최신 버전이 공식적으로 출시되기 전에 개발자 프리뷰(preview) 및 베터 버전을 먼저 출시하여 개발자들에게 테스트 기간을 주고 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;minSdkVersion 지정하기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;minSdkVersion은 &lt;strong&gt;앱을 실행하려면 필요한 최소 API 레벨&lt;/strong&gt; 을 의미합니다. 즉, ‘이 앱을 실행하려는 디바이스 기기에는 최소한 몇 API 레벨을 제공하는 Android 플랫폼 버전이 설치되어 있어야 한다’ 라는 의미입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만약 어떤 디바이스 기기에서 A라는 앱을 설치하려고 하는 상황을 가정해봅시다. 만약 이 디바이스 기기의 Android 플랫폼 버전이 A앱에 설정된 minSdkVersion보다 낮은 버전의 API 레벨을 제공한다면 Android 시스템은 자동으로 앱 설치를 방지합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minSdkVersion은 항상 지정해줘야 합니다. 만약 이 설정을 지정해주지 않을 경우 기본 값으로 API 레벨 1이 minSdkVersion으로 지정됩니다. API 레벨 1이 설정되었다는 것은 해당 앱이 모든 Android 버전과 호환된다는 의미입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만약 API 레벨 14부터 지원하는 CalendarProvider API를 사용한 앱의 minSdkVersion이 1일 경우(=minSdkVersion을 지정하지 않았을 경우) 해당 앱은 런타임 시 작동이 중단될 수 있습니다. API 레벨 14를 지원하지 않는 디바이스 기기에서도 이 앱을 설치할 수 있지만 정상적인 앱 작동에 필수인 CalendarProvider API를 제공하지 않기 때문입니다. 이렇게 minSdkVersion이 적절하지 않게 설정되면 앱이 중단될 수 있기 때문에 앱에 사용한 API 레벨을 고려하여 적절한 minSdkVersion을 지정해줘야 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;앱의 minSdkVersion을 설정할 수 있게 된 것은 API 레벨 4 이후였습니다.(애초에 minSdkVersion이라는 기능이 API 레벨 4 때 처음 추가되었기 때문)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;일반적인 Android 앱은 Android 플랫폼의 신규 버전과 호환된다!&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 Android 플랫폼 버전이 출시되면 Android Framework API에 관한 변경도 존재할 수 있습니다. 하지만 신규 Android 플랫폼 버전에 포함된 API 변경 사항은 이전 버전의 API를 Android Framework에서 완전히 삭제한 후 그것을 대체하는 것이 아닙니다. 이전 버전이 제공하는 API는 그대로 두고 거기에 추가로 새로운 API도 제공되는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;따라서 이미 이전 API 레벨을 사용하여 개발된 Android 앱이 최신 Android 플랫폼 버전을 설치한 디바이스 기기(최신 API 레벨을 제공)에서 실행된다고 하더라도 앱 실행에 있어서 문제가 되지 않습니다. 왜냐하면 최신 API 레벨은 바로 이전 API 레벨이 제공하는 API도 제공하고, 새롭게 추가된 API도 제공하기 때문입니다.  &lt;strong&gt;즉, 어떠한 이유나 이슈 발생으로  Android Framework에서 완전히 삭제된 API를 사용한 앱이 아니라면, 일반적인 Android 앱은 Android 플랫폼의 이후 버전 및 상위 API 레벨과 호환됩니다.&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;추가로 예를 들어 보자면, 사용자가 API 레벨 29를 사용하여 개발된 Android 앱을 설치하여 잘 사용하고 있었습니다. 그런데 API 레벨 30을 제공하는 새로운 Android 플랫폼 버전이 등장하여 이 사용자는 디바이스 기기에 설치된 Android 플랫폼 버전을 업데이트 설치했습니다. 이러한 경우는 어떻게 되는 걸까요? Android 플랫폼 업데이트가 정상적으로 설치되면 이 앱은 API 레벨 29와 새 시스템 기능을 가진 환경의 새로운 런타임 버전에서 실행됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112164521-4a229a80-8c31-11eb-8264-c90e479d30ef.png&quot; alt=&quot;04&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 사진 참고) 하지만 위에서 설명한 CalendarProvider API 예시처럼, 경우에 따라서는 어떤 Android 플랫폼 버전에서는 앱이 잘 동작하는데 어떤 Android 플랫폼 버전에서는 앱이 잘 동작하지 않는 경우가 있을 수 있습니다. 이러한 문제에 대응하기 위해 개발자는 다양한 Android 플랫폼에서 앱을 테스트해 볼 필요가 있습니다. 위 그림 처럼 Android SDK는 개발자가 여러 플랫폼 버전을 선택적으로 다운로드할 수 있게 제공되므로 필요한 버전을 다운로드하여 테스트해보면 됩니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;그러나 신규 API 레벨 버전을 사용한 앱을 Android 플랫폼 이전 버전에서 실행하면 100% 호환되지 않는다.&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;이전 API 레벨 버전을 사용하여 개발된 앱을 새로운 Android 플랫폼에서 실행시키는 것은 문제가 되지 않는다고 위에서 설명했습니다. 그러나 반대로 신규 API 레벨 버전을 사용한 앱을 이전 Android 플랫폼에서 실행시킬 경우, 이전 플랫폼은 신규 API를 제공하지 않기 때문에 앱이 제대로 동작하지 않을 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;디바이스 기기에 설치된 Android 플랫폼을 최신 버전으로 업데이트한 후에는 이전 플랫폼 버전으로 다운 그레이드될 가능성이 없습니다. 하지만 개발자는 항상 최신 버전으로 업데이트하지 않은 기기가 있을 수 있다는 인식을 해야 합니다.(실제로 제 주변 지인도 귀찮아서 Android 플랫폼 버전을 두 개 버전이 새로 출시될 동안 업데이트 안 한 사람이 있습니다^^..)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, 신규 API 레벨을 사용하여 앱을 개발한 후 배포했을 때, 이전 플랫폼 버전이 설치된 기기에서는 제대로 동작하지 않을 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;새로운 Android 플랫폼 버전이 출시되었을 때, 앱에 영향을 주는 변경 사항의 두 가지 유형&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 Android 플랫폼 버전이 출시되면 반드시 이전 버전보다 개선된 사항들이 존재합니다.(‘개선된 사항’이라는 단어를 앞으로 ‘변경 사항’이라고 언급하겠습니다)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;새로운 Android 플랫폼 버전이 제공하는 변경 사항의 유형은 두 가지로 나뉩니다. &lt;strong&gt;모든 앱에 적용되는 변경 사항&lt;/strong&gt; 과 &lt;strong&gt;타겟팅된 앱에 적용되는 변경 사항&lt;/strong&gt; 으로 나뉩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112330622-8c181300-8cfb-11eb-90cf-f4d9f1d9b5f0.png&quot; alt=&quot;07&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/11/behavior-changes-all?hl=ko&quot;&gt;출처&lt;/a&gt;) 위 그림은 2021년 3월 기준 가장 최신 Android 플랫폼 버전인 11 에서 제공하는 변경 사항 중 ‘모든 앱’에 적용되는 변경 사항을 소개하는 글입니다. 즉, Android 11이 설치된 디바이스 기기에서 실행되는 모든 앱에 적용되는 변경 사항인 것입니다. 그림의 출처 사이트에 접속해보면 어떤 변경 사항들이 ‘모든 앱’에 적용되는 변경 사항인지 알 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;위 그림의 내용에서 빨간색 박스 부분을 보면 ‘targetSdkVersion에 관계없이’라는 말이 있습니다. 아직 targetSdkVersion이라는 것이 무엇인지 설명하지는 않았지만 분홍색 박스 부분을 추가로 봐봅시다. ‘Android 11을 타겟팅하는 앱에만 영향을 주는 변경 사항을 검토해야 한다’는 말이 적혀있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;파란색 박스 부분과 분홍색 박스 부분을 통해 대충 유추해보자면.. 특정 Android 플랫폼 버전을 타겟팅하는 앱이 존재하는 것 같고, targetSdkVersion이라는 설정으로 타겟팅할 버전을 지정하는 것 같죠? &amp;gt;.&amp;lt; (targetSdkVersion에 대해서는 조금 아래에서 설명할 예정입니다)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/112331866-a43c6200-8cfc-11eb-83bb-3b8808778266.png&quot; alt=&quot;08&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;https://developer.android.com/about/versions/11/behavior-changes-11?hl=ko&quot;&gt;출처&lt;/a&gt;) 위 그림의 내용에서 파란색 박스 부분을 보면 Android 11 이상을 타겟팅하는 앱에만 적용되는 변경 사항들이 존재한다는 것을 알 수 있습니다. 또 Android 11을 타겟팅하는 앱은 targetSdkVersion라는 것을 30으로 설정한 앱이라는 것도 알 수 있습니다. 만약 내가 개발한 앱의 targetSdkVersion을 30으로 설정했다면 이 앱이 Android 11에서 변경된 사항들을 반영하도록 수정해야 합니다.(Android 플랫폼 버전 11이 제공하는 API 레벨은 30입니다)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이처럼 새로운 Android 플랫폼 버전이 제공하는 변경 사항의 유형은 ‘모든 앱에 적용되는 변경 사항’ 과 ‘타겟팅된 앱에 적용되는 변경 사항’으로 두 가지 유형이 존재한다는 것을 알 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;targetSdkVersion 지정하기&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;targetSdkVersion은 &lt;strong&gt;앱의 타겟 API 레벨&lt;/strong&gt; 을 지정하는 정수입니다. ‘타겟’이라는 말의 의미처럼 해당 앱이 타겟으로 하고 있는 API 레벨이라는 뜻입니다. 만약 targetSdkVersion이 30로 지정되어 있으면 개발자는 API 레벨 30이 제공되는 환경에서 해당 앱 테스트를 완료했고 앱을 실행하는데 문제가 없다는 의미입니다. 즉, &lt;a href=&quot;https://mrgamza.tistory.com/615&quot;&gt;이 블로그&lt;/a&gt;의 말을 인용하자면 “우리가 최종적으로 호환성을 맞춘 버전이 이 버전이다.” 라고 선언하는 것이 targetSdkVersion 입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;정리 )&lt;/strong&gt; minSdkVersion은 앱이 호환되는 가장 낮은 API 레벨을 말하고, targetSdkVersion은 앱을 개발하고 테스트한 가장 높은 API 레벨을 말합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만약 targetSdkVersion을 설정하지 않을 경우 minSdkVersion과 동일한 값으로 설정됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;신규 Android 플랫폼 버전이 제공하는 변경 사항 중 ‘타겟팅된 앱에만 적용되는 변경 사항’이 있다는 것을 위에서 언급했습니다. 이러한 변경 사항은 targetSdkVersion에 설정된 값을 보고 변경 사항을 적용할지 말지 결정됩니다.&lt;/p&gt;
        &lt;blockquote&gt;
          &lt;p&gt;이 위에서부터 다시 하자. 호환성 프레임워크 도구 부터 읽자.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;minsdkversion 어디서 작성하는지 , Android 11과 앱의 호환성 테스트(새로운 기능 출시됨)
https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels
https://developer.android.com/training/basics/supporting-devices/platforms?hl=ko
https://developer.android.com/distribute/best-practices/develop/target-sdk?hl=ko
https://developer.android.com/about/versions/11/test-changes?hl=ko#list
https://developer.android.com/guide/app-compatibility/test-debug?hl=ko
https://developer.android.com/guide/app-compatibility?hl=ko
얘네 참고 문서에 없는 것 추가하기&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;안드로이드 앱을 조회할 수 있고 설치할 수 있도록 해주는 &lt;a href=&quot;https://play.google.com/store?utm_source=apac_med&amp;amp;utm_medium=hasem&amp;amp;utm_content=Jan0421&amp;amp;utm_campaign=Evergreen&amp;amp;pcampaignid=MKT-EDR-apac-kr-1003227-med-hasem-py-Evergreen-Jan0421-Text_Search_BKWS-BKWS%7cONSEM_kwid_43700058439438031_creativeid_477136209046_device_c&amp;amp;gclid=CjwKCAjw9MuCBhBUEiwAbDZ-7oqhHVcoSbCI_MqISe9w1YogduL5vR2-m_9-9tKDaEleYvQBQKuBwBoCfx8QAvD_BwE&amp;amp;gclsrc=aw.ds&quot;&gt;Google Play&lt;/a&gt;에는 &lt;a href=&quot;https://developer.android.com/google/play/filters&quot;&gt;Google Play 필터&lt;/a&gt; 라는 기능이 적용되어 있습니다. Google Play는 Google Play Store에 업로드된 모든 앱의 minSdkVersion과 targetSdkVersion을 확인하여 각 앱이 요구하는 Android 버전을 파악합니다. 앱이 요구하는 버전과 맞지 않는 디바이스 기기를 가진 사용자가 Google Play Store를 실행하여 앱을 조회할 경우, Google Play는 해당 앱을 앱 리스트에 아예 표시하지 않습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-03/android-version</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-03/android-version</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
      <item>
        <title>[안드로이드] RecyclerView가 뭐예요?</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고 자료&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/topics/ui/layout/recyclerview&quot;&gt;Android Developer 도큐먼트 - RecyclerView로 목록 뷰 구현하기&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26728651/recyclerview-vs-listview&quot;&gt;Stack Overflow - RecyclerView와 ListView의 차이점&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=LqBlYJTfLP4&quot;&gt;Android Developer 유튜브 채널 - RecyclerView ins and outs Google I/O 2016&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8MIfSxgsHIs&quot;&gt;Android Developer 유튜브 채널 - ListView Animations&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0️⃣-프롤로그&quot;&gt;0️⃣ 프롤로그&lt;/h2&gt;

&lt;p&gt;안드로이드 앱 개발을 하다보면 정말 많이 사용되는 뷰 모양 몇 가지를 자연스럽게 알 수 있게 됩니다. 많이 사용되는 뷰 모양 중 ‘목록 뷰’, ‘리스트 뷰’ 라고 불리는 뷰 모양이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;400&quot; alt=&quot;01&quot; src=&quot;https://user-images.githubusercontent.com/31889335/110605656-ad8de080-81cc-11eb-99e9-f98f941f9afc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 모양의 뷰를 구현하기 위해 사용하는 레이아웃은 ‘RecyclerView’입니다. 저는 그 동안 여러 번 RecyclerView와 관련된 클래스들을 구현해왔지만 누군가 ‘RecyclerView의 내부 동작을 설명해봐!’ 라고 했을 때 정확히 잘 설명할 자신이 없다는 것을 깨닫게 되었습니다ㅠㅠ😭&lt;/p&gt;

&lt;p&gt;이 포스팅은 RecyclerView의 구현 방법부터 내부 동작 등을 깊게 알아본 후 작성한 포스팅입니다.&lt;/p&gt;

&lt;h2 id=&quot;1️⃣-what-is-recyclerview&quot;&gt;1️⃣ What is RecyclerView?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RecyclerView는 무엇일까?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;220&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/110606298-66ecb600-81cd-11eb-95e9-30a872fc3e92.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) RecyclerView는 안드로이드 프레임워크에서 제공하는 뷰 레이아웃 중 하나입니다. RecyclerView의 모습은 위 그림(=이메일 앱에서 받은 편지 목록을 나타내는 화면)과 같습니다. ‘목록을 나타내는 뷰 레이아웃’ 라고 생각하면 쉽습니다. 특히, 위 그림에서 빨간 박스로 표시한 부분이 ‘동일한 형태로 계속 반복’되고 있다는 것을 알 수 있습니다. ‘동일한 형태(=반복되는 Structure)’라는 말의 의미는 빨간 박스의 형태를 분석해보면 이해할 수 있습니다. 빨간 박스 안을 보면 왼쪽 상단에는 이메일을 보낸 사람의 이름을 보여주는 텍스트 뷰가 배치되어 있고, 그 아래에는 이메일의 제목을 보여주는 텍스트 뷰가 배치되어 있으며 또 그 아래에는 이메일의 내용을 미리 보여주는 텍스트 뷰가 배치되어 있습니다. 오른쪽 상단에는 이메일을 받은 후 지난 시간을 보여주는 텍스트 뷰가 배치되어 있고, 그 아래에 별표 모양의 뷰가 배치되어 있습니다. 이러한  빨간 박스 부분이 &lt;strong&gt;형태는 동일하게, 다만 데이터만 계속 바뀌면서&lt;/strong&gt; ‘목록을 나타내주는 뷰’를 이루고 있습니다. 즉, 목록을 나타내주는 뷰는 동일한 형태의 빨간 박스가 계속 반복되면서 ‘보낸 사람 이름’, ‘이메일 제목’, ‘이메일 내용’ 등 빨간 박스 안 데이터만 바뀌는 뷰라고 이해할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RecyclerView에서는 위에서 쉽게 표현하기 위해 ‘빨간 박스 부분’라고 언급한 부분을 ‘ItemView(아이템 뷰)’라고 부릅니다. 아이템 뷰들이 일렬로 나열되어 목록처럼 보이는 뷰 레이아웃을 RecyclerView라고 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;220&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/110943146-36984980-837e-11eb-9c35-e79f2202b2c3.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고 - &lt;a href=&quot;http://www.digitstory.com/recyclerview-multiple-viewholders/&quot;&gt;출처&lt;/a&gt;) 더 나아가서 RecyclerView를 구성하는 ItemView들이 모두 동일한 형태가 아닌 경우도 있을 수 있습니다. 위 그림을 보면 파란색 박스 부분과 핑크색 박스 부분은 둘 다 하나의 RecyclerView를 구성하는 ItemView지만 두 ItemView의 형태가 동일하지 않습니다. 파란색 박스 부분과 달리 핑크색 박스 부분에는 메시지를 표시하는 텍스트 뷰가 포함되어 있습니다. RecyclerView는 이렇게 목록을 이루는 ItemView의 형태가 동일하지 않은 경우에도 하나의 목록으로 구현할 수 있도록 도와줍니다. 또한 ItemView의 형태를 ‘ItemViewType’ 또는 ‘ViewType’ 이라고 합니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;안드로이드 프레임워크가 제공하는 RecyclerView는 어디에 구현되어 있을까?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;RecyclerView는 Android Jetpack의 구성 요소(Component) 중 하나입니다. 즉, 안드로이드 프레임워크에서 라이브러리 형식으로 제공하고 있기 때문에 개발자는 RecyclerView에 관련된 라이브러리를 가져다 사용하면 되고 원하는 모양으로 만들기 위해 적절히 응용하기만 하면 됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;886&quot; alt=&quot;03&quot; src=&quot;https://user-images.githubusercontent.com/31889335/110795213-f1aadf00-82b9-11eb-8af6-43a6d030c511.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) &lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/recyclerview?hl=ko&quot;&gt;Jetpack RecyclerView에 관한 라이브러리 문서&lt;/a&gt;를 보면 RecyclerView는 &lt;strong&gt;androidx.recyclerview&lt;/strong&gt; 라는 이름의 패키지로 제공되는 Jetpack 라이브러리임을 알 수 있습니다. 2018년 12월에 1.1.0-alpha01 버전이 처음 배포되었고 최근 2021년 2월까지 지속적으로 업데이트되고 있는 라이브러리입니다. androidx.recyclerview 패키지 안에는 2개의 API가 포함되어 있는데 이 API는 &lt;strong&gt;androidx.recyclerview.widget&lt;/strong&gt; 과 &lt;strong&gt;androidx.recyclerview.selection&lt;/strong&gt; 이라는 패키지로 묶여 제공되고 있습니다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;패키지(Package) : 자바에서 클래스를 체계적으로 관리하기 위해 사용하는 것입니다. 패키지의 형태는 파일 시스템의 ‘폴더’와 비슷합니다. 하지만 ‘폴더’와 자바의 ‘패키지’의 차이점은 패키지는 자바 클래스를 유일하게 만들어주는 식별자 역할도 한다는 점입니다. 예를 들어, Test라는 이름의 자바 클래스가 존재하고 이 클래스가 com.android라는 이름의 패키지 안에 포함된다고 가정해봅시다. 이 때 Test 클래스의 전체 이름을 com.android.Test.class 라고 부를 수도 있습니다. 따라서 클래스의 이름이 같아도 다른 패키지에 포함되어 있으면 서로 다른 클래스로 인식됩니다. (참고 - https://yolojeb.tistory.com/8)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;androidx.recyclerview 라는 이름의 패키지는 하위 폴더로 widget과 selection 라는 폴더를 가지고 있는 것입니다. 또한 각 폴더 안에 RecyclerView를 동작하게 하는 내부 클래스들이 실제로 구현되어 있습니다. 내부 클래스 파일들이 패키지로 묶여 제공되는 것입니다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RecyclerView가 왜 등장했을까?(ListView(리스트 뷰) 라는 것이 있었다!)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;RecyclerView가 등장하기 전, 안드로이드 프레임워크는 ‘목록 뷰’를 만들 때 사용하도록 &lt;a href=&quot;https://developer.android.com/reference/android/widget/ListView&quot;&gt;ListView&lt;/a&gt; 라는 것을 제공했습니다. 이 ListView를 사용해도 RecyclerView와 모양이 비슷한 ‘목록 뷰’를 만들 수 있습니다. 또한 ListView는 API level 1(=Android 1.0 버전 때 출시된 API) 때 등장한 것으로 안드로이드 프레임워크가 꽤 오랫동안 제공하던 API였습니다. 그럼 이미 ListView라는 것이 존재함에도 불구하고 2018년에 왜 RecyclerView가 새롭게 등장했을까요?&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ListView에는 고질적인 문제가 많았기 때문입니다. ListView에 들어가는 ItemView의 갯수가 수백 개, 수천 개 이상으로 많아질 경우 ListView가 ItemView를 생성하는 &lt;strong&gt;속도가 매우 느려지는&lt;/strong&gt; 문제가 존재했습니다. 특히, 안드로이드 운영체제를 탑재했던 옛날 디바이스는 메모리 용량이 요즘의 디바이스에 비해 매우 작았고 그로 인해 메모리가 제한적이어서 더욱 느렸습니다. 따라서 ListView를 사용해 한 번에 많은 수의 ItemView를 생성하는 것이 쉽지 않았습니다. 즉, ListView에 많은 수의 ItemView를 넣으면 앱 성능(App Performance)적인 측면에서 좋지 않았습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그렇다면 어떻게 해야 많은 수의 ItemView를 한 번에 빠르게 만들 수 있을까요? 이에 대한 해결책으로 많은 개발자들은 ‘속임수’를 사용하는 방법을 선택했습니다. 이 속임수는 바로 &lt;strong&gt;유저의 눈에 당장 보이는 ItemView만 생성하자!&lt;/strong&gt; 였습니다. ListView가 처음 뜨는 화면에는 유저의 눈에 당장 보여야 하는 ItemView만 한꺼번에 생성하여 보여주고, 그 후에 유저가 스크롤을 하게 되어 새로운 ItemView들이 새로 보여야 한다면 그 때 새롭게 보이는 ItemView만 생성하는 방법입니다. 마치 &lt;a href=&quot;https://youtu.be/t8T8bStabq0?t=100&quot;&gt;이 영상&lt;/a&gt;에서 강아지가 기차를 타고 가는데 기찻길을 직접 놓으면서 가는 것과 비슷한 방법입니다.(&lt;del&gt;링크로 걸어 놓은 애니메이션 어렸을 때 많이 봤었는데 .. RecyclerView 공부하다가 추억에 빠진다 ㅎㅎ&lt;/del&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, 기존 ListView의 내부 동작 원리에 의하면 한 순간에 모든 ItemView를 생성하지 않고 유저의 눈에 보이는 ItemView만 생성함으로써 마치 ItemView를 생성하는 속도가 빠르게 보이는 것 같았습니다.s&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 내부 동작을 가능하게 하기 위해 ListView는 &lt;strong&gt;Adapter&lt;/strong&gt; 라는 것을 사용했습니다. Adapter는 ListView를 동작하게 하는 구성 요소(=Component, 컴포넌트) 중 하나입니다. Adapter는 ListView에 포함될 ItemView를 생성하고 ItemView에 데이터를 채워주는 역할을 했습니다. 개발자는 Adapter 클래스가 제공하는 getView()라는 메소드를 호출함으로써 Adapter가 생성하고 데이터까지 채워놓은 ItemView를 얻을 수 있습니다.(ListView 안에서 어느 위치(=position)에 어떤 ItemVIew가 들어가야 하는지도 Adapter가 알고 있었습니다.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ListView는 앞서 설명했던 속임수 외에 또 다른 속임수가 하나 더 있었습니다. ListView에 포함될 ItemView의 갯수가 100개지만 당장 유저의 눈에는 5개의 ItemView만 보이는 ListView가 존재한다면 이 ListView는 100개의 ItemView를 미리 모두 생성하지 않고 당장 보이는 5개의 ItemView만 생성하여 보여준다고 설명했습니다. 만약 유저가 스크롤을 내린 행동의 결과로 6번째 ItemView가 새로 보여져야 한다면 어떤 일이 벌어질까요? 이 때 ListView는 또 다른 속임수를 사용합니다. 이 속임수는 바로 Adapter는 새로운 ItemView를 생성하지 않고 &lt;strong&gt;1번째 위치에 보여주기 위해 생성했던 ItemView를 그대로 재사용하여 6번째 ItemView로 제공하자!&lt;/strong&gt; 였습니다.(1번째 ItemView는 재사용하여 그대로 사용하고 6번째에 들어갈 데이터만 변경해주는 방식입니다.) 단, 1번째 ItemView의 ViewType과 6번째 ItemView의 ViewType이 동일한 경우에만 재사용됩니다.(=ItemView의 모양이 같아야함) 이러한 두 번째 속임수를 사용함으로써 6번째 ItemView를 생성하기 위해 사용되는 비용을 줄일 수 있었습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;점점 시간이 지나고.. ListView에는 이 두 개의 속임수를 사용한 기능 외에도 점점 더 많은 기능이 추가되어야 했습니다. 왜냐하면 ListView가 앱에서 너무 많이, 자주 사용되는 레이아웃이기 때문에 개발자들이 ListView API의 업데이트마다 바라는 요구사항이 많아졌기 때문입니다. 따라서 Android API level이 새로 출시될 때마다 ListView에는 새로운 기능이 계속 추가되었습니다. Google은 점점 더 많아지는 요구 사항을 ListView API에 추가 구현하여 제공하려다 보니 너무 복잡해짐을 느꼈고 부가 기능들이 많아져 오히려 오작동을 일으키게 되는 경우도 있었습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;결국 많은 요구 사항들을 ListView에 추가하다 보니 ListView의 기능이 안드로이드 프레임워크에서 이미 제공하고 있는 기능과 비슷한 것들이 생겨나기 시작했습니다. 예를 들어, ListView에 추가된 Selection이라는 기능은 View 클래스가 제공하는 Focus라는 기능과 역할이 중복되었습니다. View 클래스는 현재 포커스 된 뷰를 다루는 기능을 제공하는 것이었고, ListView의 Selection도 이와 비슷하게 현재 포커스 된 ItemView를 다루는 기능이였습니다. 또한 ItemView 클릭 리스너 기능과 View 클릭 리스너 기능도 비슷한 기능이였습니다. ListView가 제공하는 ItemView 클릭 리스너를 구현하면 유저가 ItemView를 클릭했을 때 실행할 로직을 작성할 수 있었습니다. 그러나 View 클래스에서 제공하는 View 클릭 리스너를 사용해서도 ItemView를 클릭했을 때 실행할 로직을 작성할 수 있었습니다. (ItemView 클래스가 View 클래스를 상속했기 때문) 따라서 개발자들은 대체 어떤 클릭 리스너를 사용해야 하는지에 관한 질문을 지속적으로 문의하기도 했습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/110972166-09a85e80-839f-11eb-90e1-0ce68ce5f4e3.gif&quot; alt=&quot;05&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 영상 참고 - &lt;a href=&quot;https://www.youtube.com/watch?v=8MIfSxgsHIs&quot;&gt;출처&lt;/a&gt;) 그러나 ListView가 가지고 있는 문제들 중 최고봉은 &lt;strong&gt;ListView의 ItemView 애니메이션을 구현하는 것이 정말 정말 어렵다&lt;/strong&gt; 라는 문제였습니다. &lt;a href=&quot;https://www.youtube.com/watch?v=8MIfSxgsHIs&quot;&gt;이 영상&lt;/a&gt;을 보면 ListView 애니메이션을 구현하는 것이 왜 어려운지 알 수 있습니다. 이 영상에서 구현하고자 하는 애니메이션은 ItemView를 클릭하면 해당 ItemView가 fade out(=서서히 사라지기) 애니메이션 처리되면서 마침내 완전히 사라지는(=메모리에서 제거) 효과입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/110972820-c4d0f780-839f-11eb-8013-cccadcfd79be.gif&quot; alt=&quot;06&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 영상 참고) ItemView를 하나씩 클릭했을 때는 원하는 대로 잘 동작하는 것 같지만 위 영상처럼 여러 개의 ItemView를 클릭한 후 바로 ListView를 빠르게 스크롤하면 몇 개의 ItemView가 아무 데이터도 가지고 있지 않은 빈 모습으로 중간 중간 보이는 현상이 발생합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 현상은 ListView의 동작 원리가 ItemView를 재사용하도록 동작하기 때문에 발생합니다. 먼저, 유저가 ItemView를 클릭하면 해당 ItemView에 fade out 효과가 적용되기 시작합니다. 하지만 유저가 클릭과 동시에 ListView를 위로 빠르게 스크롤 한다면 클릭한 ItemView는 fade out 효과가 시작되자마자 화면 밖으로 나가게 되어 유저의 눈에 보이지 않는 범위에 포함되게 됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ListView 내부 동작에 의하면 유저의 눈에 보이지 않는 ItemView는 새롭게 보일 ItemView로 재사용됩니다. 따라서 이 ItemView는 fade out이 진행되고 있음과 동시에 재사용될 ItemView로 선택되게 됩니다.(fade out 효과가 완전히 완료될 때까지 시간이 걸리기 때문에 fade out 효과가 진행되고 있는 도중에 재사용 대상으로 선택되는 것입니다.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그러나 이 ItemView는 fade out 효과가 완전히 끝난 후에야 메모리 상에서 제거됩니다. 즉, fade out 효과가 진행되고 있는 한 내부적으로는 메모리 상에서 이 ItemView에 해당하는 객체(object)가 여전히 존재합니다. 따라서 fade out 효과가 진행 중인 객체와 재사용될 ItemView로 선택된 객체는 메모리적으로 동일한 객체입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;fade out 효과가 완전히 끝나면 이 ItemView에 해당하는 객체는 메모리 상에서 삭제됩니다. 하지만 이 객체는 재사용되기로 선택된 객체이기도 하기 때문에 ListView의 끝에 다시 붙어야 합니다. 그러나 fade out 효과 완료로 인해 메모리 상에서 사라져 버린 경우, ListView 입장에서는 새로운 데이터를 세팅할 재사용 ItemView를 메모리에서 찾지 못하게 됩니다. 따라서 사용자의 눈에도 중간 중간 데이터가 세팅되지 않은 빈 공간이 보이게 됩니다. 이것을 ListView의 ‘붕괴(disruption) 현상’이라고 부릅니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/111035271-f1971480-845c-11eb-8b41-1b3ea3898bd6.gif&quot; alt=&quot;07&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 영상 참고) ListView의 붕괴 현상을 해결하기 위해 안드로이드 프레임워크가 제공하는 &lt;a href=&quot;https://developer.android.com/reference/android/view/ViewPropertyAnimator&quot;&gt;ViewPropertyAnimator&lt;/a&gt; API를 사용하면 됩니다.(ViewPropertyAnimator은 Android level 12 때 추가된 API입니다.) ViewPropertyAnimator를 사용하면 fade out 효과가 진행 중인 아이템 뷰는 아직 작업이 진행 중인 객체로 인식되어 재사용될 ItemView로 선택되지 않습니다. 따라서 위 영상처럼 붕괴 현상이 해결됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img width=&quot;360&quot; alt=&quot;02&quot; src=&quot;https://user-images.githubusercontent.com/31889335/111036153-1c836780-8461-11eb-8a59-4e5bbc76ef4f.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 사람들은 ListView를 더욱 복잡한 레이아웃으로 변형하여 개발하기 시작했습니다. 심지어 위 그림의 오른쪽에서 볼 수 있는 것 같은 엇갈린 그리드 레이아웃(=staggered grid layout)도 등장했습니다. 더 나아가 엇갈린 그리드 모양이 화면 크기에 따라 반응형으로 달라지기까지 해야했습니다. 이러한 것들을 기존의 ListView API를 사용하여 구현하려면 개발자는 굉장히 많은 코드 수정을 해야했습니다. 특히, ItemView의 재사용을 담당하는 Adpater 클래스의 수정이 많았습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이러한 상황에서 개발자들은 ListView를 더 잘 응용하기 위해 &lt;strong&gt;ViewHolder 패턴&lt;/strong&gt; 이라는 것을 등장시켜 개발하곤 했습니다.(ViewHolder 패턴에 대해서는 조금 아래에서 설명할 예정입니다.) Google Android API 개발 팀은 ViewHolder 패턴을 사용한 가장 좋은 코드 예제를 ListView API에 아예 추가하기로 결정했습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;더불어 ListView를 구현할 때는 개발자이 직접 ItemView를 생성하는 로직(onCreate)과 생성된 ItemView에 데이터를 연결(binding)시키는 로직(onBind)을 분리하여 작성해야 했습니다. 즉, 개발자들은 if 조건문을 통해 재사용될 ItemView가 존재하면 바로 데이터를 해당 ItemView에 binding하고, 재사용될 ItemView가 존재하지 않으면(=if null) 새로운 ItemView를 생성하는 코드를 작성해야 했습니다. 하지만 이러한 로직 분리 작업을 많은 개발자들이 쉽게 까먹는 경우가 많았고, 그로 인해 ListView의 ItemView 재사용 기능이 정상적으로 동작하지 않게 되어 앱 성능을 악화시키는 원인이 되기도 했습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또한 ListView에 보여질 데이터가 변경된 경우, &lt;strong&gt;ListView의 Adapter는 데이터가 변경되었다는 사실만 알 수 있을 뿐 구체적으로 목록에서 몇 번째 데이터가 변경되었는지 알 수 없었습니다.&lt;/strong&gt; 예를 들어, 사용자의 눈에 보이고 있는 ItemView 중 세 번째 ItemView에 연결된 데이터가 어떠한 처리에 의해 바뀌게 되면 Adapter는 데이터가 바뀌었다는 사실만 알 뿐 몇 번째 ItemView에 연결된 데이터를 바꿔야 하는지는 알 수 없었습니다. 따라서 세 번째 ItemView의 데이터를 바꾸기 위해 모든 ItemView에 데이터를 다시 binding해야 했습니다. 이러한 문제는 애니메이션 처리까지 더욱 어렵게 했습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이렇게 다양한 곳에서 문제점이 등장하기 시작하자 Google Android API 개발 팀은 기존 ListView가 가지고 있던 문제점들을 해결한 새로운 API인 RecyclerView를 개발해 내놓게 되었습니다. RecyclerView는 ListView가 가지고 있던 실수와 문제들이 또 다시 반복되지 않도록 철저히 구현되었습니다. Google I/O 2016 발표에 따르면 ‘Google Android API 개발 팀은 ListView를 통해 기존 ListView 설계에 존재했던 실수들을 깨닫게 되었다’ 라고 말하면서 이 실수들을 다시는 반복하지 않고자 RecyclerView를 개발하게 되었다고 말합니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RecyclerView의 내부 동작&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;RecyclerView의 내부 아키텍처는 &lt;strong&gt;컴포넌트(Componenet) 기반 아키텍처&lt;/strong&gt; 입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/111988900-73212d80-8b54-11eb-97ca-621a242dc35b.png&quot; alt=&quot;09&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) RecyclerView 내부 아키텍처를 구성하는 컴포넌트는 RecyclerView, LayoutManager, Item Animator, Adapter 등 입니다. 그 중 &lt;strong&gt;Layout Manager&lt;/strong&gt;, &lt;strong&gt;Item Animator&lt;/strong&gt;, &lt;strong&gt;Adapter&lt;/strong&gt; 라는 3가지 컴포넌트가 중요합니다. Layout Manager는 ItemView를 올바른 위치(=position)에 배치해주는 컴포넌트이고, Item Animator는 ItemView의 애니메이션을 담당하는 컴포넌트 입니다. Adapter는 RecyclerView에 ItemView를 제공해주는 컴포넌트입니다. 이 3가지 컴포넌트가 적절하게 상호작용해야만 ItemView를 RecyclerView 컴포넌트 안에 바르게 배치할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이렇게 RecyclerView, Layout Manager, Item Animator, Adapter 등의 컴포넌트가 서로 상호작용하여 하나의 목록형 레이아웃을 동작하게끔 만들기 때문에 RecyclerView 내부 아키텍처를 ‘컴포넌트 기반 아키텍처’라고 부릅니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2️⃣-recyclerview의-내부-동작을-자세히-알아보자&quot;&gt;2️⃣ RecyclerView의 내부 동작을 자세히 알아보자~&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Layout Manager가 뭘까?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/111990090-f4c58b00-8b55-11eb-9461-f8f582a7320a.png&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) Layout Manager는 RecyclerView의 모습을 &lt;strong&gt;선형(Linear)&lt;/strong&gt; 으로 구성할 수 있도록 또는 &lt;strong&gt;격자형(Grid)&lt;/strong&gt; 으로 구성할 수 있도록 또는 &lt;strong&gt;엇갈린 격자형(Staggerd Grid)&lt;/strong&gt; 으로 구성할 수 있게 해주는 작업을 담당하는 컴포넌트입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;즉, Layout Manger는 RecyclerView의 모양을 만드는 작업을 책임지고, RecyclerView 모양에 따라 ItemView를 적절한 위치(=position)에 배치하는 작업을 담당합니다. Layout Manager에게 이러한 책임이 부여되었기 때문에 RecyclerView 본인은 자기 자신이 선형 모양이 될지, 격자형 모양이 될지, 엇갈린 격자형 모양이 될지에 관해 알고 있지 않고 각 ItemView가 어느 위치에 놓여야 하는지에 대해서도 관여하지 않습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/111997193-22aecd80-8b5e-11eb-9e06-5355fa2ac121.png&quot; alt=&quot;11&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 만약 유저가 RecyclerView를 스크롤하고 있는 상황이라면 어떻게 동작할까요? RecyclerView는 유저의 손가락(스크롤 인식)과만 상호작용 합니다. 만약 Linear 모양의 RecyclerView가 존재하고 유저가 목록을 더 보기 위해 위로 스크롤했다고 가정해봅시다. 이러한 경우, RecyclerView는 유저 손가락과 상호작용의 결과로 새로운 ItemView를 보여줘야 한다는 것을 인식합니다. 하지만 새로운 ItemView를 그래서 어디에 배치해야 할 지에 관해서는 RecyclerView는 모르고 Layout Manager가 알고 있습니다. 따라서 RecyclerView는 Layout Manager에게 스크롤에 의해 새로운 ItemView를 보여줘야 한다고 알립니다. 스크롤 알림을 받은 Layout Manager는 적절한 위치(=위 상황에서는 목록 가장 아래에 새로운 ItemView를 추가해야 함)에 데이터가 연결된 ItemView를 배치합니다. 즉, Layout Manager가 ItemView를 적절한 위치에 배치하는 순간에는 데이터가 ItemView에 binding되어 있는 상태입니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Adapter가 뭘까?&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;RecyclerView도 ListView와 마찬가지로 Adapter에 의존합니다. RecyclerView에서의 Adapter도 ItemView를 생성(create)하는 작업을 담당하는 컴포넌트 입니다. 하지만 ListView의 Adapter와 다른 점은 ItemView 생성 외에도 &lt;strong&gt;ViewHolder라는 것을 생성&lt;/strong&gt; 하는 작업도 담당하고 있다는 점입니다. (ViewHolder에 관해서는 조금 더 아래에서 설명할 예정입니다.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또한 Adapter는 Data Set이 변경되었을 때 RecyclerView에게 알리는(=notify) 작업도 담당하며 유저가 ItemView를 클릭할 때 발생하는 상호작용(=클릭 리스너) 처리 작업도 담당합니다. 또 RecyclerView를 구성하는 ItemView의 형태(=ViewType)가 동일하지 않고 다른 경우를 처리하는 작업도 Adapter가 담당합니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ViewHolder의 lifecycle - 탄생편&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;앞에서 Adapter가 생성한다고 했던 ViewHolder는 무엇일까요? ViewHolder가 무엇인지 알기 위해서는 &lt;strong&gt;ViewHolder의 life cycle(=생명 주기, 탄생에서부터 소멸까지 과정)&lt;/strong&gt; 을 아는 것이 굉장히 중요합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RecyclerView의 내부 동작을 구성하는 컴포넌트는 앞에서 언급한 Layout Manager, Adapter 등 외에도 &lt;strong&gt;Cache, Recycled Pool&lt;/strong&gt; 등이 있습니다. 그럼 이제 이러한 각 컴포넌트들이 어떻게 상호작용하는지 알아봅시다!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113571490-6ff86800-9651-11eb-8298-f6db1e1b7520.png&quot; alt=&quot;12&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) RecyclerView는 유저와의 상호작용의 결과인 스크롤 알림을 Layout Manager에게 알립니다. 알림을 받은 Layout Manager는 몇 번째 위치(=position)에 새로운 ItemView가 배치되어야 하는지를 계산하고 이 위치를 다시 RecyclerView에게 알립니다. Layout Manager는 RecyclerView에게 자신이 계산한 위치를 알림으로써 해당 위치에 배치해야 하는 ItemView를 달라고 요청하는 것입니다. 그럼 RecyclerView는 Cache(=캐시)에 해당 위치에 배치하도록 지정된 ItemView가 저장되어 있는지 확인합니다.(RecyclerView 내부 동작 원리 상 일정 양의 ItemView를 캐시에 저장해놓기 때문) 만약 그 위치에 배치되어야 하는 ItemView가 Cache에 저장되어 있다면 RecyclerView는 해당 ItemView를 다시 Layout Manager에게 전달합니다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Cache(캐시)&lt;/strong&gt; : 임시 저장 공간, 저장해 놓은 것을 빠르게 찾을 수 있으나 저장 공간의 용량이 작아 많은 양을 저장할 순 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113571563-94544480-9651-11eb-8909-bf5b7cbf3068.png&quot; alt=&quot;13&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 하지만 만약 해당 위치에 배치될 ItemView가 캐시에 저장되어 있지 않다면 RecyclerView는 Adapter에게 이 위치에 배치될 ItemView의 모양(=ViewType)을 물어봅니다. (위에서 RecyclerView를 구성하는 ItemView가 모두 동일한 모양일 수도 있지만 다른 모양의 ItemView들이 섞여서 하나의 RecyclerView를 구성할 수도 있다고 설명했습니다.) 그럼 Adapter는 해당 위치에 배치될 ItemView의 ViewType을 RecyclerView에게 알려줍니다. 이번에는 RecyclerView가 Recycled Pool에게 이 ViewType을 위한 ViewHolder가 있는지 체크 요청합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113571697-d41b2c00-9651-11eb-9e93-c69c01889728.png&quot; alt=&quot;14&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 만약 Recycled Pool에 해당 ViewType을 위한 ViewHolder가 존재하지 않는다면 RecyclerView는 Adapter에게 해당 ViewType을 위한 새로운 ViewHolder 생성을 요청합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113578298-8c9a9d00-965d-11eb-8fd3-ad45d3d682fb.png&quot; alt=&quot;15&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 그러나 만약 Pool에 해당 ViewType을 위한 ViewHolder가 존재한다면 RecyclerView는 Adapter에게 이 ViewHolder를 ItemView가 배치될 위치(=position)에 연결(bind)해달라고 요청합니다. 그리고 Adapter는 RecyclerView에게 해당 ItemView를 전달하고 RecyclerView는 이 ItemView를 다시 Layout Manager에게 최종적으로 전달합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113577476-4a249080-965c-11eb-8591-62c535841482.png&quot; alt=&quot;16&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 결과적으로 Layout Manager는 해당 위치에 ItemView를 배치하고 RecyclerView에게 이를 알립니다. 그러면 RecyclerView는 Adapter에게 해당 position에 ItemView가 잘 배치되었다고 알립니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;여기까지의 과정은 &lt;strong&gt;ViewHolder가 탄생하는 순간의 과정&lt;/strong&gt; 을 말로 쉽게 풀어 쓴 것입니다. 화살표에 적힌 각각의 설명은 실제로는 위 그림들에 명시된 함수 호출에 의해 이루어집니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그리고 다시 한 번 전체 과정을 살펴보면 Layout Manager가 어떤 position에 배치될 ItemView를 요청할 경우 해당 ItemView가 Cache에 저장되어 있다면 Adapter를 거치지 않고 바로 Layout Manager에게 해당 ItemView를 전달할 수 있음을 깨달을 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ViewHolder의 lifecycle - 재활용편&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용자가 스크롤을 올려버려서 기존의 ItemView가 화면에서 사라지는 경우 RecyclerView는 이 ItemView를 재사용한다고 했습니다. 이 과정을 자세히 알아봅시다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113579570-75f54580-965f-11eb-9652-5898fe0530ed.png&quot; alt=&quot;17&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) 먼저 Layout Manager가 사용자의 스크롤에 의해 화면에서 제거되어야 할 ItemView의 position을 계산합니다. 그리고 RecyclerView에게 해당 position의 ItemView를 화면에서 제거해야 한다고 알립니다. 그럼 RecyclerView는 화면에서 그 ItemView를 떼어낸 후(=detach) Adapter에게 떼어냈다고 알려줍니다. 그럼 이제 떼어진 ItemView를 Cache에 저장해 놓을지 말지를 결정해야 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/31889335/113583008-0c2b6a80-9664-11eb-9f15-1211fb1566d3.png&quot; alt=&quot;18&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) Cache에 저장해 놓을지 말지는 위와 같은 과정을 통해 결정됩니다. 먼저 RecyclerView가 Cache에게 해당 position에 배치되는 ItemView가 Cache에 저장해놓을만 한 것인지 유효성을 물어봅니다. 즉, 이 position에 배치될 ItemView가 재사용률이 높냐고 물어보는 것입니다. 만약 Cache에서 해당 ItemView는 계속 저장해놓을만 하다. 즉, 유효하다 라고 답한다면 해당 ItemView를 Cache에 계속 저장하도록 결정합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;(위 그림 참고) Cache는 용량이 제한적이기 때문에 Cache에 남아있는 시간이 가장 긴 ItemView를 Cache에서 제거하여 용량 부족을 방지합니다. Cache에 오래 남아있었다는 것은 Cache에 저장된 이후로 재사용이 안 되었다는 것이기 때문에 앞으로도 재사용될 가능성이 적다고 판단하기 때문입니다. Cache는 Recycled Pool에게 가장 오래된 ItemView를 전달하고 Recycled Pool은 다시 Adapter에게 이 ItemView는 메모리에서 아예 제거해도 된다(=해당 ItemView의 인스턴스를 메모리에서 제거)고 알립니다. 이 과정을 통해 Cache에 어떤 ItemView들이 어떻게 얼만큼 저장되는지 결정되는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;따라서 RecyclerView가 Cache에게 요청하는 유효성 체크에 대한 응답은 Cache에 해당 ItemView가 저장되어 있는지 없는지에 의해 유효/무효가 결정되는 것입니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ViewHolder의 lifecycle - 소멸편&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;그럼 ViewHolder는 언제 메모리에서 소멸될까요? ViewHolder가 메모리에서 소멸되는 경우는 2가지 경우가 있습니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;조금만 기다려주세요 열심히 공부 중입니다 :)
21분 50초부터 이어서 보기..&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>2021-09-13</pubDate>
        <link>http://localhost:4000/articles/2021-03/recyclerview</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2021-03/recyclerview</guid>
        
        
        <category>안드로이드</category>
        
      </item>
    
  </channel>
</rss>

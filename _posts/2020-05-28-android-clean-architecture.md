---
layout: post
title:  "[안드로이드] 🔨 Android Clean Architecture(1탄)"
date:   2020-05-28 18:34:10 +0700
categories: [안드로이드]
---

<br>

## 0️⃣ 안드로이드에서 권장하는 아키텍처가 있다?

[Android Jetpack이 뭐지?](https://choheeis.github.io/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/2020/05/25/jetpack.html)라는 포스팅에서 Jetpack을 이루는 4가지 컴포넌트 중 Architecture 컴포넌트가 있다는 것을 공부했었다.

Jetpack에 속하는 컴포넌트 중 Architecture 컴포넌트로 분류되어 있는 라이브러리들에는

![01](https://user-images.githubusercontent.com/31889335/83118033-c8dda280-a108-11ea-9e2e-201751a17ef1.PNG)

이런 것들이 있다!

__Jetpack에서 지원하는 이러한 라이브러리들을 사용하여 개발하면 구글에서 권장하는 안드로이드 앱 프로젝트 Architecture를 구성할 수 있다.__

구글에서 권장하는 아키텍처는 어떤 구조인지 [Android Developer 도큐먼트 - 앱 아키텍처 가이드](https://developer.android.com/jetpack/docs/guide) 문서를 읽어보고 알아보자!

이 문서를 읽어보면 좋은 퀄리티의 강력한 앱을 개발하기 위한 권장 아키텍처가 무엇인지에 대해 알 수 있을 것이다.

## 1️⃣ 모바일 앱 사용자 환경이란?

안드로이드 권장 아키텍처를 본격적으로 살펴보기 전에 __모바일 앱 사용자 환경__ 이라는 개념에 대해 살짝 알아보자.

일반적인 Android 앱은 __Activity/Fragment, Service, Content Provider, Broadcast Receiver__ 등의 여러 App Component(앱 구성요소) 들로 구성되어 있다.

이것을 __안드로이드 4대 컴포넌트__ 라고도 부른다.

개발자는 이러한 앱 구성요소 대부분을 manifest 파일에서 선언하고, Android OS가 이 manifest 파일을 사용하여 기기를 사용하는 사용자의 전반적인 작업 환경을 망가뜨리지 않으면서 앱을 이 환경에 자연스럽게 통합하는 방법을 결정한다.

여기서 말하는 __사용자의 전반적인 작업 환경(모바일 앱 사용자 환경)__ 이란 무엇을 의미하는 것일까?

Android 앱을 사용하는 유저는 짧은 시간 내에 여러 앱을 실행할 때가 많다.

__따라서 앱이 사용자 중심의 다양한 workflow에 맞게 조정될 수 있어야 한다.__

예를 들어, 사용자가 SNS 앱에서 사진을 업로드 하는 과정에 대해 생각해보자.

SNS 앱은 가장 먼저 카메라 인텐트를 트리거할 것이다. 그러면 Android OS에서 이 요청에 따라 카메라 앱을 실행시킨다.

이 순간, 사용자는 카메라 앱으로 이동하게 되면서 SNS 앱에서는 나간 상황이 되지만 사용자의 작업 환경은 끊김없이 연결되어 있는 상태라고 볼 수 있다.

그 다음, 카메라 앱에서 앨범을 보기 위해 앨범 인텐트를 트리거할 수도 있다.

이 후에는 사용자가 다시 SNS 앱으로 돌아가서 앨범에서 선택한 사진이나 카메라 앱으로 직접 찍은 사진을 업로드할 것이다.

또 심지어는 __이 과정에서 전화나 알림에 의해 사용 환경의 흐름이 끊어질 수도 있다.__

사용자는 이러한 흐름 중단에 대응하고 난 후, 다시 SNS 앱으로 돌아가 하고 있던 작업을 계속 이어서 하길 원할 것이다.

이와 같이 __사용자는 모바일 환경에서 다양한 앱을 시도 때도 없이 바꾸기도 하고, 전화나 알림 등의 작업도 동시에 하기 때문에 앱에서 이러한 사용자 흐름이 중단되지 않고 자연스럽게 흘러가도록 올바르게 처리해야__ 한다.

이 뿐만 아니라 모바일 기기는 하드웨어 자원(메모리 등)이 제한되어 있으므로 메모리 부족으로 인한 사용자 흐름 중단이 발생할 수도 있다.

이에 대비하여 안드로이드 OS는 메모리 공간이 부족할 경우 '일시정지됨' 상태에 있는 앱의 프로세스를 강제 종료함으로써 사용자 작업 흐름을 끊기지 않게 해야한다.

이러한 모바일 환경 조건을 고려해 볼 때 __App Component(앱 구성요소)는 개별적이고 비순차적으로 실행될 수 있으며 Android OS나 사용자가 언제든지 앱 구성요소를 제거__ 할 수 있다는 것을 깨닫게 될 것이다!

하지만 개발자는 이러한 이벤트(앱 구성요소가 개별적, 비순차적으로 실행 / OS에 의한 앱 구성요소 제거)를 직접 제어할 수 없다.

따라서 이러한 이벤트가 발생할 것에 대비하여 __앱 구성요소에 앱 데이터나 상태를 저장해서는 안 되며 앱 구성요소가 서로 종속되도록 개발하면 안된다.__

앱 구성요소에 앱 데이터나 상태를 저장할 경우, 앱의 강제 종료가 발생하거나 예상치 못한 전화 및 알람이 왔을 경우 저장하고 있던 데이터가 유실될 수 있기 때문이다.

또한 앱 구성요소가 서로 종속된다면 포그라운드에서 동작하는 Activity를 종료했을 경우 백그라운드에서 동작하는 Service도 함께 종료되기 때문이다.

## 2️⃣ Android Clean Architecture 두 가지 원칙

위 내용을 통해 __'앱 구성요소에 앱 데이터와 상태를 저장하면 안됨'__ 에 대해 깨닫게 되었을 것이다.

__앱 구성요소에 앱 데이터와 상태를 저장하지 않으려면 앱을 어떻게 설계해야 할까?__

이 질문에 대한 대답으로 앱을 설계하는데 필수적인 몇 가지 원칙들을 알아보자.

__🧚🏻‍♀️ 첫 번째 원칙! "UI 기반 클래스를 가볍게 하라"__

이 원칙은 안드로이드 앱 아키텍처 원칙 중 가장 중요한 원칙이다.

안드로이드 초기 개발자들은 Activity나 Fragment에 모든 코드를 작성하는 '실수'를 범하기도 한다.

Activity나 Fragment 클래스를 __UI 기반 클래스__ 라고 하는데 원칙적으로 __UI 기반 클래스는 UI를 핸들링하거나 안드로이드 OS와 앱의 상호작용을 처리하는 로직만 포함해야 한다.__

UI 기반 클래스를 최대한 가볍게 유지해야 많은 수명 주기 관련 문제를 피할 수 있을 것이다.

Activity와 Fragment 클래스는 Android 운영체제와 Application(앱) 사이의 계약을 나타내도록 이어주는 클래스일 뿐이다.

__즉, 여러 수명 주기를 제어함으로써 사용자가 어떤 동작을 하더라도 그 흐름이 끊어지지 않도록 해주는 것이 UI 기반 클래스__ 라고 생각하면 된다.

__따라서 UI 기반 클래스에서는 수명 주기에 따라 발생할 수 있는 상황에 대처하는 코드만 작성하는 것이 좋다.__

__🧚🏻‍♀️ 두 번째 원칙! "UI와 Model(모델)을 분리하라"__

안드로이드 앱 아키텍처 원칙 중 두 번째로 중요한 원칙은 모델과 UI를 분리해야 한다는 것이다.

이 말의 의미는 __UI 기반 클래스에 데이터나 상태를 저장하지 말라__ 는 말과 같다.

모델은 __앱의 데이터를 담당하는 구성요소__ 로, 앱의 View 객체 및 앱 구성요소와 독립되어 있는 존재여야 한다.

즉, 모델을 UI와 분리하여 앱의 수명 주기나 여러 사용자 환경 흐름에 영향을 받지 않도록 해야한다는 것이다.

## 3️⃣ 권장하는 Android Clean Architecture

위에서 알아본 두 가지 원칙을 지키려면 개발자는 어떻게 코딩해야 할까?

예를 들어, 사용자 프로필 UI를 제작한다고 상상해보자.

이 때, 사용자 프로필 관련 정보는 REST API를 사용해서 서버를 통해 가져온다.

위에서 알아본 두 가지 원칙(UI 기반 클래스 가볍게 하기, UI와 Model 분리하기)를 지키면서 사용자 프로필 기능을 제작하기 위해서는 개발자가 다음과 같은 아키텍처를 구성해야 한다.

아래 구조가 안드로이드에서 권장하는 아키텍처이다.

![02](https://user-images.githubusercontent.com/31889335/83138586-fbe25f00-a125-11ea-9a82-be29de3fc4b0.PNG)

위 다이어그램을 보면 아키텍처의 각 구성요소는 __Activity/Fragment__, __ViewModel__, __Repository__, __Remote Data Source__ 임을 알 수 있다.

또 이 구성요소들은 모두 딱 한 단계 아래의 구성요소에만 종속되어 있음을 알 수 있다.

예를 들어 Activity나 Fragment는 ViewModel에만 종속되어 있는 것이다.

하지만 특이하게도 Repository(저장소)는 여러 개의 다른 클래스에 종속되어 있는 유일한 요소임을 알 수 있다.(위 그림에서 Repository는 Model과 Remote Data Source에 종속되어 있다.)

이제 본격적으로 위와 같은 아키텍처 구조를 따르는 사용자 프로필 기능을 구현해보자! (코드 구현이 아니라 머리로 상상하며 구현해보자.)

1. __사용자 프로필 UI 레이아웃 및 UI 클래스 만들기__

    사용자 프로필 UI를 위해 user_profile_layout.xml 이라는 xml 파일과 UserProfileFragment.kt 라는 Fragment 클래스를 만들었다고 가정하자.

    프로필 UI 안에 들어갈 정보들은 아래와 같이 총 두 가지라고 가정해보자.

    - __사용자 ID__ : 사용자 ID는 Android OS에서 이 앱의 프로세스를 제거해도 이 정보가 계속 유지되어 앱을 다시 시작할 때 ID를 재사용할 수 있도록 하는 역할이다.

        따라서 사용자 ID는 fragment argument 사용하여 프래그먼트에 전달하는 것이 좋다.

    - __사용자 Object__ : 사용자 프로필에 관한 세부 정보를 가지고 있는 데이터 클래스이다. (예를 들어, 이 데이터 클래스에는 사용자 닉네임, 나이, 사진 등이 포함될 수 있다.)

2. __ViewModel 클래스 만들기__

    위에서 본 안드로이드 아키텍처 다이어그램을 보면 Activity/Fragment 아래 단계에 ViewModel이 있는 것을 알 수 있다.

    그렇기 때문에 우리는 UI 기반 클래스를 구현하고 난 후 ViewModel 클래스를 생성해야 한다.

    UserProfileViewModel이라는 이름으로 ViewModel 클래스를 만들어보자.

    그렇다면 대체 [ViewModel](https://developer.android.com/topic/libraries/architecture/viewmodel)이 뭘까?

    __ViewModel은 Activity/Fragment와 같은 UI 구성요소에 데이터를 제공하고 Model과 커뮤니케이션하기 위한 데이터 처리 비즈니스 로직__ 이라고 할 수 있다.

    예를 들어, ViewModel은 UI 구성요소에 데이터를 업데이트하기 위해 ViewModel 하위 단계인 Repository를 호출하고 사용자 요청을 전달받아 데이터를 수정하는 작업을 할 수 있다.

    단, __ViewModel은 UI 기반 클래스가 아닌 일반 클래스이므로 UI에 대해 전혀 알지 못한다. 따라서 Activity나 Fragment의 수명주기 변경에 영향을 받지 않는다.__

지금까지

- user_profile_layout.xml : 프로필 화면의 레이아웃 정의 파일

- UserProfileFragment.kt : 프로필 화면의 레이아웃에 대응하는 Fragment UI 기반 클래스

- UserProfileViewModel.kt : 프로필 화면에 띄워줄 데이터를 준비하거나 프로필 화면으로부터 받은 사용자 요청(서버의 데이터 값 수정 등)에 반응하여 처리 작업을 하는 클래스(이 예시에서는 userId 및 userObject가 이 ViewModel 클래스에서 준비된다.)

이렇게 총 3개의 파일이 만들어졌다.

3. __Repository 클래스 만들기__

    이제 REST API를 통해 Server(Remote Data Source)로부터 사용자 프로필 화면을 보여주기 위해 필요한 데이터를 가져와야 한다.(이 때, 주로 Retrofit 라이브러리와 같은 Android 네트워크 통신을 도와주는 라이브러리를 사용하여 데이터를 가져온다.)

    Android 네트워크 통신과 관련된 코드를 ViewModel 클래스에 작성하여 프로필 화면에 띄워줄 데이터를 준비하는 것도 좋지만

    이렇게 할 경우 __ViewModel 클래스의 역할이 너무 커지게 되고, 앱의 규모가 커지면 유지 보수가 어려울__ 수 있다.

    따라서 Android 네트워크 통신과 관련된 코드를 ViewModel에서 분리하는 것이 좋다.

    네트워트 통신 코드가 분리되어 있는 클래스를 __Repository(저장소) 클래스__ 라고 부른다.

    UserProfileRepository.kt 라는 클래스를 생성하고 이 안에 네트워크 통신 로직을 작성하면 된다.

4. __ViewModel 클래스와 Repository 클래스 연결하기__

    이제 Repository 클래스에서 서버와의 통신을 통해 가져온 데이터를 ViewModel 클래스에 넘겨주어 ViewModel 클래스가 UI 기반 클래스에 존재하는 UI 객체에 반영시킬 데이터를 준비하도록 해줘야 한다.

5. __ViewModel 클래스에서 데이터가 준비되었다고 UI 객체에게 알리기__

    이제 ViewModel 클래스는 Repository 클래스에서 넘겨받은 데이터를 가지고 있게 된다. 즉, __UI 객체에 업데이트 해줄 데이터가 준비된 상태__ 이다.

    따라서 __ViewModel 클래스에서 데이터가 준비되었다고 UI에게 알리는 방법이 필요하다.__

    이 때, ViewModel 클래스에서 __[LiveData](https://developer.android.com/topic/libraries/architecture/livedata)__ 라는 녀석을 사용하면 데이터가 준비되었다고 UI에게 알릴 수 있게 된다.

    __LiveData__ 는 __데이터를 담고 있는 Holder(홀더)인데 자신이 담고 있는 데이터가 변경되었는지를 식별할 수 있는 Holder__ 이다.

    따라서 LiveData를 통해 데이터 변경사항을 모니터링할 수 있게 된다.

    이 예제에서는 LiveData가 userId와 userObject 라는 데이터를 담고 있는 상태라고 볼 수 있다.

6. __UI 기반 클래스에서 LiveData를 관찰하고 있다가 변경 신호를 받으면 데이터를 업데이트하기__

    이제 UI 기반 클래스에서 ViewModel 클래스에 존재하는 LiveData를 observe(관찰)하여야 한다. 그래야 LiveData가 알려주는 신호를 알아차릴 수 있기 때문이다.

    LiveData가 자신이 담고 있는 데이터가 변경되었다는 신호를 발생하면 이 LiveData를 observe(관찰)하고 있던 UI 기반 클래스에서 이를 알아차리게 되어 UI 객체에 업데이트 작업을 해주면 된다.

여기까지 하면 위에서 보았던

![03](https://user-images.githubusercontent.com/31889335/83407257-4a0ba100-a44b-11ea-9849-238ebd515768.PNG)

다이어그램 구조대로 기능 하나를 완성시킨 것이 된다. (데이터를 제공해주는 Source가 서버였기 때문에 빨간 박스 처리한 부분의 로직을 따라한 것이다.)

처음부터 다시 한 번 쭉 읽어본다면 Android Clean Architecture가 왜 등장했고, 어떻게 구현할 수 있는지 이해될 것이다!

# 끝!

이 포스팅에서는 Android Clean Architecture의 실제 구현 코드를 언급하지는 않았지만 전체적인 구조를 이해하는데 집중하였다.

따라서 각 단계에서 등장했던 LiveData 사용법, Repository 구현법, ViewModel 구현법, UI 기반 클래스에서 LiveData observe 구현법 등에 대해서는 따로 공부할 필요가 있다! 화이탱~ 💪🏻
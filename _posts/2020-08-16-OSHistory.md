---
layout: post
title:  "[운영체제] 👩🏼‍💻 2. 운영체제의 역사에 대해 알아보자"
date:   2020-08-16 18:34:10 +0700
categories: [operating system]
---

> [경성대학교 양희재 교수님 - 운영체제의 역사](http://www.kocw.net/home/cview.do?lid=31dfd5c232f54591) 을 보고 포스팅한 것입니다.

<br>

# [👩🏼‍💻 2. 운영체제의 역사에 대해 알아보자]

## 1️⃣ 최초의 컴퓨터(초기 컴퓨터의 동작 방식)

최초의 컴퓨터는 무려 1940년대 말에 발명되었다. 

<img width="393" alt="01" src="https://user-images.githubusercontent.com/31889335/90332454-ee879300-dff7-11ea-948e-b3c13d4fd691.png">

초기 컴퓨터는 위와 같은 모습을 하고 있었으며 크기 자체가 너무 커 건물 하나를 차지하는 정도였다.

그 중에서도 입력장치인 카드리더기가 차지하는 공간이 가장 컸다.

초기 컴퓨터의 입력은 천공카드였다. 천공카드는 주로 시험을 볼 때 사용하는 OMR 카드와 비슷했지만 OMR 카드에서 검정색으로 칠하는 동그란 부분을 구멍을 뚫어 표현하는 방식이였다.

아래 사진이 천공카드이다! 예를 들어, y=x+3을 표현하기 위해 y에 해당하는 자리에 구멍을 뚫고, =에 해당하는 자리에 구멍을 뚫는 형식이라고 생각하면 된다.

<img width="1343" alt="02" src="https://user-images.githubusercontent.com/31889335/90332740-88503f80-dffa-11ea-8c91-9458cde03bf1.png">

입력장치인 카드리더기가 읽은 천공카드의 내용이 메모리에 저장되고 나면 프로세서가 메모리에서 읽은 명령어들을 읽어 처리하였다.

하지만 이렇게 초기 컴퓨터가 명령어들(프로그램)을 처리하는 과정을 더 정확히 설명하기 위해서는 컴파일러가 존재했다는 것도 알아야한다.

메모리에 천공카드에서 읽은 명령어들이 저장된 후에는 컴파일러 프로그램(명령어들)이 들은 천공카드를 카드리더기에 올린다.

왜냐하면 입력받은 프로그램을 프로세서가 처리하기 위해서는 명령어들이 기계어로 변환되어야 하기 때문이다.

컴파일러 프로그램이 들은 천공카드를 카드리더기에 읽히게 되면 메모리에 컴파일러도 올라가게 되고 이 컴파이러가 이미 메모리에 올라와있는 프로그램들을 기계어로 번역을 하게 된다.

이제서야 기계어로 번역된 프로그램을 프로세서가 처리하게 되는 것이다.

그 다음, 그 당시에는 모니터라는 것이 없었기 때문에 처리기가 처리한 내용을 프린터를 사용해 종이에 찍어 출력하였는데 초기 프린터는 망치(해머)로 종이를 두들겨서 출력하는 방식이였다.

이러한 전 과정은 컴퓨터 전문가인 Operator 라는 사람이하고 관리하였다.

여기서 알 수 있는 사실은 초기 컴퓨터가 등장했던 1940~1950년대에는 운영체제가 없었다는 것이다!

<br>

## 2️⃣ 최초의 운영체제가 등장하다!

위에서 공부한 내용처럼 초기의 컴퓨터는 사람이 일일이 천공카드를 카드리더기에 올리고 컴파일러도 올려야했기 때문에 불편한 점이 많았고, 기술이 점점 발전하면서 이러한 작업을 사람이 할 것이 아니라 컴퓨터 스스로하게 할 수 없을까? 라는 생각을 하게 되었다.

그래서 이 때, __Batch Processing System__ 이라는 것이 등장하게 되었다!

Batch는 꾸러기, 묶음이라는 뜻을 가지고 있다. 즉, Batch Processing은 묶어서 처리한다라는 의미이고 우리말로는 일괄처리라고 한다.

위에서 알아본 내용 중 사람은 프로그램 하나를 실행하고 싶을 때마다 컴파일러 프로그램도 카드리더기에 직접 올려야했고 그 외에 링킹 프로그램 올리기, 로딩 프로그램 올리기 등 여러가지 할 일들이 많았다.

그래서 컴파일러, 링킹, 로딩 프로그램 올리는 일련의 과정을 사람이 아닌 컴퓨터가 처리해주는 프로그램을 만들어 이 프로그램 하나를 처음부터 메모리에 올려둠으로써 사람이 할 일을 줄이자! 라는 개념이 등장하였다.

이 일련의 과정을 처리해주는 프로그램을 resident(레지던트) monitor 라고 불렀다.

> resident 라는 단어는 '상주한다' 라는 의미를 가지고 있다.

결국 Batch Processing 시스템이 최초의 운영체제였던 것이다.

<br>

## 3️⃣ MultiProgramming System의 등장

최초의 운영체제인 Batch Processing이 등장한 후, 기술의 발전이 계속되어 하드디스크가 발명되게 되었고, 진공관 형태였던 프로세서도 트랜지스터를 이용하여 반도체 형태로 만들어지게 되었다.

이렇게 기술이 한창 발전하고 있을 시기에 컴퓨터 분야에서도 한 가지 불편함을 해결하고자 하려는 노력이 생겨나게 되었다!

초기 컴퓨터는 운영체제와 단 한 개의 프로그램만 메모리에 올라갈 수 있는 구조였다. 즉, 최초의 운영체제인 Batch Processing 시스템과 실행시킬 프로그램 한 개만 메모리에 올라갔다는 것이다.

예를 들어, 초기 컴퓨터가 실행시킬 다음과 같은 간단한 프로그램 하나가 존재할 때 동작하는 것들을 봐보자.

c++ 언어로 작성하였지만 입력은 카드리더기로, 출력은 프린터로 한다고 상상하자!

~~~c++
#include<iostream>
using namespace std;

int main(){
    int a = 0;
    int b;
    cin>>b;
    for(int i = 0 ; i < 10 ; i++){
        a += b + 1;
    }
    print(a);
}
~~~

이러한 실행시킬 프로그램이 있다고 가정했을 때, 변수를 선언하고 산수 계산을 하는 것은 프로세서의 역할이다.

하지만 cin과 print 명령은 프로세서가 처리하는 것이 아니라 입력장치인 카드리더기와 프린터의 역할이다.

이렇게 하나의 프로그램이 실행될 때는 프로세서와 입/출력 장치들이 번갈아가면서 동작하게 된다.

하지만 그 당시의 사람들이 이 과정에서 인식하게 된 문제가 하나 있었다!

카드리더기나 프린터가 작동하고 있을 때, 프로세서는 따로 계산할 일들이 없기 때문에 아무 일도 하지 않은채 작동하게 된다는 것이 문제였다.

> 이렇게 프로세서가 아무일도 하지 않는 현상을 __cpu idle__ 이라고 부른다.

왜냐하면 초기 컴퓨터는 크기도 클 뿐더러 가격도 엄청 비쌌기 때문에 비싼 자원 중 하나인 프로세서가 아무 일도 하지 않은채 돌아가고만 있다는 것은 비용적인 측면에서 큰 손해였다.

심지어 너무 비싼 가격때문에 그 당시 우리나라는 컴퓨터를 소지하고 있지도 않을 정도였다.

또한 프로세서는 처리 속도가 빠르지만 입/출력 장치인 카드리더기와 프린트는 처리 속도가 느리고 오래 걸렸기 때문에 시간적인 측면에서도 손해였다.

그래서 사람들이 생각한 방법은 __메모리에 단 한 개의 프로그램만 올릴 수 있는 것이 아니라 여러 프로그램을 올릴 수 있도록 기술을 개발하자!__ 였다.

메모리에 여러 프로그램을 올리게 됨으로써 얻는 장점은 다음과 같았다.

<img width="834" alt="03" src="https://user-images.githubusercontent.com/31889335/90334037-9b1c4180-e005-11ea-9c10-d7b8951f84a2.png">

프로그램 1에서 입출력장치가 실행되어야 한다면 프로세서는 할 일 없이 있는 것이 아니라 다음 프로그램인 프로그램 2의 계산 부분을 처리하면 된다.

또 프로그램 2에서 입출력장치가 실행되어야 한다면 프로그램 3의 계산 부분을 처리하면 되는 것이다.

즉, 프로세서가 아무 일도 하지 않은 채 작동하는 일이 없어지게 된 것이다!

> 20분 54초부터 다시 보기!


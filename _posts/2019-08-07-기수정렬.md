---
layout: post
title:  "[알고리즘] 🐾 기수정렬"
date:   2019-08-07 18:34:10 +0700
categories: [c++]
---

> --> [그림으로 배우는 알고리즘](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=85969851) 책 참고

<br>

## 🐾 기수 정렬이란?
---

영어로 __Radix(기수) Sort__ 라고도 하는 이 정렬은 정렬할 수들의 1의 자릿수부터 윗 자릿수까지 버킷 정렬을 반복하는 정렬이다.

<br>

- _무슨 말이지?_

	만약, [버킷 정렬](https://choheeis.github.io/c++/2019/08/07/%EB%B2%84%ED%82%B7%EC%A0%95%EB%A0%AC.html) 로 10개의 수인 123, 602, 082, 777, 057, 510, 396, 196, 843, 138를 정렬한다면?

	10개의 수 중 최대값이 843이므로 0 ~ 843까지의 index를 가지는 배열이 필요하다. 이런 경우 __메모리 낭비__ 가 심해지는 경우가 있을 수 있다는 것을 느낄 수 있다.

	따라서 버킷 정렬을 활용하여 메모리 낭비를 줄인 또 다른 정렬 방법이 바로 radix sort 이다.

	<br>

- _본격적으로 알아보자!_

	일단, 기수 정렬이 동작하는 흐름을 살펴보자.

	기수 정렬은 어떤 숫자를 구성할 수 있는 수인 0 부터 9까지의 수만큼의 원소가 필요하다.

	즉, 10개의 수인 0, 1, 2, 3, 4, 5, 6, 7, 8, 9를 index로 갖는 10개의 원소가 필요한 것이다.

	<br>
	
	__가장 먼저,__ 기수 정렬은 데이터의 1의 자리만을 보고 버킷정렬을 실행한다.

	이 때, 왼쪽에 위치한 데이터부터 차례대로 1의 자리를 탐색하며 정렬한다.

	즉, 아래와 같은 정렬이 실행된다.

	![01](https://user-images.githubusercontent.com/31889335/62849805-001ac880-bd1c-11e9-8420-972bf3f9a0e7.PNG)

	<br>

	__두 번째로,__ 이번에는 1차 정렬에서 정렬된 데이터의 순서대로 10의 자리를 탐색하여 다시 한번 정렬한다.

	즉, 아래와 같은 정렬이 실행된다.

	![02](https://user-images.githubusercontent.com/31889335/62850211-20975280-bd1d-11e9-8a92-1f9662bac1c2.PNG)

	<br>

	__세 번째로,__ 2차 정렬에서 정렬된 데이터의 순서대로 100의 자리를 탐색하여 다시 한번 정렬한다.

	즉, 아래와 같은 정렬이 실행된다.

	![03](https://user-images.githubusercontent.com/31889335/62850530-175ab580-bd1e-11e9-8b0d-f20ab4cce52a.PNG)

	3번의 정렬에 의해 정렬이 완료된다!

	정렬을 몇 차까지 반복해야 하는지는 데이터의 자릿수에 달려있다. 정렬하고자 하는 수들이 네 자릿수이면 1의 자리부터 1000의 자리까지 4번 정렬을 반복해야 한다.

	<br>

	> __기수 정렬에서 왜 제일 큰 자릿수부터 정렬을 하지 않는지에 대해서!__
	>
	> 4개의 수 156, 113, 279, 529를 100의자리부터 정렬한다고 하면 1차 정렬의 결과로 156, 113, 279, 529가 된다. 이어서 2차 정렬을 하면 113, 529, 156, 279가 된다. 3차 정렬을 하면 113, 156, 529, 279가 된다. 
	>
	> 즉, 올바르지 않은 정렬이 결과로 출력될 것이다!
	>
	> 1의 자리 부터 정렬을 해야 1차 정렬에서 1의 자리 대소 비교가 완벽한 정렬이 생성되기 때문에 반드시 1의 자리부터 정렬을 해야 한다.
	>
	> __기수 정렬을 하기 위해 알아야 할 것!__
	>
	> 정렬할 데이터들의 최대 자릿수를 알아야 버킷정렬을 몇번 반복할지 알 수 있다.

	<br>

## 🐾 기수 정렬 알고리즘
---

기수 정렬의 흐름을 이해했으면 코드로 작성해보자!

> --> [참고한 사이트](https://sexycoder.tistory.com/74)

~~~c++
#include<iostream>
#include<queue>
using namespace std;

int main(){
	// 정렬할 데이터 초기화 
	int arr[8] = {170, 45, 75, 90, 2, 24, 802, 99};
	// 큐 10개 선언(0 ~ 9 까지 수에 대한 큐) 
	queue<int> q[10]; 
	
	// 데이터 중 가장 큰 수 구하기(최대 자릿수 구하기 위함) 
	int max = arr[0]; 
	for(int i = 1 ; i < 8 ; i++){
		if(max < arr[i]) max = arr[i];
	}
	
	// 최대 자릿수 구하기
	int count = 0, Q = max; // 최대 자릿수, 몫 변수 
	while(Q > 0){
		Q = Q/10;
		count++; 
	} 
	
	/* 기수 정렬 알고리즘 */ 
	int mod = 10, div = 1, rotation = 0; // rotation은 while문이 돌아간 횟수를 세기 위한 변수
	while(rotation < count){
		for(int j = 0 ; j < 8 ; j++){
		// rotation이 0일 때는 1의 자릿수가 구해져서 해당 큐에 넣어짐
		// rotation이 1일 때는 10의 자릿수가 구해져서 해당 큐에 넣어짐
		// rotation이 2일 때는 100의 자릿수가 구해져 해당 큐에 넣어짐
			q[(arr[j]%mod) / div].push(arr[j]);
		}	
	
		for(int i = 0 , j = 0 ; i < 10; ){
			// 큐가 비어있지 않으면 
			if(q[i].size() != 0){
				// arr배열을 queue에 저장된 순서대로 다시 초기화함. 
				arr[j] = q[i].front();
				q[i].pop();
				j++;
			}
			else i++;
		}	
		
		div *= 10;
		mod *= 10;
		rotation++;
	}
	 
	for(int i = 0 ; i < 8 ; i++){
		printf("%d ", arr[i]);
	}
	
}
~~~

<br>

코드를 살펴보자!.

우선, 0 부터 9까지에 해당하는 큐를 10개 만든다. 

처음에 1의 자리의 수들을 버킷정렬하여 해당 큐에 넣는다. 

데이터를 저장해놓은 arr를 0 ~ 9까지의 큐에 저장되어있는 데이터 순서대로 다시 배치한다.

그런 다음, 이 arr의 데이터의 10의 자리 수들을 버킷정렬하여 해당 큐에 넣는다. (이 때, 모든 큐에는 데이터가 없다. 왜냐하면 arr에 큐의 데이터들을 넣을 때 pop() 함수로 큐의 데이터를 삭제했기 때문이다!)

이와 같은 과정을 최대자리수인 100의 자리 수들을 버킷정렬 할 때까지 반복한다.

div와 mod 변수를 변화시킴으로써 1의자리, 10의자리, 100의 자리수를 구하는 것이다.










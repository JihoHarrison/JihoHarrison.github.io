---
layout: post
title:  "[자료구조] 🎁 꼭! 알아두어야 할 자료구조들!"
date:   2019-07-16 18:34:10 +0700
categories: [c++]
---

> [그림으로 배우는 알고리즘](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=85969851) 이라는 책으로 자료구조를 쉽게 이해해보았다!
>

<br>

## 📚 꼭! 알고 있어야 할 자료구조들!
---

__자료구조__ 라는 것은 데이터의 효율적인 접근 및 수정을 위한 자료의 조직, 관리, 저장 방법에 관한 것이다.

즉, 데이터를 모아 놓고 데이터 간의 관계, 데이터에 적용 가능한 함수 등이 모여 있는 것을 자료구조라고 부른다.

알고리즘과 자료구조는 뗄 수 없는 관계이다. 문제를 해결하기 위해 알고리즘을 선택했다면 선택한 알고리즘을 토대로 자료구조를 선택해야 하기 때문이다.

또, 데이터를 관리하고 조작하기 위해 자료구조를 선택했다면 선택한 자료구조를 토대로 알고리즘을 선택할 수도 있다.

<br>

- _배열_

    데이터를 빈틈없이 나열한 자료구조이다.

    직선형(1차원 배열), 직사각형형(2차원 배열), 직육면체 형(3차원 배열) 등이 있다.

    <br>

- _리스트_

    데이터를 순서대로 나열한 자료구조이다.

    배열과 같이 순서가 있는 데이터를 저장하고 관리한다.

    하지만 배열과 다르게 데이터들이 화살표로 서로 연결되어 있어 데이터들이 떨어진 장소에 위치해도 된다는 점이 장점이다.

    ![리스트](https://user-images.githubusercontent.com/31889335/61299760-ab1e8c00-a81b-11e9-84a3-4f27706bb1d9.PNG)

    리스트는 크게 두 가지 종류로 나뉜다.

    <br>

    - __단방향 리스트__ 

        단방향 리스트의 각 요소에는 2가지 항목이 들어있는데 데이터와 다음 요소를 가리키는 포인터이다.

        이 때, 포인터가 위 그림에서 화살표 역할을 하는 친구이다.

        이 포인터는 다음 요소가 어디에 있는지 __위치정보__ 가 저장되어 있다.

        또한, 단방향 리스트의 마지막 요소의 포인터에는 이제 다음 요소가 더이상 없다는 뜻의 종료 정보가 저장되어 있다.

        여기에 더불어 단방향 리스트에는 HEAD 포인터라는 특별한 포인터가 따로 존재하는데 여기에는 리스트의 맨 처음 요소의 위치 정보가 저장되어 있다.

        ![단방향리스트](https://user-images.githubusercontent.com/31889335/61359643-b8895400-a8b7-11e9-89bc-44f64bd6213d.PNG)

        만약, 단방향 리스트에 아무 데이터가 저장되어 있지 않아 리스트가 비어있는 경우, HEAD 포인터에는 종료 정보가 저장된다.

        <br>

    - __양방향 리스트__

        양방향이라는 뜻과 같이, 이 리스트는 화살표 방향이 두 방향으로 존재하는 리스트이다.

        따라서 리스트의 각 요소에는 데이터, 다음 요소를 가리키는 포인터 외에도 이전 요소를 가리키는 포인터가 추가로 포함되어 있다.

        이전 요소를 가리키는 포인터에는 이전 요소가 어디에 있는지에 대한 위치 정보가 저장되어 있다.

         또한, 단방향 리스트에서 HEAD 포인터가 존재헀던 것과 같은 맥락으로, 양방향 리스트는 HEAD 포인터와 TAIL 포인터를 둘 다 가지고 있다. 

         양방향 리스트에서 HEAD 포인터에는 첫 번째 요소의 위치 정보가 저장되어 있으며, TAIL 포인터에는 마지막 요소의 위치정보가 저장되어 있다.

         만약, 리스트가 비어있다면 HEAD, TAIL 포인터에 모두 종료 정보가 저장된다.

         ![양방향리스트](https://user-images.githubusercontent.com/31889335/61360167-d4d9c080-a8b8-11e9-8863-9e3124737ef3.PNG)

        <br>

    > 👀 배열과 리스트를 비교해보자!
    >
    > __1. N번째 요소를 찾아야할 때__ 리스트보다는 배열을 사용하는 것이 더 편리하다!
    >
    > --> 배열은 index 값을 통해 N번째 요소를 즉시 찾을 수 있지만 리스트는 N번째 값을 찾기 위해 첫번째 요소부터 순서대로 N번째 요소까지 확인하여야 한다.
    > 
    > __2. 데이터를 중간지점에 삽입해야 할 때__ 배열보다는 리스트를 사용하는 것이 더 효율적이다!
    >
    > --> 배열의 중간에 새로운 데이터를 삽입하기 위해서는 삽입 위치 다음에 존재하는 모든 요소들을 한칸씩 뒤로 이동시켜야 한다. 만약 1000개의 요소들을 한칸씩 뒤로 이동시켜야 한다면 시간 소모가 커질 것이다!
    >
    > 하지만 리스트의 중간에 새로운 데이터를 삽입한다면 삽입 요소의 바로 직전 요소가 가지는 '다음요소 위치 정보' 와 삽입 요소의 '다음요소 위치 정보'만 수정하면 되므로 배열보다 더 효율적이다.
    >
    > __3. 중간지점의 데이터를 삭제해야 할 때__
    > 
    > 데이터를 중간지점에 삽입하는 경우와 마찬가지로 배열보다 리스트를 사용하는 것이 더 효율적이다!
    >
    > 배열의 중간 데이터를 삭제한다면 삭제 위치 다음의 모든 요소들을 한칸씩 앞으로 이동시켜야 한다.
    >
    > 하지만 리스트 중간 지점의 데이터를 삭제한다면 위치정보만 수정하면 된다.

    <br>

- _스택(Stack)_

    책상 위에 책을 쌓듯 데이터를 저장하고 관리하는 자료구조이다.

    일반적으로 쌓여있는 책은 가장 위쪽부터 꺼내는 것이 안전하듯이 스택도 가장 위쪽 데이터부터 꺼낼 사용할 수 있다.

    즉, 스택 자료구조를 사용하면 데이터를 넣은 순서와 반대의 순서로 데이터를 꺼낼 수 밖에 없다.

    
    ![스택](https://user-images.githubusercontent.com/31889335/61307781-eb850680-a829-11e9-82ea-6a90a10ed922.PNG)

    스택 자료구조를 사용하여 데이터를 관리할 때는 아래 두 가지 작업을 알아두어야 한다.

    - __PUSH__ : 스택 자료구조에 데이터를 넣는 작업

    - __POP__ : 스택 자료구조에서 데이터를 꺼내는 작업

    이렇게 마지막으로 넣어진 데이터를 제일 먼저 뺄 수 있는 구조는 __Last-In First-Out__ 이라고 부르고 줄여서 __LIFO__ 라고 한다.

    <br>

- _큐(Queue - 대기행렬)_

    계산대에 먼저 줄을 선 손님부터 계산을 해주듯 데이터를 저장하고 관리하는 자료구조이다.

    즉, 큐 자료구조를 사용하면 먼저 들어온 데이터부터 꺼낼 수 있다.

    > 운영체제 수업 때 프로세스 레디 큐 구조를 떠올리자!

    ![큐](https://user-images.githubusercontent.com/31889335/61307642-a7920180-a829-11e9-915d-e74543937321.PNG)

    <br>

    큐와 같이 처음 들어온 원소부터 빠지는 방식을 __FIFO(First In First Out)__ 방식이라고 한다.

- _트리_

    나뭇 가지가 나뉘듯 퍼져 나가는 자료구조이다.

    ![트리](https://user-images.githubusercontent.com/31889335/61307349-22a6e800-a829-11e9-9305-ff4f9b55f2c8.PNG)

    <br>

- _링 버퍼(ring buffer)_

    1차원 배열은 각 요소에 index를 통해 참조할 수 있다. 하지만 1차원 배열은 처음과 끝이 존재한다.

    즉, 크기가 10인 1차원 배열의 처음 index는 0이고, 마지막 index는 9이다. 

    따라서 마지막 index에 +1을 한 index는 존재하지 않는다.

    하지만 __ring buffer__ 라는 자료구조에서는 마지막 index에 +1을 한 index가 존재한다.
    
    ring buffer는 1차원 배열의 처음과 끝을 원모양이 되도록 붙여놓은 자료구조이다. 

    ![링버퍼](https://user-images.githubusercontent.com/31889335/62105437-52e88f00-b2dd-11e9-89ed-0dde7b44d3d9.PNG)

    <br>

- _이진트리_

    이진트리는 다음 요소를 가리키는 포인터를 2개 가진 단방향 리스트의 일종이다. 즉, 데이터 x의 다음 요소로 데이터 L과 데이터 R이 존재하는 자료구조이다.

    ![이진트리](https://user-images.githubusercontent.com/31889335/62107160-fc318400-b2e1-11e9-983e-cf9394d4aa33.PNG)

    이진트리는 각 요소들을 __노드__ 라고 부른다. 위 그림에서 데이터 X를 부모노드, 데이터 L과 데이터 R을 자식노드라고 부른다.

    자식노드에 데이터 L과 R이 반드시 있을 필요는 없으며 왼쪽 자식 노드만 있거나 오른쪽 자식 노드만 있을 수도 있다.

    __하지만! 자식 노드를 3개 이상 가질 수는 없다.__

    또한, 아래 그림과 같이 자식 노드는 또 다른 자식 노드의 부모 노드가 될 수 있다.  

    ![이진트리2](https://user-images.githubusercontent.com/31889335/62107640-056f2080-b2e3-11e9-9be1-35658f0c0379.PNG)

    이진트리에서 맨 처음 노드를 루트 노드라고 부르며, 더 이상 자식 노드가 없는 노드를 리프 노드라고 부른다.

    <br>

- _힙_

    위 이진트리에서 각 노드의 값이 __"부모 노드의 값(데이터)은 항상 하위 노드의 값보다 작다"__ 를 만족하는 이진트리를 __힙__ 이라고 부른다.

    ![힙1](https://user-images.githubusercontent.com/31889335/62107833-73b3e300-b2e3-11e9-81c3-dd9f56a1061a.PNG)

    위 그림에서 보면 부모 노드의 데이터 값은 항상 하위 노드의 데이터 값보다 작다!

    자식 노드 간의 대소 비교는 상관하지 않는다.

    따라서 힙의 루트 노드에는 항상 최솟값이 저장된다. 

    힙의 조건은 __"부모 노드의 값(데이터)은 항상 하위 노드의 값보다 크다"__ 도 가능하다. 이 경우에는 루트 노드에 항상 최댓값이 저장된다.

    따라서 힙은 최솟값과 최댓값을 효율적으로 구하는데 적합하다.

    실제로 힙을 구현할 때는 배열을 사용하고, 힙의 아래서 위로, 힙의 왼쪽에서 오른쪽 방향으로 훑으면서 데이터를 배열에 차례로 저장한다.

    아래 그림은 위에서 보여준 힙 그림을 배열로 구현한 것을 보여주는 그림이다.

    ![힙2](https://user-images.githubusercontent.com/31889335/62108211-74994480-b2e4-11e9-94d7-7499e7c7051d.PNG)

    <br>

- _해시 테이블_

    해시 테이블은 __1. N개의 요소를 가진 루트 배열이라는 이름의 배열__ 과 __2. 루트 배열의 각 요소들이 가리키는 리스트__ 이 2개의 자료구조가 결합된 자료구조이다.

    아래 그림을 보며 이해하자!

    ![해시테이블1](https://user-images.githubusercontent.com/31889335/62108908-25ecaa00-b2e6-11e9-91f2-e91e68a8092f.PNG)

    즉, 데이터들은 배열 요소가 가리키는 하나의 리스트에 저장되어있다. 즉, 데이터들이 그룹화 되어 있는 것이다. 

    만약 해시테이블로 데이터들을 관리할 경우, 필요한 데이터를 찾기 위해서는 먼저 루트 배열 요소를 알아야 한다. 왜냐하면 루트 배열 요소가 각 리스트를 가리키고 있기 때문이다.

    해시 테이블에서는 이 배열의 요소 번호를 구할 때 __해시 함수__ 라는 것을 사용한다. 

    해시 함수는 데이터를 함수의 입력으로 넣으면 0 ~ N 사이의 값인 배열 요소 번호를 출력해주는 함수이다. 

    이렇게 해시 함수를 통해 루트 배열 요소의 번호를 구한 후, 해당 배열 요소가 가리키는 리스트에 접근하여 순차적으로 리스트를 탐색하여 원하는 데이터를 찾을 수 있다.

    <br>

- _그래프_

    그래프는 2개 이상의 항목이 어떤 관계를 맺고 있는지에 주목하여 이 관계를 그림으로 나타낸 것이다.

    그래프에서는 각 항목을 __정점(노드)__ 라고 부르고, 각 항목들의 관계를 표현하는 선을 __간선(edge)__ 라고 부른다.

    ![그래프1](https://user-images.githubusercontent.com/31889335/62113128-ff7f3c80-b2ee-11e9-83b5-a48098c1d953.PNG)
 
    위 그림은 간선에 __방향성이 없는__ 그래프를 나타낸 것이다. 위 그래프에 따르면 A 에서 C로 한번에 갈 수 있는 방법은 없다는 것을 알 수 있다. 또한, B에서 D로도 한번에 갈 수 없다.

    ![그래프2](https://user-images.githubusercontent.com/31889335/62113407-859b8300-b2ef-11e9-81c4-555769deb945.PNG)

    위 그림은 간선에 __방향성이 있는__ 그래프를 나타낸 것이다. 이 경우에 정점 D에서 B로 가려면 D, E, A 를 순서대로 거쳐야 함을 알 수 있다.

    ![그래프3](https://user-images.githubusercontent.com/31889335/62113609-db702b00-b2ef-11e9-95e5-b5bf5638a53f.PNG)

    위 그림은 간선에 __가중치가 있는__ 그래프를 나타낸 것이다. 이 그래프에서는 각 정점사이를 이동할 때 필요한 가중치를 계산할 수 있다.

    <br>

    > 쉬운 책으로 자료구조 __개념__ 에 대해 쭉 봐보니 알고리즘을 공부할 때 등장했던 것들이 지금은 어렵게 느껴지지 않는다! 
    >
    > 역시 쉽게 쉽게 접근하는 것이 이해와 정신건강에 좋다! ㅋㅋㅋ
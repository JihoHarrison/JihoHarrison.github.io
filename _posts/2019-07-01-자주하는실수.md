---
layout: post
title:  "[알고리즘] 😅 알고리즘 문제 풀 때 실수하지 말자!"
date:   2019-07-04 18:34:10 +0700
categories: [algorithm]
---

> 🐋 '프로그래밍 대회에서 배우는 알고리즘 문제해결전략(구종만)' 이라는 책 읽고 배우기 프로젝트
>
> 문제를 풀 때 자주하는 실수들에 관한 포스팅
>
> "남의 실수로부터 배워 유사한 실수를 저지르지 않는 것이 가장 좋은 방법이다" - 구종만님

<br>

## 배열 범위 밖 원소에 접근하는 실수
---

- _배열 범위가 아닌 인덱스에 접근하는 경우 c언어와 c++은 런타임 오류를 낸다_

	하지만 런타임 오류가 나지 않는 경우도 있다!

	언제일까?

	만약 

	~~~c
	// arr 배열에 접근할 수 있는 인덱스는 0 ~ 9 이다.
	int arr[10], num;
	~~~

	이라고 선언되어 있는 경우, 프로그램을 실행시켰을 때 arr 배열과 num 이 메모리 상에서 연속해서 위치하게 되었다고 가정하자.

	이 때, 실수로 arr[10] 에 접근하여 값을 바꿨다면 의도하지 않은 num 변수의 값이 바뀌게 된다! 이런 경우에는 런타임 에러를 발생시키지 않기 때문에 매우 찾기 어려운 버그로 존재하게 된다.

	> 헐.. 이런 경우도 있다니

	<br>

## 일관성 없는 범위 표현방식을 사용할 때 발생하는 실수
---

범위를 표현하는 방식에는 2가지 방식이 있다.

__닫힌 구간 방식__ & __열린 구간 방식__

- _닫힌 구간 방식_

	![닫힌구간](https://user-images.githubusercontent.com/31889335/60645840-cb8e3400-9e74-11e9-9dc2-1252a9eacf00.PNG)

	<br>

- _열린 구간 방식_

	![열린구간](https://user-images.githubusercontent.com/31889335/60645836-ca5d0700-9e74-11e9-98be-4b01f430dc51.PNG)

	<br>

- 대부분의 프로그래밍 언어는 __반 열린 구간__ 을 사용한다. 반 열린 구간은 첫 번째 값은 집합 안에 포함하고(닫힌구간으로 표시), 다른 하나는 집합 안에 포함하지 않는(열린구간으로 표시) 방식이다.

	![반열린구간](https://user-images.githubusercontent.com/31889335/60646028-3f304100-9e75-11e9-9b85-297b201d35f2.PNG)

	예를 들어, 배열의 인덱스를 표현할 때 반 열린 구간을 자주 사용하는데 첫번째 인덱스는 0 이고, 마지막 인덱스는 n-1 을 사용한다. 즉, 배열 인덱스 범위를 __0 \<= 인덱스 \< n__ 으로 표현하는 것이다!

	또한, c++ STL에서도 범위를 표현할 때 begin() 과 end() 를 사용하며 이 때 begin() 은 첫번째 원소를 가리키지만 end() 는 마지막 원소가 아닌 마지막 원소 다음의 원소를 가리킨다.

- _반 열린 구간을 사용하면 좋은점_

	- 공집합을 표현할 수 있다.

		예를 들어, __2 \<= i \< 2__ 는 만족하는 i 가 없으므로 공집합을 나타내는 범위이다.

	- 두 구간이 연속해 있는지를 쉽게 알 수 있다.

		예를 들어, __a \<= i \< b__ 와 __c \<= i \< d__ 가 연속하는 구간인지를 확인하기 위해서 b = c 인지만을 확인하면 된다.

	- 구간의 크기를 쉽게 알 수 있다.

		__a \<= i \< b__ 구간의 크기는 b - a 이므로 크기를 쉽게 알 수 있다.

		<br>

## 스택 오버플로우가 발생하는 경우
---

- _스택(stack) 오버플로우란?_

	소스코드 컴파일이 완료되면 실행파일이 만들어지고, 이 실행파일을 실행시키면 실행파일이 메모리에 올라가게 된다.

	> 운영체제 수업때 배운 내용을 되살려보자!
	>
	> 한 프로그램에 주어지는 메모리는 사실 여러 공간으로 나누어져 있는데 heap공간, stack공간, data공간, code공간으로 나누어진다.
	>
	> 👀 이 공간들 중 stack 공간은 용량이 1메가 정도로 한정되어 있다!
	>
	> 사실 stack 공간의 최대 크기는 언어나 아키텍처 등에 따라 다르기 때문에 각 언어에 따른 스택 허용량에 대해 알아 둘 필요가 있다. 또는 컴파일시에 스택 허용량을 설정할 수도 있다!

	<br>

	이 때, 이 프로그램이 많은 stack 공간을 사용하도록 구현되어 있다면 정해진 stack 공간을 초과할 수 있는데 이 경우 __스택 오버플로우__ 가 발생했다고 한다.

	스택 오버플로우가 발생하면 실행중이던 프로그램이 강제종료된다!

	<br>

- _스택 오버플로우는 어떤 경우에 발생하는가?_

	주로 스택 오버플로우는 재귀 호출의 깊이가 너무 깊어질 경우에 발생한다.

	또, 지역변수는 stack 공간에 자리잡기 때문에 지역변수로 너무 큰 배열을 잡을 경우에도 스택 오버플로우가 발생할 수 있다.

	<br>

## 연산자 우선순위를 잘못쓰는 경우
---

- _연산자의 종류_

	크게 세 가지 연산자가 있는데 __사칙연산자__ 와 __비트연산자__, __시프트연산자__ 가 있다.

	사칙연산자의 우선순위는 혼동하는 일이 적지만, 시프트 연산자나 비트 연산자들의 우선순위는 종종 헷갈린다.

	예를 들어,

	~~~c
	if(b & 1 == 0)
	~~~

	이라는 코드는 얼핏 보면 b의 최하 비트가 0일 때 참인 것처럼 보이지만 비트연산자 AND 인 & 는 비교연산자인 == 보다 낮기 때문에 사실

	~~~c
	if(b & (1 == 0)
	~~~

	이렇게 해석해야 한다.

	> 우선순위들이 헷갈릴 경우에는 괄호로 적절히 감싸는 것이 좋다!

	<br>

## 너무 느린 입출력 방식을 선택하는 경우
---

- _입출력을 담당하는 함수들은 각각의 속도를 가진다!_

	예를 들어, c++ 에서는 __gets()__ 함수를 이용해 모든 입력을 문자열 하나로 읽어들인 뒤 파싱할 수도 있고, __cin__ 을 사용하여 입력을 받을 수도 있다.

	하지만 cin 이 gets() 보다 두 배 이상 속도가 느려 시간초과를 야기할 수도 있다!!!

	> 우와!

	문제를 위해 입력과 출력을 1만개 이상 해야한다면 입출력 종류에 따라 시간이 달라지니 유의해야 한다!

	<br>


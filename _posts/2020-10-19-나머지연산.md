---
layout: post
title:  "[알고리즘] ➗ 나머지 연산"
date:   2020-10-19 18:34:10 +0700
categories: [algorithm]
---

## 0️⃣ 나머지 연산이란?

나머지 연산은 나누기 연산과 다른 연산이다. 

나머지 연산은 어떤 수를 또 다른 수로 나누었을 때 나오는 나머지를 구하는 연산이다.(몫을 구하는 것은 나누기 연산.)

나머지 연산의 연산자는 __%(mod)__ 이다.

예를 들어, 7 % 3의 정답은 7을 3으로 나누었을 때 남는 나머지인 1이 정답이다.

나머지 연산은 __Modulo 연산(모듈러 연산)__ 이라고도 부른다.

## 1️⃣ 어떤 문제들은 나머지 연산을 하라고 한다!

알고리즘 문제를 풀다보면 온전한 정답을 구하는 것이 아니라 정답을 얼마로 나눈 값을 정답으로 제출하라는 문제들을 볼 때가 있다.

이렇게 온전한 정답을 제출하는 것이 아닌 정답을 얼마로 나눈 값을 제출하라고 하는 이유는 __온전한 정답 자체가 너무 큰 수(int나 long long 으로 표현이 안 될 정도로 큰 수) 일 수 있기 때문__ 이다.

## 2️⃣ 나머지 연산의 특성

나머지 연산을 하라는 문제는 정답을 다 구하고 그 정답을 얼마로 나누는 것이 아니고, 정답을 갱신해줄 때마다 나머지 연산을 해주어야 한다.

온전한 정답에 나머지 연산을 하는 것과 정답을 갱신해줄 때마다 나머지 연산을 해주는 것의 결과값이 똑같을까?

나머지 연산의 몇 가지 특성을 알고 나면 위 두 가지 값이 똑같다는 것을 알 수 있을 것이다.

1. __(A + B) % M = ((A % M) + (B % M)) % M__ 이 성립한다.

    예를 들어, (5 + 2) % 3 의 정답은 1이다.

    하지만 ((5 % 3) + (2 % 3)) % 3 의 정답도 1로 같음을 알 수 있다.

2. __(A X B) % M = ((A % M) X (B % M)) % M__ 이 성립한다.

    예를 들어, (4 * 3) % 5 의 정답은 2이다.

    하지만 ((4 % 5) * (3 % 5)) % 5 의 정답도 2로 같음을 알 수 있다.

3. __(A - B) % M = ((A % M) - (B % M)) % M__ 이 성립한다.

    예를 들어, (4 - 3) % 3 의 정답은 1이다.

    하지만 ((4 % 3) - (3 % 3)) % 3 의 정답도 1로 같음을 알 수 있다.

    다만, __이 경우에는 예외가 있을 수 있다!__

    예를 들어, (6 - 5) % 3 의 정답은 1이다.

    그렇다면 ((6 % 3) - (5 % 3)) % 3 을 하면 정답을 구하기 직전 수식이 -2 % 3 이 된다.

    -2 % 3 을 계산하면 -2 일까? 1일까?

    -2 % 3과 같은 음수가 섞인 나머지 연산의 계산 결과는 프로그래밍 언어마다 다르다.

    위 예시 -2 % 3의 계산 값은 c++과 java에서는 -2 로 나오고, python에서는 1로 나온다.

    따라서 원래 식인 (6 - 5) % 3 = 1 이 나오게 하기 위해서는 -2를 양수로 만들어주기 위해 3을 한 번 더해주면 된다.
    
    즉, __((6 % 3) - (5 % 3) + 3) % 3__ 으로 계산해주면 된다.

    결론적으로는 (A - B) % M = ((A % M) - (B % M)) % M 은 성립은 하지만 음수가 나와 결과값이 언어별로 달라질 수 있기 때문에

    __(A - B) % M = ((A % M) - (B % M) + M) % M__ 로 바꾸어 계산해주는 것이 좋다!

    


    


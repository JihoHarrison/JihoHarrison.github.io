---
layout: post
title:  "[알고리즘] 😎 Dynamic Programming 문제 풀이"
date:   2020-10-28 18:34:10 +0700
categories: [algorithm]
---

## 0️⃣ 다이나믹 프로그래밍의 개념에 대해 알고 싶다면?

[이 블로그의 다른 포스팅 - Dynamic Programming](https://choheeis.github.io/newblog//articles/2020-05/DynamicProgramming) 을 보고 오자!

## 1️⃣ 문제 풀이 - 1로 만들기

[백준 문제 - 1로 만들기](https://www.acmicpc.net/problem/1463) 를 DP로 풀어보자!

이 문제는 큰 문제를 작은 문제로 쪼개어 풀 수 있는 문제이다.

그럼 큰 문제(__D[N]__)는 무엇일까? 큰 문제는 최종 정답을 도출할 수 있는 문제로 생각하면 된다.

__D[N] = N을 1로 만드는 최소 횟수__ 가 이 문제의 가장 큰 문제라고 볼 수 있다.

그렇다면 이 큰 문제를 작은 문제들로 쪼갤 수 있을까?

작은 문제들은 이 문제의 본문에 이미 다 나와있다.

<img width="302" alt="09" src="https://user-images.githubusercontent.com/31889335/97393344-6fcba200-1926-11eb-8a94-70fff3c31f39.png">

문제의 조건이였던 위 3가지 항목들이 바로 작은 문제들이라고 볼 수 있다.

예를 들어 N을 1로 만드는 최소 횟수를 구하기 위해 1번 조건인 X가 3으로 나누어 떨어지면, 3으로 나눈다를 N에 가장 먼저 적용했다고 해보자.

이 경우에, __D[N] = (N/3 의 횟수) + (N/3을 1로 만드는 최소 횟수)__ 라고 정의할 수 있다.

이 때, N/3은 1번 만에 할 수 있고, N/3을 1로 만드는 최소 횟수는 기존의 큰 문제로 정의했던 N 자리에 N/3을 대입하면 되므로 D[N/3] 으로 표현할 수 있다.

정리하면 조건 1번을 적용했을 때 큰 문제 D[N] 은 __D[N] = D[N/3] + 1__ 이라는 점화식으로 나타내질 수 있다는 것이다!

그렇다면 N에 가장 먼저 조건 2번을 적용했을 때의 점화식은 __D[N] = D[N/2] + 1__ 이 될 것이라는 것을 유추할 수 있다.

또 마지막으로 N에 가장 먼저 조건 3번을 적용했을 때의 점화식은 __D[N] = D[N-1] + 1__ 이 될 것이라는 것도 유추할 수 있다.

즉, 이 문제에서 큰 문제 D[N]을 작게 만들 수 있는 방법은 총 아래와 같은 3가지 인 것이다!

* __D[N] = D[N/3] + 1__

* __D[N] = D[N/2] + 1__

* __D[N] = D[N-1] + 1__

따라서 위 3가지 방법을 모두 구해본 후, D[N]의 값이 가장 최소가 되는 경우가 정답이 된다.

위 과정을 따라 정답을 구하는 코드를 작성해보자. 아래 코드는 bottom-top 방식으로 구현하였다.

~~~kotlin
// 언어 : kotlin
fun main() {
    val N = readLine()!!.toInt()

    // bottom - top 방식
    var memo = IntArray(N+1){i -> 0}
    memo[0] = -1 // index 0 안씀 처리
    memo[1] = 0 // 1로 만드는 방법은 0이니까 초기화 처리

    for(i in 2..N) {
        var min = N+1 // 최솟값 저장을 위한 초기화 

        // 조건 1 - 3으로 나누어 떨어지면, 3으로 나눈다.
        if(i%3 == 0) {
            memo[i] = 1 + memo[i/3]
            if(min > memo[i]) {
                min = memo[i] // 최솟값 저장
            }
        }

        // 조건 2 - 2로 나누어 떨어지면, 2로 나눈다.
        if(i%2 == 0) {
            memo[i] = 1 + memo[i/2]
            if(min > memo[i]) {
                min = memo[i] // 최솟값 저장
            }
        }

        // 조건 3 - 1을 뺀다.
        memo[i] = 1 + memo[i-1]
        if(min > memo[i]) {
            min = memo[i] // 최솟값 저장
        }

        memo[i] = min // 이 때의 min이 가장 최소가 된다.
    }
    print(memo[N])
}
~~~

DP는 어떻게 큰 문제를 작은 문제들로 나눌 것인지가 어렵고 중요한 것 같다.

## 2️⃣ 문제 풀이 - 2 X n 타일링

[백준 문제 - 2 X n 타일링](https://www.acmicpc.net/problem/11726) 문제를 풀어보자.

DP 문제는 스스로 큰 문제에 대한 점화식을 찾을 수 있는 능력이 중요하다.

이 문제에서 구해야 하는 큰 문제의 점화식은 __D[N] = 2 X N 크기의 직사각형을 채우는 방법의 수__ 이다. 이 큰 문제를 작은 문제들로 쪼갤 수 있다면? 그건 DP로 풀 수 있는 문제이다.

위에서 언급했던 1로 만들기 문제 풀이에서 큰 문제 D[N]을 작은 문제들로 쪼갤 때, 일단 가능한 경우 3가지가 존재했고, 각 경우마다 D[N] 을 재활용하여 D[N/3] 등과 같이 작은 문제를 정의했었다.

이 과정처럼 2 X n 타일링 문제도 __일단 가능한 경우가 존재하는지 확인__ 해보자.

<img width="511" alt="10" src="https://user-images.githubusercontent.com/31889335/97878090-7e202080-1d61-11eb-8b93-d38b5c92251e.png">

위 그림처럼 가장 오른쪽에 타일을 놓을 수 있는 각각 서로 다른 경우 2가지가 존재한다! 

* 가장 오른쪽에 가로 형태의 2 X 1 타일이 2개 오는 경우 

* 가장 오른쪽에 세로 형태의 2 X 1 타일이 1개 오는 경우 

따라서 이 문제의 정답은 위 두 경우에 구해지는 방법의 수를 합한 것이라는 것을 알 수 있을 것이다.

그렇다면 각 경우마다 큰 문제 D[N]은 어떻게 작은 문제로 쪼개질 수 있을까?

<img width="502" alt="11" src="https://user-images.githubusercontent.com/31889335/97878705-52ea0100-1d62-11eb-855e-144737758d3a.png">

<img width="507" alt="12" src="https://user-images.githubusercontent.com/31889335/97878809-74e38380-1d62-11eb-8112-ac36314b899b.png">

먼저 위의 첫 번째 그림을 보면 가장 오른쪽에 가로 형태의 2 X 1 타일이 2개 배치되었으므로 그 앞 공간들은 2 X n-2 크기의 직사각형을 채우는 방법의 수를 구하면 된다!

또 두 번째 그림을 보면 가장 오른쪽에 세로 형태의 2 X 1 타일이 1개 배치되었으므로 그 앞 공간들은 2 X n-1 크기의 직사각형을 채우는 방법의 수를 구하면 된다!

따라서 각 경우마다 큰 문제 D[N] 은 다음과 같이 작은 문제로 쪼개질 수 있게 된다.

* 가장 오른쪽에 가로 형태의 2 X 1 타일이 2개 오는 경우 : __D[N] = D[N-2]__

* 가장 오른쪽에 세로 형태의 2 X 1 타일이 1개 오는 경우 : __D[N] = D[N-1]__

즉, 이 문제의 큰 문제는 __D[N] = D[N-1] + D[N-2]__ 가 되는 것이다!

그럼 이제 위 큰 문제의 점화식을 가지고 bottom - top 방식으로 문제를 풀어보자!

bottom - top 방식으로 문제를 풀려면 먼저 메모를 위한 배열을 선언해야 하고, 이 배열의 첫 번째 또는 두 번째 원소까지의 값이 초기화되어야 한다.

~~~kotlin
// 언어 : kotlin
fun main() {
    val n = readLine()!!.toInt()
    print(BJ_11726().solution(n))
}

class BJ_11726 {
    fun solution(n: Int): Int {
        var D = IntArray(1001){0} // memoization을 위한 배열(점화식 표현과 맞추려고 D라고 이름 지음)
        D[0] = 1 // 아래 for문에서 i가 2일 때 D[0]이 되는데 2 X 2 크기의 직사각형의 가장 오른쪽에 가로 형태의 2 X 1 직사각형 2개가 들어가는 경우에도 방법의 수는 1임
        D[1] = 1 // 아래 for문에서 i가 1일 때 D[1]이 되는데 2 X 2 크기의 직사각형의 가장 오른쪽에 세 형태의 2 X 1 직사각형 1개가 들어가는 경우에도 방법의 수는 1임

        for(i in 2..n) {
            D[i] = D[i-1] + D[i-2]
            D[i] = D[i] % 10007
        }

        var answer = D[n]
        return answer
    }
}
~~~

## 3️⃣ 문제 풀이 - 1, 2, 3 더하기

[백준 문제 - 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095) 문제를 풀어보자.

이 문제에서 구해야 하는 큰 문제는 __D[N] = N을 1, 2, 3의 합으로 만드는 방법의 수__ 라고 볼 수 있다.

그럼 큰 문제 D[N] 을 작은 문제로 쪼갤 수 있도록 하는 특정 경우들이 존재할까?

문제에서 예시로 n이 4일 때는 1, 2, 3의 합으로 나타낼 수 있는 방법이 아래와 같이 총 7개의 방법이라 나와있다.

<img width="105" alt="13" src="https://user-images.githubusercontent.com/31889335/97889303-9008c000-1d6f-11eb-8bbe-6f3469007fcf.png">

그럼 위 예시를 보고 특정 경우들을 찾아내보자.

* 1 + X 로 나타낼 수 있는 경우

* 2 + X 로 나타낼 수 있는 경우

* 3 + X 로 나타낼 수 있는 경우

위 3가지 경우는 수식의 맨 앞에 놓이는 수에 따라 경우를 나눈 것이다.

n이 4일 때의 예시를 보면 수식의 맨 앞에 놓이는 수가 1인 경우, 1 + 1 + 1 + 1, 1 + 1 + 2, 1 + 2 + 1, 1 + 3 으로 총 4개의 방법이 존재한다.

이와 같이 수식의 맨 앞에 놓이는 수가 2인 경우, 2 + 1 + 1, 2 + 2 로 총 2개의 방법이 존재한다.

마지막으로 수식의 맨 앞에 놓이는 수가 3인 경우, 3 + 1 로 총 1개의 방법이 존재한다.

따라서 n이 4일 경우, D[4] =  1, 2, 3의 합으로 만드는 방법의 수 = 4 + 2 + 1 = 7 이다.

그럼 이제 각 경우를 어떻게 점화식으로 나타낼 수 있을까?

각 경우에서 X는 N에서 맨 앞자리 수를 뺀 값이다. 예를 들어, N이 4일 때 1 + X 경우에서의 X는 3이고, 이는 다시 3을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수를 구하면 되는 것과 같다.

* 1 + X 로 나타낼 수 있는 경우 = __D[N] = D[N-1]__

* 2 + X 로 나타낼 수 있는 경우 = __D[N] = D[N-2]__

* 3 + X 로 나타낼 수 있는 경우 = __D[N] = D[N-3]__ 

따라서 최종 큰 문제인 __D[N] = D[N-1] + D[N-2] + D[N-3]__ 인 것이다.

그럼 이제 위 큰 문제의 점화식을 가지고 bottom - top 방식으로 문제를 풀어보자!

이 때 구해놓은 점화식은 N이 4 이상일 때만 항상 적용되는 식이므로, 아래 코드의 memo 배열에서 index 0, 1, 2, 3은 직접 값을 생각하여 초기화 해줘야 한다!

~~~kotlin
// 언어 : kotlin
fun main() {
    val T = readLine()!!.toInt()
    BJ_9095().solution(T)
}

class BJ_9095 {
    fun solution(T: Int) {
        val memo = IntArray(11){0}
        memo[0] = -1 // index 0은 안씀 처리
        memo[1] = 1
        memo[2] = 2
        memo[3] = 4

        // 문제에서 n은 1 ~ 10까지라고 했으므로 10까지 memo값을 다 구해놓고, 테스트 케이스를 돌려야 시간 효율성이 높아짐 
        for(i in 4..10) {
            for(j in i-1 downTo i-3) {
                memo[i] += memo[j]
            }
        }

        // input
        for(i in 0 until T) {
            val n = readLine()!!.toInt()
            println(memo[n])
        }
    }
}
~~~

bottom - top 방식으로 문제를 풀 때 팁은 점화식이 N이 몇 이상부터 항상 만족하는 식인지를 생각하고, 만족하지 못하는 N을 index로 갖는 배열의 원소은 직접 값을 생각하여 초기화 시켜주면 된다!

## 4️⃣ 문제풀이 - 카드 구매하기

[백준 문제 - 카드 구매하기](https://www.acmicpc.net/problem/11052) 문제를 풀어보자.

이 문제에서 구해야 하는 큰 문제는 __D[N] = N개의 카드를 구매하기 위해 지불해야 하는 금액의 최댓값__ 라고 볼 수 있다.

그럼 큰 문제 D[N] 을 작은 문제로 쪼갤 수 있도록 하는 특정 경우들이 존재할까?

문제에서 예시로 든 N = 4일 때 카드팩을 골라 총 4개의 카드를 만들 수 있는 경우는 다음과 같다.

<img width="308" alt="14" src="https://user-images.githubusercontent.com/31889335/98335742-e2383280-2048-11eb-9fb1-1bacf766e55e.png">

위 경우들을 자세히 보면 맨 마지막으로 선택하는 카드가 p1인지, p2인지, p3인지, p4인지에 따라 경우가 달라진다는 것을 확인할 수 있다.

즉, 만약 맨 마지막으로 선택하는 카드가 p1인 경우는 다음과 같은데

<img width="589" alt="15" src="https://user-images.githubusercontent.com/31889335/98336073-8ae69200-2049-11eb-8d30-520a221816bc.png">

자세히 보면 p1을 제외한 앞 부분은 N=3일 때와 같은 경우라는 것을 알 수 있다.

즉, 맨 마지막 카드로 p1을 뽑았을 때의 D[4]은 D[4] = D[3] + p1 이 된다.

이와 마찬가지로 맨 마지막 카드가 p2, p3, p4일 경우 각각은

* D[4] = D[3] + p1 

* D[4] = D[2] + p2

* D[4] = D[1] + p3

* D[4] = D[0] + p4 (식의 일관성을 위해 D[0]을 추가했고, D[0] = 0 이라고 생각하자.) 

가 된다.

따라서 최종 답인 D[N] 은 Max((D[3] + p1), (D[2] + p2), (D[1] + p3), (D[0] + p4)) 이다!

즉, 이것을 일반화시켜 점화식 형태로 나타내면 뽑아야 하는 카드의 개수가 N 일 때,

<img width="350" alt="16" src="https://user-images.githubusercontent.com/31889335/98338079-f120e400-204c-11eb-86aa-4547f2260ec1.png">

이렇게 나타낼 수 있다!

이 문제를 맨 처음부터 위와 같이 마지막에 뽑히는 카드에 따라 경우가 나뉘어지는 것을 빨리 생각해내지 못할 수도 있다.

이런 경우 dp 문제인지 빠르게 확인하는 방법은(나 스스로 내린 방법이다,,,😂) D[1], D[2] 등의 값을 구해보고 이 값들을 계속 사용해도 그 다음 값인 D[3], D[4]... 의 값을 구하는데 그대로 사용되는지 먼저 확인해보는 것! (아직 dp 문제를 많이 풀어보지 않아서 이 방법이 먹히는지는 잘 모르겠다ㅠ)

그럼 위에서 알아본 점화식을 가지고 bottom - top 방식으로 코드를 작성해보자.

~~~kotlin
// 언어 : kotlin
fun main() {
    val T = readLine()!!.toInt()
    val ps = arrayListOf<Int>()
    ps.add(-1) // index 1부터 사용하기 위해 index 0 은 안씀 처리
    ps.addAll(1, readLine()!!.split(" ").map{it.toInt()})
    BJ_11052().solution(ps)
}

class BJ_11052 {
    fun solution(ps: ArrayList<Int>) {
        var d = IntArray(1001){0}
        d[0] = 0
        d[1] = ps[1]

        for(i in 2..ps.size-1) {
            var max = 0
            for(j in 1..i) {
                val tmp = ps[j] + d[i-j]
                if(max < tmp) {
                    max = tmp
                }
            }
            d[i] = max
        }

        print(d[ps.size-1])
    }
}
~~~
---
layout: post
title:  "[알고리즘] 😎 Dynamic Programming 문제 풀이"
date:   2020-10-28 18:34:10 +0700
categories: [algorithm]
---

## 0️⃣ 다이나믹 프로그래밍의 개념에 대해 알고 싶다면?

[이 블로그의 다른 포스팅 - Dynamic Programming](https://choheeis.github.io/newblog//articles/2020-05/DynamicProgramming) 을 보고 오자!

## 1️⃣ 문제 풀이 - 1로 만들기

[백준 문제 - 1로 만들기](https://www.acmicpc.net/problem/1463) 를 DP로 풀어보자!

이 문제는 큰 문제를 작은 문제로 쪼개어 풀 수 있는 문제이다.

그럼 큰 문제(D[N])는 무엇일까? 큰 문제는 최종 정답을 도출할 수 있는 문제이다.

__D[N] = N을 1로 만드는 최소 횟수__ 가 이 문제의 가장 큰 문제라고 볼 수 있다.

그렇다면 작은 문제들은 무엇일까?

작은 문제들은 이 문제의 본문에 이미 다 나와있다.

<img width="302" alt="09" src="https://user-images.githubusercontent.com/31889335/97393344-6fcba200-1926-11eb-8a94-70fff3c31f39.png">

문제의 조건이였던 위 3가지 항목들이 바로 작은 문제들이라고 볼 수 있다.

예를 들어 N을 1로 만드는 최소 횟수를 구하기 위해 1번 조건인 X가 3으로 나누어 떨어지면, 3으로 나눈다를 N에 가장 먼저 적용했다고 해보자.

이 경우에, __D[N] = (N/3 의 횟수) + (N/3을 1로 만드는 최소 횟수)__ 라고 정의할 수 있다.

이 때, N/3은 1번 만에 할 수 있고, N/3을 1로 만드는 최소 횟수는 기존의 큰 문제로 정의했던 N 자리에 N/3을 대입하면 되므로 D[N/3] 으로 표현할 수 있다.

정리하면 조건 1번을 적용했을 때 큰 문제 D[N] 은 __D[N] = D[N/3] + 1__ 이라는 점화식으로 나타내질 수 있다는 것이다!

그렇다면 N에 가장 먼저 조건 2번을 적용했을 때의 점화식은 __D[N] = D[N/2] + 1__ 이 될 것이라는 것을 유추할 수 있다.

또 마지막으로 N에 가장 먼저 조건 3번을 적용했을 때의 점화식은 __D[N] = D[N-1] + 1__ 이 될 것이라는 것도 유추할 수 있다.

즉, 이 문제에서 큰 문제 D[N]을 작게 만들 수 있는 방법은 총 아래와 같은 3가지 인 것이다!

* __D[N] = D[N/3] + 1__

* __D[N] = D[N/2] + 1__

* __D[N] = D[N-1] + 1__

따라서 위 3가지 방법을 모두 구해본 후, D[N]의 값이 가장 최소가 되는 경우가 정답이 된다.

위 과정을 따라 정답을 구하는 코드를 작성해보자. 아래 코드는 bottom-top 방식으로 구현하였다.

~~~kotlin
// 언어 : kotlin
fun main() {
    val N = readLine()!!.toInt()

    // bottom - top 방식
    var memo = IntArray(N+1){i -> 0}
    memo[0] = -1 // index 0 안씀 처리
    memo[1] = 0 // 1로 만드는 방법은 0이니까 초기화 처리

    for(i in 2..N) {
        var min = N+1 // 최솟값 저장을 위한 초기화 

        // 조건 1 - 3으로 나누어 떨어지면, 3으로 나눈다.
        if(i%3 == 0) {
            memo[i] = 1 + memo[i/3]
            if(min > memo[i]) {
                min = memo[i] // 최솟값 저장
            }
        }

        // 조건 2 - 2로 나누어 떨어지면, 2로 나눈다.
        if(i%2 == 0) {
            memo[i] = 1 + memo[i/2]
            if(min > memo[i]) {
                min = memo[i] // 최솟값 저장
            }
        }

        // 조건 3 - 1을 뺀다.
        memo[i] = 1 + memo[i-1]
        if(min > memo[i]) {
            min = memo[i] // 최솟값 저장
        }

        memo[i] = min // 이 때의 min이 가장 최소가 된다.
    }
    print(memo[N])
}
~~~

DP는 어떻게 큰 문제를 작은 문제들로 나눌 것인지가 어렵고 중요한 것 같다.
---
layout: post
title:  "[알고리즘] 🌊 버블정렬"
date:   2019-08-19 18:34:10 +0700
categories: [c++]
---

> --> [유튜버동빈나](https://www.youtube.com/watch?v=EZN0Irp2aPs&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=3) 영상 참고!

<br>

## 🌊 버블정렬이란?
---

- _버블정렬의 아이디어_

	__"바로 옆에 있는 수와 비교해서 큰 수는 오른쪽으로, 작은 수는 왼쪽으로 옮긴다!"__

	아래 그림을 통해 더 자세히 이해해보자.

	![01](https://user-images.githubusercontent.com/31889335/63243723-606ab680-c296-11e9-8853-d07a1ee6ff5c.PNG)

	![02](https://user-images.githubusercontent.com/31889335/63243725-606ab680-c296-11e9-996e-343275e6a718.PNG)

	![03](https://user-images.githubusercontent.com/31889335/63243726-61034d00-c296-11e9-88d1-7498e55c2100.PNG)

	![04](https://user-images.githubusercontent.com/31889335/63243728-61034d00-c296-11e9-8574-f93dc14cf87b.PNG)

	![05](https://user-images.githubusercontent.com/31889335/63243729-61034d00-c296-11e9-942f-aad90dcb8ba2.PNG)

	![06](https://user-images.githubusercontent.com/31889335/63243731-61034d00-c296-11e9-8e53-44ab1533b35d.PNG)

	위 그림에서 알 수 있듯이 두 번째 정렬때는 첫번째 원소에서 다섯번째 원소까지 버블정렬 시키면 된다.
	
	세 번쨰 정렬때는 첫번째 원소에서 네번째 원소까지 버블정렬 시키면 된다! 
	
	즉, __버블정렬을 한 번 실행시키면 버블 정렬의 대상이 되는 수 중 제일 큰 수가 맨 뒤에 배치된다!__

	<br>

## 🌊 버블정렬을 코드로 작성해보자.
---

~~~c
	#include<stdio.h>

	int main(){
		// 정렬할 수 데이터 
		int arr[10] = {2, 10, 5, 7, 8, 9, 1, 3, 4, 6};
		
		// 버블 정렬 알고리즘  
		for(int i = 0 ; i < 10 ; i++){
			for(int j = 0 ; j < 10-i ; j++){
				if(arr[j] > arr[j+1]){
					int tmp = arr[j+1];
					arr[j+1] = arr[j];
					arr[j] = tmp;
				}
			}
		}
		
		// 출력결과 확인하기
		for(int i = 0 ; i < 10 ; i++){
			printf("%d ", arr[i]);
		} 
		
		
	}
~~~

<br>

## 🌊 버블정렬의 시간복잡도
---

버블정렬의 시간 복잡도는 선택정렬과 마찬가지로 O(N^2) 이다.

비교연산이 몇 번 실행되는지를 살펴보자.

i = 0 일 때 비교연산은 10번

i = 1 일 때 비교연산은 9번

i = 2 일 때 비교연산은 8번 

...

i = 9 일 때 비교연산은 1번 실행된다.

즉, 10번 + 9번 + 8번 + 7번 + ... + 1번은 등차수열 N * (N + 1)/2 로 나타낼 수 있고, 이것을 빅오표기법으로 나타내면 __O(N^2)__ 이다.

__하지만 버블정렬의 시간복잡도는 대표적인 정렬 알고리즘 중 가장 느리다!__

선택정렬과 빅오 표기법이 똑같은데 버블정렬이 왜 더 느릴까?

버블 정렬은 당장 옆에 있는 수와 비교해서 바로 자리를 바꾸는 연산이 있다. 선택 정렬은 한 줄을 쭉 보고 가장 작은 수를 앞으로 자리바꿈 하지만 버블 정렬은 한 줄을 거쳐가면서 계속해서 자리바꿈이 일어난다.

즉, 

~~~c
int tmp = arr[j+1];
arr[j+1] = arr[j];
arr[j] = tmp;
~~~

이 코드의 실행이 버블정렬에서 훨씬 많은 것이다!

따라서 빅오표기법은 선택정렬과 같지만 실제로는 버블 정렬이 훨씬 느리다!

> 오,, 헐..! 간단한 정렬쓸때는 매번 버블정렬을 시켰었는데 시간이 가장 느린 정렬을 사용하고 있었다니!
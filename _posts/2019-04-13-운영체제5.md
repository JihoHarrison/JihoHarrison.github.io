---
layout: post
title:  "[OS] 운영체제5"
date:   2019-04-13 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>
> _5강 - CPU Scheduling_
>
> 🙋 5강에서 설명할 수 있어야 할 것들 🙋
>
> - CPU 스케줄러가 하는 일
> - dispatcher란?
> - CPU 스케줄링 알고리즘들

<br>

## 📃 CPU 스케줄러(Scheduler)
---

- _CPU 스케줄러가 하는 일_

	프로세스의 상태에 대한 앞 포스팅에서 ready 상태에 있는 프로세스들은 CPU 스케줄러에 의해 선택된다고 언급했었다.

	ready 상태에 있는 프로세스들은 사실 __Ready Queue__ 라는 열의 형태에 들어가 있다.

	CPU 스케줄러는 이 레디큐에 있는 프로세스들 중 하나를 선택해서 CPU를 할당해 주는 일을 한다. 

	<br>

- _CPU 스케줄러가 하는 결정들은 아래와 같은 4가지 상황이 발생했을 때 일어난다_

	1. __프로세스가 running 상태에서 waiting 상태로 이동할 경우__

	2. __프로세스가 running 상태에서 ready 상태로 이동할 경우__

	3. __프로세스가 waiting 상태에서 ready 상태로 이동할 경우__

	4. __프로세스가 terminated 상태가 될 경우__

	즉, 크게 보면 다른 상태에서 ready 상태로 돌아오는 경우나 종료되는 경우이다. 

	위 4가지 경우 중에서 2번과 3번은 선점적이고, 1번과 4번은 비선점적인 스케줄링이다.

	__비선점적__ = 어떤 프로세스가 CPU를 할당받으면 이 프로세스가 종료될 때까지 계속 CPU 작업이 실행되는 것

	__선점적__ = 어떤 프로세스가 CPU를 할당받은 후, timeslice가 지나거나 I/O 이벤트를 기다려야 한다면 다른 프로세스에게 CPU를 양보하는 것(즉, 다른 프로세스가 기존 프로세스를 몰아내고 CPU를 선점할 수 있다는 것이다.)

	<br>

- _디스패처(Dispatcher)_

	CPU 스케줄러의 일을 보조 해주는 __디스패처__ 라는 것이 있다.
	
	CPU 스케줄러에 의해 선택된 프로세스에게 CPU를 할당해 주는 역할을 하는 것을 디스패처라고 한다.

	<br>

- _디스패처가 담당하는 3가지 일_

	__context switch 담당__

	__user모드로 바꾸기__

	__선택된 프로세서가 시작될 수 있도록 적절한 경로로 점프하기__

	> 여기서 user모드가 왜 나올까?

	CPU 스케줄링은 운영체제가 하는 일이기 때문에 __커널모드__ 에 속한다.

	즉, 프로세스를 선택하거나 선택된 프로세스로 바꾸는 것은 커널모드이지만 프로세스가 실행되는 단계는 __유저모드__ 이다.

	따라서 디스패처는 커널모드에서 user모드로 바꾸는 역할을 한다.

	<br>

- _디스패처 지연(latency)_

	디스패처가 기존 프로세스를 멈추고 선택된 프로세스에게 CPU를 할당하기까지는 약간의 시간이 걸리기 때문에 시간 지연이 발생한다.

	즉, 프로세스1에서 프로세스2로 context switch가 발생할 때 디스패처로 인한 약간의 시간 지연이 발생한다는 것이다.

	디스패처에 인한 지연을 __스케줄링 overhead__ 라고도 한다.

	<br>

## 👌 CPU 스케줄러가 프로세스를 선택하는 5가지 기준
---

- _1. CPU 이용률(utilization)을 극대화 시키는 방향으로 선택_

	CPU를 정해진 시간(time slice)동안 100% 가동하는 것에 가까운 프로세스 먼저 선택한다.

	<br>

- _2. 처리능력(throughput)을 최대화 시키는 방향으로 선택_

	주어진 시간동안 최대한 많은 프로세스를 처리할 수 있는 방향으로 선택될 프로세스 순서를 결정한다.

	<br>

- _3. 반환까지 걸리는 시간(turnaround time)을 최소화하는 방향으로 선택_

	반환까지 걸리는 시간(프로세스가 완료될 때까지의 시간)이 줄어들면 결국 전체 작업 수행 시간이 최소화 되기 때문에 turnaround time이 적은 방향으로 프로세스를 선택한다.

	<br>

- _4. 대기시간(waiting time)이 최소화되는 방향으로 선택_

	ready queue에서 기다리는 시간이 최소화 되도록 프로세스들을 선택한다.

	<br>

- _5. 응답시간(response time)이 최소화되는 방향으로 선택_

	첫 응답까지 걸리는 시간이 최소화 되는 방향으로 선택한다.

	<br>

	__위와 같은 기준들을 적용시켜서 CPU가 효과적으로 스케줄링할 수 있게 하는 알고리즘들이 존재한다!__

	<br>

## 🐍 CPU 스케줄링 알고리즘들(7가지)
---

먼저 알아둬야 할 것은 __burst time__ 이라는 것이다! 

CPU burst time은 CPU가 일을 수행하는 시간을 말하고, I/O burst time은 I/O 요청에 대한 응답을 기다리는 시간을 말한다.

<br>

- _1. First-Come First-Served(FCFS) 알고리즘_

	__FCFS__ 는 알고리즘의 이름 그대로 처음 온 프로세스가 제일 처음으로 선택되는 방식의 알고리즘이다.

	![운영체제35](https://user-images.githubusercontent.com/31889335/56301837-9296cb00-6173-11e9-80b4-803956182b57.PNG)

	위 표는 프로세스별 CPU burst time을 나타낸 표이다.

	이 표에 해당하는 프로세스들은 P1, P2, P3 순으로 ready quere에 도착했다고 가정하자.

	위와 같은 상황에서 CPU 스케줄러는 FCFS 알고리즘을 따른다고 한다면 

	![운영체제36](https://user-images.githubusercontent.com/31889335/56302116-12bd3080-6174-11e9-9ed3-adf8347c227e.PNG)

	와 같은 간트 차트가 도출된다.

	(__간트 차트(Gantt chart)__ = 프로젝트 일정관리를 위한 bar 형태의 차트)

	이 표를 보고 알 수 있는 점은 P1은 24초간 실행된 후 재등장 하지 않으므로 이 알고리즘은 비선점적이라는 점을 알 수 있다. 

	P1은 1등으로 도착하였기 때문에 대기시간이 0초이다.

	P2는 P1이 종료될 때까지 대기하여 대기시간이 24초이다.

	P3는 P1과 P2가 종료될 때까지 대기하여 대기시간이 27초이다.(24초 + 3초)

	이 세 프로세스의 평균 대기 시간은 (0 + 24 + 27)/3 이므로 17초이다.

	만약 이 때, P2를 제일 먼저 실행시켰다면 평균 대기 시간은 (0 + 3 + 27)/3 이 되어 10초로 줄어들 것이다.

	<br>

- _2. Shortest-Job-First(SJF) 알고리즘_

	이 알고리즘도 말 그대로 CPU burst time이 가장 짧은 프로세스를 먼저 선택하는 방식의 알고리즘이다.

	단, 이 때, 프로세스가 도착한 시점에서 가장 짧은 수행시간을 갖는 것을 먼저 선택하는 것임이 중요하다!

	이 알고리즘에는 두 가지 버전이 존재한다.

	__1. 비선점적 버전__

	![운영체제37](https://user-images.githubusercontent.com/31889335/56302833-857adb80-6175-11e9-8040-3273277ac7ae.PNG)

	위 표는 프로세스별 도착 시간과 burst time을 나타낸 표이다.

	SJF 알고리즘에 따라 간트 차트를 그려보면

	![비선점적](https://user-images.githubusercontent.com/31889335/56304686-a5140300-6179-11e9-83d9-2ce966101ed3.jpg)

	위와 같은 과정으로 그려진다. (SJF에서 burst time이 같다면 먼저 도착한 프로세스를 고른다.)

	P1의 대기시간은 0초, P3의 대기시간은 3초(4초에 도착했는데 7초에 실행됨), P2의 대기시간은 6초, P4의 대기시간은 7초이다.

	이 네 프로세스의 평균 대기 시간은 (0 + 3 + 6 + 7)/4 이므로 4초이다.

	4초 밖에 되지 않으므로 SJF 알고리즘의 비선점적 버전은 프로세스의 평균 대기 시간을 최소화하는데 좋은 알고리즘이다.

	<br>

	__2. 선점적 버전__

	![선점적](https://user-images.githubusercontent.com/31889335/56305951-49974480-617c-11e9-97dd-6f36f0ed542b.jpg)

	선점적으로 프로세스를 선택한 간트 차트는 위와 같다.

	P1의 대기 시간은 9초(2초에서 중단되었다가 11초에 다시 시작되었으므로), P2의 대기 시간은 1초, P3의 대기시간은 0초, P4의 대기 시간은 2초(5초에 도착했지만 7초에 시작되었으므로)이다.

	이 네 프로세스의 평균 대기 시간은 (9 + 1 + 0 + 2)/4 이므로 3초이다.

	3초 밖에 안되므로 SJF 알고리즘의 선점적 버전도 프로세스의 평균 대기 시간을 최소화하는데 좋은 알고리즘이다.

	<br>

- _3. Priority Scheduling 알고리즘_

	이 알고리즘 또한 알고리즘 이름 그대로 우선순위가 높은 프로세스를 먼저 선택하는 방식이다.

	사실 SJF도 Priority Scheduling의 한 종류이다. 

	Priority Scheduling 알고리즘에는 문제점이 존재하는데 우선순위가 낮은 프로세스들은 선택될 일이 없다는 문제점이 있다. 이 문제점을 __starvation(굶주림)__ 이라고 한다.

	starvation 문제를 해결하기 위해서는 시간이 지날 때마다 프로세스들의 우선순위를 높여줘야 한다. 이런 해결법을 __aging(노화)__ 이라고 한다.

	<br>

- _4. Round Robin(RR) 알고리즘_

	이 알고리즘은 프로세스들 간에 우선순위를 두지 않고, 순서대로 단위시간(time slice 또는 time quantum)동안 CPU를 할당하는 방식의 알고리즘이다.

	좀 더 쉽게 말하면 모든 프로세스들을 합리적인 순서에 입각하여 선택한다는 것인데, 큐의 맨 오른쪽에서 하나씩 뽑고 단위시간이 지나면 큐의 맨 왼쪽으로 돌아가는 식이다.

	![운영체제38](https://user-images.githubusercontent.com/31889335/56362793-a6026e80-6225-11e9-802f-e93ae60f1086.PNG)

	위 표는 프로세스별 CPU burst time을 나타낸 표이다. 이 표에 적용할 RR 알고리즘의 time quantum은 2초이다.

	이 때의 간트 차트는 

	![RR](https://user-images.githubusercontent.com/31889335/56364482-9ab14200-6229-11e9-8799-e2ea42c80177.jpg)

	이다. 

	P1의 __처음 응답까지의 시간__ 은 0초, P2의 처음 응답까지의 시간은 2초, P3의 처음 응답까지의 시간은 4초, P4의 처음 응답까지의 시간은 6초이다.

	따라서 평균 응답 시간은 (0 + 2 + 4 + 6)/4 이므로 3초이다.

	RR 알고리즘의 장점은 프로세스 중 무작정 기다리고 있는 프로세스는 없다는 것이다. 

	또한, time quantum이 긴 시간이라면 한 번에 모든 프로세스가 다 돌아갈 것이다.

	또, time quantum이 얼마냐에 따라 turnaround time(=반환시간 즉, 레디 큐에 들어가고 나서 부터 CPU 작업이 끝나 다시 레디큐에 들어갈 때까지의 시간)이 달라진다.

	![운영체제39](https://user-images.githubusercontent.com/31889335/56365836-bec25280-622c-11e9-8276-1e25bbbf1982.PNG)

	위 그림을 통해 time quantum에 따른 평균 turnaround 시간을 확인 할 수 있다.	

	SJF 알고리즘 보다 평균 대기 시간과 순환 시간이 길지만 평균 응답 시간은 빠르다.

	<br>

- _5. Multilevel(다단계) Queue 알고리즘_

	이 알고리즘은 레디 큐를 하나만 사용하는 것이 아니라 여러개의 레디 큐가 존재하도록 한다.

	예를 들어, foreground 프로세스와 backgroud 프로세스가 들어가는 레디 큐를 분리시켜 놓는 것이다.

	> foregroud , backgroud 프로세스의 정확한 정의는 모르겠지만 느낌은 알 수 있으니! 이해 가능!

	별도의 큐들은 반드시 각각의 스케줄링 방식에 의해 결정되어야 하고, 일반적으로 foreground 프로세스 레디 큐는 RR 알고리즘, backgroud 프로세스 레디 큐는 FCFS 알고리즘으로 스케줄링 된다.

	또, 큐와 큐 사이에는 반드시 스케줄링이 있어야 하고, 일반적으로 고정 우선순위 선점형 스케줄링으로 구현된다.

	위의 예시에 추가로 설명하자면 foreground 프로세스 레디 큐가 backgroud 프로세스 레디 큐보다 높은 우선순위를 가져서 먼저 선택된다.

	따라서 이 경우 starvation이 발생할 수 있다.

	또, 각 큐들은 자신만의 CPU를 가지고 있는 시간이 정해져 있다. 예를 들면 foreground 프로세스 레디 큐는 CPU의 80퍼센트 시간을 가지고, background 프로세스 레디 큐는 CPU의 20퍼센트 시간을 가진다.

	<br>

_6. Multilevel Feedback Queues 알고리즘_

	이 알고리즘은 여러 개의 레디 큐가 존재하는데 각 큐들은 자신만의 스케줄링 알고리즘대로 실행된다. 즉, 레디 큐들의 알고리즘은 정해져 있고 프로세스가 자신에게 적합한 알고리즘을 가지고 있는 큐로 들어가는 방식이다.

	자신이 들어온 큐가 자신과 맞지 않다면 다른 알고리즘을 가지고 있는 레디 큐로 이동할 수도 있다.
	
![운영체제40](https://user-images.githubusercontent.com/31889335/56368045-99841300-6231-11e9-8621-cd4c0e9eed9e.PNG)
	
	위 그림을 통해 다단계 피드백 큐 알고리즘을 이해할 수 있을 것이다.

	Multilevel Feedback Queue 알고리즘은 다음과 같은 5개의 매개변수에 의해 정의된다.

	- 큐의 개수

	- 각 큐를 위한 스케줄링 알고리즘

	- 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법

	- 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법

	- 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법	

<br>

- _7. Multi(다중)-Processor(처리) Scheduling 알고리즘_

	위 알고리즘들은 Single-Processor 스케줄링이었다. 이에 반해 Multi-Processor 스케줄링은 더 복잡하다.

	다중 처리 스케줄링 알고리즘은 두 가지 종류가 있다.

	__1. 비대칭적 멀티프로세싱__

	어떤 Master 프로세스가 스케줄링을 결정하고 있으면 다른 프로세스는 유저모드에서 수행중이다.

	__2. 대칭적 멀팊로세싱__

	각각의 프로세스는 자신만의 스케줄링 결정을 동시에 하는 것이다.

	<br>

## 🐥 리눅스에서의 스케줄링
---

- _리눅스에서의 timeslice로 인한 Time-sharing_

	리눅스에서는 프로세스에 timeslice가 적용된다.

	타이머 interrupt가 발생할 경우 타임 슬라이스는 줄어든다.

	타임 슬라이스가 0일 때, 다른 프로세스가 선택되어 진다.

	모든 프로세스의 타임 슬라이스가 0이면 재연산이 시작된다.

	<br>

- _리눅스에서의 우선순위에 따른 Real-time_

	리눅스는 완전한 리얼 타임 시스템까지는 아니다.

	리얼 타임 시스템의 성격이 약간 도입되었으므로 soft 리얼 타임이라고 한다.

	0이 가장 높은 우선순위이다. 따라서 우선순위가 0인 프로세스부터 실행시킨다.

	우선순위가 높은 프로세스들에게는 timeslice를 충분히 제공한다.

	<br>



	














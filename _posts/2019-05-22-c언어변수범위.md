---
layout: post
title:  "[C] 😡 오버플로우를 깨닫다!"
date:   2019-05-22 18:34:10 +0700
categories: [c]
---

> [백준 1834번 - 나머지와 몫이 같은 수](https://www.acmicpc.net/problem/1834)을 푸는 과정에서 오버플로우를 처음 마주하게 되었다...!
>
> --> [이 포스팅에 참고한 자료](https://m.blog.naver.com/PostView.nhn?blogId=sharonichoya&logNo=220340284388&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

<br>

## 😟 분명 맞는데 왜 틀릴까?
---

>코드상 문제가 없는 것을 몇 번이고 검토했지만 __틀렸습니다__ 라는 빨간딱지를 계속 받게 되었다.
> 
>결국, 다른 사람들이 질문한 곳에서 틀린 이유를 찾게 되었는데 원인은 오버플로우가 발생했기 때문이였다!!

<br>

- _오버플로우(overflow)란?_

	먼저 오버플로우라는 어원을 살펴보면

	__over__ + __flow__ = __넘쳐__ + __흐르다__ 

	라는 뜻이다. 즉, 용기나 그릇이 가득 차 넘쳐 흐르다 라는 의미임을 알 수 있다.

	그렇다면, c언어에서 언제 넘쳐흐른다 라는 표현을 적용하는 것일까?

	<br>

- _오버플로우가 발생하는 경우_

	우리는 변수가 선언될 때 변수의 각 자료형에 따라 해당 변수에 할당되는 메모리 크기가 달라진다는 것을 안다.

	<br>

	> [C언어 기억을 살리자](https://choheeis.github.io/c/2019/03/03/C%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%96%B5%EC%82%B4%EB%A6%AC%EA%B8%B0.html) 포스팅 참고!

	<br>

	또, 할당된 메모리가 얼마냐에 따라 해당 변수에 저장할 수 있는 숫자 범위가 정해져 있음도 알고 있다.

	<br>

	> 📑 예를 들어 int 형 변수를 선언하면 메모리에 4byte만큼이 할당되는데 이는 곧, 32비트이므로 0과 1이 32 비트에 들어갈 수 있는 경우의 수 만큼의 범위가 생긴다.
	>
	> 즉, 부호 비트가 있는 __int__ 형 변수에 들어갈 수 있는 수의 범위는 __-2,147,483,648 ~ 2,147,483,647__ 이고
	>
	> 부호 비트가 없는 __unsigned int__ 형 변수에 들어갈 수 있는 수의 범위는 __0 ~ 4,294,967,195__ 이다.
	
	<br>

	그럼 c언어에서 넘쳐흐른다 라고 할 수 있는 부분은 어느 부분을 말하는 것일까?

	바로 __선언된 변수가 표현할 수 있는 수의 최대 범위보다 큰 수가 해당 변수에 저장되도록 코딩할 경우에 오버플로우가 발생하는 것이다!__

	변수가 저장할 수 있는 것보다 넘쳐버린 것이기 때문이다.

	따라서 변수에 저장해야 하는 수를 보고 사용해야 할 변수 자료형을 적절히 결정해야 한다!

	> 변수 자료형에 따른 범위를 구분해 놓은 표는 글 아래에서 보자!

	<br>

- _오버플로우가 발생했을 때 알아야 할 중요한 사실!_

	만약 int 형 변수 number 을 선언한 후, int 형 변수의 최대 범위인 2,147,483,647 보다 딱 1 큰 수인 2,147,483,648을 number에 저장했다고 가정하자.

	그 다음, __printf("%d", number);__ 을 해보면 출력값은 __-2,147,483,648__ 이 나오는 것을 확인할 수 있다.

	왜 -2,147,483,648 이 출력되는 것일까? 

	![01](https://user-images.githubusercontent.com/31889335/58177699-d2efe880-7cdf-11e9-89b6-0ef321a54a04.PNG)

	이 그림을 통해 위 질문에 대한 답을 할 수 있다.

	윗 줄 사각형들의 나열은 int 형 변수가 표현할 수 있는 수의 범위를 나타낸 것이다. 

	이 때, 최대인 2,147,483,647보다 1큰 수를 저장한다면 더 이상 표현할 수 있는 수가 아니므로 범위의 맨 처음인 -2,147,483,648 로 돌아온다.

	따라서 printf("%d", number); 의 출력값이 -2,147,483,648 가 되었던 것이다.

	만약 최대인 2,147,483,647 보다 2만큼 큰 수를 변수에 저장하여 출력한다면 -2,147,483,647 이 출력될 것이다.

	아랫줄 사각형들의 나열은 unsigned int 형 변수의 overflow 를 설명하기 위한 그림이다.

	따라서 위 그림과 같은 순환은 __무~한히__ 순환한다. 즉, 순환이 몇 번이고 돌 수 있다는 것이다.

	> 사실 위에서 설명한 오버플로우는 더 정확히 __산술 오버플로우__ 라고 하는 것이 옳다. __버퍼 오버플로우__ 라고 하는 개념도 있기 때문이다.

	<br>

## 💪 오버플로우를 문제에서 마주치다!
---

위에서 알아본 오버플로우를 코딩문제에서 마주하였다!

먼저 [백준 1834번 - 나머지와 몫이 같은 수](https://www.acmicpc.net/problem/1834) 문제에서 출력에 사용되는 변수를 int 형으로 선언할 경우, 문제에서 제시한 입력값 범위의 최댓값을 입력했을때 오버플로우가 발생했다.

따라서 최댓값을 입력했을지라도 오버플로우가 발생하지 않게 하기 위해서는 출력에 사용되는 변수를 int형이 아닌 다른 자료형으로 선언해야 했다.

![02](https://user-images.githubusercontent.com/31889335/58179242-c0c37980-7ce2-11e9-8242-1ec759fc3c63.PNG)

위 표를 보고 출력값 변수의 자료형을 long long int 로 해야함을 알 수 있었다.

__int 형에 넣을 수 있는 값의 범위를 기억하기 어렵다면 총 10자리 수 중 맨 앞 숫자가 2를 넘어가는 수를 int 형에 넣으면 오버플로우가 발생한다는 것을 기억하자!__

<br>

> 왜 사람들이 long long int 를 long long 만 쓰는지, 이 둘은 다른 것인지 같은 것인지 궁금했는데 이 표를 통해 같은 것임을 알게되었다!
>
> ~~~c
> long long int number;
>
> // 는 아래와 같은 표현이다.
> long long number;
> ~~~


<br>
_이 문제를 풀면서 깨달은 것이 있는데 코드를 제출하기 전에 문제에서 주어진 입력값의 최대, 최소값을 꼭 테스트해보고 제출하는 것이 좋은 습관이라는 것을 알게 되었다. 😹_

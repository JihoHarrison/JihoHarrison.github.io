---
layout: post
title:  "[OS] 운영체제1"
date:   2019-04-03 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>
> _1강 - Introduction to Operating Systems_
>
> 🙋 1강에서 설명할 수 있어야 할 것들 🙋
>
> - 운영체제란
> - 하드웨어에 속하는 것들과 각각의 특징
> - 운영체제가 가지는 특징
> - 프로세스 관리
> - 메모리 관리
> - 가상머신


<br>


## ☺ '운영체제'를 '정의' 해보자!
--- 

-  운영체제를 정의하기 위해서는 기본적으로 컴퓨터 시스템이 4가지 구성요소로 이루어져 있다는 것을 알아야한다. 

	컴퓨터시스템(computer system)에는 4가지 구성요소가 있는데,

	- 최상위 요소 : __Users__ (말그대로 컴퓨터를 사용하는 유저)
	- 세번째 요소 : __Applications__ (워드 프로세서, 웹 브라우저, 게임 등등 유저가 사용하는 프로그램들. 유저가 필요할 때 설치하고 사용하지 않을 때는 지우기도 하는 것들, 사용자가 필요할 때만 실행되는 것들)
	- 두번째 요소 : __Operating Systems__ (운영체제)
	- 최하위 요소 : __Hardware__ (컴퓨터 부품들, CPU, 메모리, 입출력장치 등)

		![운영체제1](https://user-images.githubusercontent.com/31889335/55477789-f50ca900-5654-11e9-8504-96a77e025d82.PNG)

		컴퓨터가 부팅되면 하드웨어 위에서 운영체제가 제일 먼저 가동되고 운영체제가 각 어플리케이션의 실행을 관리한다

		위 그림에서 볼 수 있듯이 유저는 운영체제에 직접 접근할 수 없다. 어플리케이션을 통해서 운영체제나 하드웨어에 접근할 수 있다.

		예 ) 유저는 프린트를 하려고 프린터를 실행시키고 싶으면 프린터 실행 프로그램(인쇄 프로그램)을 실행시켜야 하지!

- 운영체제가 뭘까?

	운영체제는 영어로 Operating system 이라고 하고 줄여서 OS라고 한다.

	운영체제는 위 그림에서 알 수 있듯이 컴퓨터 시스템의 4가지 구성요소 중 어플리케이션과 하드웨어를 중개하는 중개인 역할을 하는 시스템이다.

- 사용자들의 시점에서 본 운영체제의 역할

	사용자들의 thinking about OS !

	>운영체제는 어플리케이션을 수행시키고, 사용자들이 컴퓨터 시스템을 사용하기 편리하도록 만드는 시스템이다.

- 컴퓨터시스템의 시점에서 본 운영체제의 역할

	컴퓨터의 thinking about OS !

	> 운영체제는 자원 할당자이다. 그리고, 프로그램들을 컨트롤한다. 즉, 운영체제는 어플리케이션이나 입출력장치의 동작을 컨트롤 한다.
	>
	> _여기서 말하는 __자원__ 이란 뭘까_
	>
	> 자원은 두가지로 분류되는데 __하드웨어 자원__ 과 __소프트웨어 자원__ 으로 나눌 수 있다.
	>
	> 1. 하드웨어 자원 = CPU, 메모리, 입출력 장치
	> 2. 소프트웨어 자원 = 파일들, 소켓 등등
	> 
	> 이 자원들이 관리되어야 하는 이유는 자원은 무한하지 않고 한정되어 있기 때문이다!
	

- 자자! 운영체제가 뭔지를 한줄로 정리해보면?! (출제율↑)

	__어플리케이션과 하드웨어 중간에서 하드웨어 자원(리소스)를 적절하고 효율적으로 관리하는 것!__

- 우리 일상생활에서 어떤 것들을 운영체제라고 할까?

	마이크로소프트의 윈도우, 유닉스, 리눅스, 안드로이드, iOS 등등이 운영체제의 종류이다. 

<br>

## ⚡️ 컴퓨터 시스템 작동 방식
---

- 컴퓨터 시스템의 구성요소 중 하나인 하드웨어는 CPU, 메모리, Disk controller, USB controller, Graphics Adapter 가 하나의 bus로 연결되어 있는 구조이다.

	![운영체네2](https://user-images.githubusercontent.com/31889335/55482565-c47e3c80-565f-11e9-8edf-05174837c389.PNG)

	디스크 컨트롤러는 다시 하드디스크를 연결하고, USB 컨트롤러는 다시 키보드, 마우스, 프린터 등을 연결한다.	

	이때, 컨트롤러는 디바이스(예를 들어, 프린터기)를 구동시키는 프로그램이다.

	<br>

- _CPU_

	![운영체제3](https://user-images.githubusercontent.com/31889335/55970562-bb721880-5cba-11e9-94c1-99e625a3894f.PNG)

	위 그림은 CPU의 모습을 나타낸 그림이다. CPU에는 주로 인텔 같은 CPU 회사 이름이 써있는 경우가 많다.

	각 입출력 디바이스 컨트롤러는 local 버퍼(자기 자신의 버퍼 = 조그만 메모리 공간)를 가지고 있다.

	이 버퍼에 임시로 데이터를 잠깐 저장한다.

	마찬가지로 디스크 컨트롤러도 local 버퍼를 갖는데 디스크와 디스크 컨트롤러 버퍼간에 데이터를 주고 받을 때 데이터 임시 저장 공간으로 버퍼를 사용한다.

	CPU는 메인 메모리와 디바이스 컨트롤러의 버퍼간에 데이터를 이동시킨다.
	<br>

- _CPU와 입출력 장치들 간의 관계는 독립적이다_

	CPU와 입출력 장치들은 서로 독립적으로 수행될 수 있다. 만약 CPU가 다른 일을 하고 있을 때 입출력 장치는 CPU가 그 일을 다 마칠때까지 기다려야 할까?

	만약 CPU가 필요하지 않은 작업이라면 CPU가 마칠때까지 기다리지 않고 독자적으로 수행될 수 있다.

	디바이스 컨트롤러는 어떤 디바이스의 수행이 종료되었음을 __interrupt(중단)__ 을 발생시켜서 CPU에게 알려준다. 

	예를 들어, 마우스를 관리하는 디바이스 컨트롤러는 마우스 클릭이 한번 끝날 때마다 interrpt를 발생시킨다.

	<br>

- _interrupt 핸들링_

	만약 디바이스 컨트롤러가 CPU에게 interrupt를 발생시켜서 CPU가 알게되면 CPU는 자신이 하던 일을 멈추고 ISR을 발생시킨다.

	__ISR = Interrupt Service Routine__

	![운영체제4](https://user-images.githubusercontent.com/31889335/55971672-e78e9900-5cbc-11e9-9e65-b8e0e318607a.PNG)

	위 그림에서 민트색으로 표현된 구조를 __interrupt vector 테이블__ 이라고 한다.

	이 vector 테이블에는 키보드 interrupt, 마우스 interrupt, 프린트 interrupt, 디스크 interrupt 등 각각의 디바이스에 대한 interrupt 공간이 있다.

	이 테이블에는 각각의 interrupt가 발생하면 어떻게 해야하는지( = interrupt service)가 저장이 되어있다.

	프로그램을 수행하면서 디바이스 컨트롤러에 의해 각각의 interrupt가 발생하면 vector 테이블에서 해당 interrupt 발생 시 정보가 저장되어 있는 칸으로 이동한다. 

	하지만, 이 vector 테이블이 직접 칸에 저장된 서비스대로 수행시키는 것이 아니라 이 서비스는 ISR이 수행시키는 것이다.

	ISR에 의한 서비스 수행이 끝나면 interrupt가 발생된 결과로 중단되었던 CPU가 다시 실행된다.

	_결국, CPU가 뭔가를 수행하고 있어도 interrupt가 발생하면 자신이 하던 일을 멈추고 발생한 interrupt에 해당하는 서비스를 해야한다는 것이다._

	즉, CPU는 사실 엄청 많이 중단되었다가 실행되기를 반복하고 있다. 하지만 CPU가 너무나도 빨라서 중단되지 않는 것으로 보이는 것이다!

	![운영체제20](https://user-images.githubusercontent.com/31889335/56131190-c500c680-5fc1-11e9-95e8-caddd2b2fc97.PNG)

	위 그림은 입출력장치의 실행이 끝난 후 CPU에서 ISR이 실행되는 모습을 나타낸 것이다.

	idle(=쉬고 있는) 

	위 그림을 보면 입출력장치가 transfer 상태(실행되는 상태)에서 idle 상태(쉬고있는 상태 = 즉, 입출력 행위가 끝난 상태)로 변경되면 디바이스 컨트롤러가 intterupt를 발생시킨다. 

	그럼 프로그램을 실행시키고 있던 CPU가 프로그램 실행을 멈추고 ISR을 실행시키는 모습을 확인할 수 있다.

<br>

## 🍄 저장 장치들
---

- _메인 메모리(1차 저장소)_

	CPU가 직접 바로 엑세스할 수 있는 저장장치이다.

	__DRAM( = Dynamic Random Access Memory )__ 이라고도 한다.

	하지만 휘발성이 있어서 전원을 끄면 메인 메모리에 저장한 데이터들이 날아간다. 그래서 HDD나 SSD 같은 2차 저장소를 사용해서 저장해야 한다.

	<br>

- _2차 저장소들_

	2차 저장소들인 __HDD(하드디스크)__, __SSD(Solid State Drive)__, __flash memory__ 등은 휘발성이 없어서 전원을 꺼도 데이터가 사라지지 않으며, 저장공간이 매우 넓다. 단, CPU가 직접 이 저장소들에 접근하지 않는다!

	![운영체제5](https://user-images.githubusercontent.com/31889335/55972895-5c62d280-5cbf-11e9-9bd2-d815a545a651.PNG)

	<br>

- _저장소들을 비교해보자!_

	![운영체제6](https://user-images.githubusercontent.com/31889335/55973063-c24f5a00-5cbf-11e9-8c1b-d7e905fb014c.PNG)

	위 그림의 각 항목들은 모두 컴퓨터 시스템에서 사용되는 데이터 저장 공간들이다.

	레지스터 쪽으로 갈수록 속도가 빨라지지만 가격이 비싸고, 저장용량이 적어진다.

	SRAM(CPU 캐시)은 CPU 안에 있는 저장장치로, 인텔 CPU의 i5와 i7의 차이점 중 SRAM 차이도 포함된다.

	<br>
	
- _캐시에 대해서 더 알아보자_

	CPU 캐시가 언제 사용될까?

	하드디스크에 있는 데이터는 메인 메모리로 올라와진다. 또, 메인 메모리로 올라온 데이터는 CPU 캐시로 올라와진다. 최종적으로 CPU 캐시에 있는 데이터들은 레지스터로 올라온다.

	CPU 가까이에 데이터를 놓을 수 있는 저장소가 CPU 캐시(SRAM)이다.

	<br>

- _"캐싱한다" 는 무슨 말일까?_

	"캐싱한다" 는 것에 대한 설명을 해보자. 일단 CPU가 어떤 데이터를 얻고자 한다면 얻고자 하는 데이터가 하드디스크에 있는지를 체크한다. 하드디스크에 해당 데이터가 있다면 메인 메모리로 가지고 오고, CPU 캐시에 넣어놓는다.

	이 데이터를 CPU 캐시에 계속 넣어놓으면 CPU가 다음에도 같은 데이터를 원할 때 하드디스크까지 가서 데이터 여부를 확인하지 않고, 바로 CPU 캐시에서 데이터를 찾을 수 있다.

	즉, CPU가 요청하는 데이터가 CPU 캐시에 있는지를 먼저 확인한다. 만약 캐시에 해당 데이터가 있다면 하드디스크까지 가지 않고 CPU 캐시에 있는 데이터를 바로 사용할 수 있다.

	만약 CPU 캐시에 해당 데이터가 없어서 하드디스크까지 갔다 와야 하는 상황이라면 이 때는 다음번을 위해 그 데이터를 CPU 캐시에 복사해서 가져다 놓는다.

	캐시는 CPU 캐시 개념에서만 쓰이는 개념이 아니다.

	다양한 곳에서 캐시라는 개념이 사용되는데 CPU 캐시 외에도 __OS 버퍼 캐시__, __디스크 캐시__, __웹 캐시__ 등 다양한 곳에서 캐시 개념이 사용된다.

	일반적으로 캐시의 크기는 제한적이다. 

	<br>

- _캐시 데이터 일치(coherency)_

	캐시에 저장된 데이터들은 반드시 일치되어야 한다!

	무슨말이냐면

	만약 두 개의 프로그램이 실행되고 있는데 이 두 개의 프로그램은 메인메모리를 공유하고 있고, 각자는 로컬 캐시를 가지고 있다고 하자.

	즉, 아래 그림과 같이

	![운영체제21](https://user-images.githubusercontent.com/31889335/56132812-e5cb1b00-5fc5-11e9-8870-b39faef9fd15.PNG)

	각 프로그램을 실행 중인 각 클라이언트가 메인메모리는 공유하되, 자신만의 캐시 저장소를 가지고 있는 것이다.

	이 때, 메인 메모리에 변수 X가 올라왔고, 이 변수에 0이 저장되어 있다고 하자.

	만약 이 때, 클라이언트 A가 X에 데이터 1을 저장한 후, 클라이언트 B가 변수 X를 읽어들이게 될 경우 A에 의해 변경된 1을 읽게 되는 것이 아니라 0을 읽어들이게 된다.

	즉, 데이터 불일치 문제가 발생한 상황이다. 

	따라서 메모리를 공유하는 방식으로 실행되고 있는 상황에서는 메모리에서 올라온 각 프로그램의 캐시 데이터가 일치되어야 한다는 것이 __캐시 일관성__ 개념이다. 

	캐시 일관성을 유지하기 위해서는 다른 프로세서가 갱신한 캐시 값을 곧바로 다른 프로세서에서 사용할 수 있도록 해주어야 한다. 캐시 일관성을 유지하기 위한 다양한 프로토콜과 일관성 모델이 존재한다.

	이와 같은 캐시 일관성 문제는 멀티 프로세서 환경에서 중요하다.

	<br>

## 👙 운영체제의 특징
---

- _멀티프로그래밍_

	운영체제는 여러 개의 프로그램을 동시에 수행시킬 수 있는 특징이 있다.

	멀티 프로그램이 실행될 때, 한 프로그램이 독자적으로 계속 CPU를 차지할까?
	
	아니다! 하나의 프로그램이 자신의 실행이 끝날 때까지 CPU를 차지하지 않는다! 
	
	만약 자신의 실행이 끝날때까지 CPU를 차지한다면 그 프로그램이 끝날 때까지 다른 프로그램들이 실행되지 못하고 기다리고 있어야 할 것이다..

	설명을 조금 더 보충하자면!!

	여러개의 실행을 위해 메인 메모리에 올라온 프로그램들이 같은 시간동안 메인메모리에 붙잡혀 있을 수 있다는 것이다.

	그리고, 한 프로그램이 독자적으로 CPU를 차지하지 않는다는 말은 CPU는 실행되는 중에는 하나의 프로그램을 실행시키지만 이 프로그램을 끝까지 실행시키고 있지는 않는다는 의미이다.

	__스케줄러__ 에 의해 메인 메모리에 올라온 여러 프로그램 중 하나가 선택되고, 선택된 프로그램이 수행되다가 다른 프로그램으로 교체된다. 다른 프로그램으로 교체되면 원래 실행되고 있던 프로그램이 다시 자신이 선택되기를 기다려야 한다.

	즉, CPU가 여러 프로그램을 돌려가며 실행시킨다는 것이다!
	
	이런 특징 때문에 유저들은 여러 프로그램과 상호작용을 할 수 있게 된다.

	<br>

- _타임쉐어링(Timesharing = 시간공유)_

	CPU에게 만약 1초라는 시간이 주어진다면 CPU는 0.1초는 1번 프로그램을 실행시키는데 쓰고, 0.1초는 2번 프로그램을 실행시키는데 쓴다.

	타임쉐어링은 유닉스라는 운영체제에서 가장 잘 실행되고 있다.

	<br>

- _OS는 이벤트가 발생하기를 기다리고 있는 시스템이라고 보면 된다_

	프로그램이 실행되고 있지도, 입출력 요청이 있지도 않다면 운영체제는 어떠한 이벤트라도 일어나기를 조용히 기다리고 있다.

	운영체제가 기다리는 이벤트에는 __하드웨어 interrupt__ , __유효하지 않은 메모리 엑세스__, __시스템 콜__, __무한 루프 에러__ 등이 있다.

	<br>

- _듀얼 모드(Dual mode)_

	운영체제에는 두 가지 모드가 존재한다.

	__유저 모드__

	__커널 모드__

	운영체제가 무언가를 수행하는 모드는 __커널 모드__ 라고 하고, __유저 모드__ 는 유저가 무언가를 수행하는 모드이다.

	유저 모드는 비트 1로 설명하고, 커널 모드는 비트 0으로 설명된다.

	![운영체제22](https://user-images.githubusercontent.com/31889335/56137685-5840f880-5fd0-11e9-8071-b445b7c3a065.PNG)

	위 그림과 같이 유저가 어떤 프로세스를 실행하여 시스템 콜이 호출되는 부분까지는 유저모드로 분류된다.

	그 후에 시스템 콜이 실행되는 부분은 커널모드로 분류되고, 시스템 콜이 종료되어 비트 1을 반환받으면 다시 유저모드로 분류된다.	

	<br>

## 😎  프로세스 관리하기(Process Management)
---

- _프로세스(Process)가 뭘까?_

	프로세스는 지금 실행되고 있는 프로그램을 말한다.

	> 잉? 프로그램과 프로세스의 차이가 정확히 뭐지?

	프로세스는 능동적이고 프로그램은 수동적이다.
	
	무슨 말이냐 하면 __프로그램__ 은 아직 실행되지 않은 실행할 수 있는 파일이고, __프로세스__ 는 메모리에 올라와 CPU를 할당받고 실행되고 있는 프로그램이다.

	프로세스는 여러가지 자원(resource)들을 필요로 한다. 예를 들어, CPU, 메모리, 입출력장치들, 파일들 등등!

	<br>

- _프로세스를 "관리한다"에 속하는 것들_

	- CPU를 사용하는 프로세스들의 스케줄 관리
	- 프로세스 생성 및 삭제
	- 프로세스 동기화
	- 프로세스들 간의 커뮤니티
	- deadlock(데드락) 핸들링

	<br>

## 💽 메모리 관리하기(Memory Management)
---

- _메모리를 "관리한다"에 속하는 것들_

	- 메모리의 어떤 부분을 누구에게 줄 것인가 결정
	- 어떤 프로세스와 어떤 데이터가 메모리로 올려질 것인가를 결정

	메모리가 한정적이기 때문에 위의 항목들을 메모리 관리자가 잘 결정해야 한다.

	<br>

- _가상 메모리 시스템_

	운영체제는 __가상 메모리__ 라는 개념을 지원한다.

	가상 메모리는 실제 존재하지는 않지만 사용자에게 있어 메모리로써의 역할을 하는 메모리이다.

	이 때, 프로그램은 용량이 큰 가상메모리의 크기에 맞춰 수용되지만 실제 실행될 때는 실제 물리 메모리를 필요로 한다.

	> 가상 메모리가 사용되는 경우는 어떤 경우일까?

	예를 들어, 전공 서적 100권이 필요한데 내 책상은 100권을 모두 놓을 수 없고, 50권의 책만 놓을 수 있다고 하자. 그렇다면 책상에 놓지 않을 50권의 책을 고르려고 고민을 해야만 한다.

	하지만 만약 책장이 있어서 100권의 책을 책장에 놓고, 필요한 책들만 책상으로 가져올 수 있다면? 너무 좋을 것이다.

	이와 같이 실제 메인 메모리보다 용량이 큰 가상 메모리에 프로그램을 올려놓고, 메인 메모리에는 필요한 부분만을 옮겨오는 방식이 가상 메모리 방식이다.

	<br>

## 💾 저장소 관리하기(Storage Management)
---

- _운영체제는 정보 저장에 대한 논리적이고 통일된 저장소를 제공한다._

	- 파일과 파일 시스템

		데이터를 저장할 때 파일을 주로 많이 사용한다. 파일은 소프트웨어적인 저장공간이다.

		파일 시스템을 통해 파일에 데이터를 저장하고, 수정한다.
	

	<br>

- _파일 시스템이 하는 일_

	- 파일과 디렉토리를 생성 및 삭제한다.
	- 파일과 디렉토리를 조작(수정)한다.
	- 파일을 실제 저장소와 어떻게 매핑 시킬 것인지를 관리한다.

	<br>

- _대용량 저장소 관리자_

	보통 대용량 데이터를 저장할 때는 저장 공간이 대용량인 디스크를 많이 사용한다. 

	따라서 컴퓨터 속도는 디스크 시스템과 디스크 알고리즘에 의해 많이 좌우된다.

	<br>

## 📺 I/O 서브 시스템(SubSystem)
---

- _운영체제의 목적 중 하나는 유저로부터 하드웨어의 특색을 숨기는 것에 있다_

	유저로부터 하드웨어를 숨기는 것은 여러 I/O 서브 시스템들을 사용함으로서 실행된다.

	<br>

- _I/O 서브 시스템들은 다음과 같은 요소들로 구성되어 있다_

	- 일반적인 디바이스 드라이버 인터페이스
	- 특정 하드웨어를 위한 드라이버
	- I/O 디바이스들의 메모리 관리자(버퍼, 캐시 등)

	디바이스 마다 디바이스 드라이버가 존재한다. 이 디바이스 드라이버도 운영체제의 일부이다.

	<br>

## 🌀 특별한 목적을 위한 시스템들
---

- _리얼 타임 시스템_

	리얼 타임 운영체제를 말하는 것이다. 

	real time = __실시간__

	리얼 타임 시스템은 deadline(마감 시간)을 중요시 하는 목적을 가진 시스템에 사용된다. 즉, 요청에 의한 응답시간이 실시간으로 수행되어야 하는 시스템에 사용된다.

	__미사일 제어 시스템__ 이나 __운전 시스템__ , __의료 기계 시스템__ 에 사용되는 운영체제가 리얼 타임 시스템 운영체제에 속한다.

	<br>

- _멀티미디어 시스템_

	멀티미디어에 최적화 해놓은 시스템으로 MP3 플레이어, DVD 플레이어 등을 잘 관리하는 시스템이다.

	멀티미디어 시스템도 약간의 리얼타임 시스템이 요구된다.

	<br>

## 💭 가상 머신(Virtual Machine)
---

- _가상머신이 뭐지?_

	가상머신은 __여러 개의 다른 환경을 제공__ 해주는 추상적인 모습의 __단일 컴퓨터__ 이다.

	무슨 말이냐면 하나의 PC에서 종류가 다른 여러 운영체제를 실행하려 할 때 사용되는 것이 가상머신이라는 말이다.

	가상 머신을 사용하지 않으면 실제로 여러개의 다른 OS를 한 컴퓨터에서 수행시킬 수 없다.

	가상머신은 각각의 분리된 실행 환경이 하나의 컴퓨터에 환각적으로 생성된다.

	가상 머신을 줄여서 __VM__ 이라고도 부른다.

	![운영체제23](https://user-images.githubusercontent.com/31889335/56140112-3302b900-5fd5-11e9-9e4b-52edd7dd9ed2.PNG)

	위 그림에서 볼 수 있듯이 가상머신이 아닌 경우에는 하드웨어에 커널(운영체제)를 올린다.

	반면, 가상머신의 경우에는 하드웨어 위에 가상머신을 실행시키고 각 가상머신을 분리된 하드웨어 위에 올린 후, 그 위에 각 커널을 올린다.

	<br>

- _가상머신의 특징_

	- 가상머신은 시스템 리소스들을 완벽히 보호한다.

	- 가상머신 안에서 돌아가는 프로세스가 가상 머신이 제공하는 환경과 자원에 제한을 받으며 가상 세계를 벗어날 수 없다.

	- 가상머신들 간의 리소스 공유할 수 없다.

	- 가상머신은 개발하는 것을 편리하도록 도와준다.

	- 어플리케이션들을 다른 운영체제 환경에서 실행시켜 보면서 테스트 할 때 편리하다.

	<br>

- _Vmware의 아키텍처(구조)_

	Vmware은 __가상머신__ + __제품들(software 할 때의 ware이다)__ 을 뜻한다.

	![운영체제24](https://user-images.githubusercontent.com/31889335/56141504-e1a7f900-5fd7-11e9-8dc3-bf9974d0850b.PNG)

	위 그림은 가상머신의 구조를 시각화한 그림이다.

	일단 하드웨어 위에 host(주인) 운영체제가 올라간다.(리눅스라고 가정)

	host 운영체제 위에서 돌아가는 어플리케이션도 존재한다.

	가상 머신을 만들기 위해 host 운영체제 위에 가상 계층을 만든다.

	이 계층 위에 각각의 가상 메모리, 가상 CPU 등을 올리고 각 운영체제를 올리는 것이다.


	







	









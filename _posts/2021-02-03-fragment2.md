---
layout: post
title:  "[안드로이드] 프래그먼트의 모든 것(FragmentTransaction) - 2편"
date:   2021-02-03 18:34:10 +0700
categories: [안드로이드]
---

> __참고 자료__
>
> [Android Developer 도큐먼트 - 프래그먼트 트랜잭션](https://developer.android.com/guide/fragments/transactions)

<br>

## 0️⃣ 프롤로그

이 포스팅은 [프래그먼트의 모든 것 - 1편](https://choheeis.github.io/newblog//articles/2021-02/fragment) 포스팅과 이어지는 포스팅입니다.

편의상 FragmentManager, FragmentTransaction을 한글 번역하여 '프래그먼트 관리자', '프래그먼트 트랜잭션'라고 작성할 예정입니다^^(~~한글최고~~)

이 포스팅은 위에 언급한 참고 자료들을 보고 이해한 내용을 바탕으로 작성합니다. 혹시라도 오개념 및 빠진 내용이 있다면 댓글로 알려주시면 감사하겠습니다 🧚🏻‍♀️

## 1️⃣ What is FragmentTransaction?

* __[프래그먼트의 모든 것 - 1편](https://choheeis.github.io/newblog//articles/2021-02/fragment) 내용 복습__

    * 1편을 꼼꼼히 보고 와야 이 포스팅이 더욱 잘 이해될 것입니다 ^^

    * 호스트 Activity에 프래그먼트 컨테이너만 배치할 경우, 컨테이너 위치에 프래그먼트를 추가/교체/삭제하는 작업을 프로그래밍적으로 할 수 있습니다.

    * 이와 같은 작업을 프로그래밍적으로 하려면 [프래그먼트 관리자](https://developer.android.com/reference/androidx/fragment/app/FragmentManager)와 [프래그먼트 트랜잭션](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction) 이라는 것을 사용할 줄 알아야 합니다.

    * 런타임 시 프래그먼트를 추가(add), 교체(replace), 삭제(remove)하는 작업을 실행하는 것은 프래그먼트 관리자가 담당합니다.

    * 프래그먼트 관리자는 이러한 작업을 실행할 때 프래그먼트 트랜잭션이라는 단일 단위를 지정하여 이 단위 내에 명시된 프래그먼트 조작 사항을 커밋합니다.

    * 프래그먼트 트랜잭션 단일 단위 내에서는 [FragmentTransaction](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction) 클래스가 제공하는 여러 함수들(API)를 사용해 프래그먼트 추가/교체/삭제 처리를 명시할 수 있습니다.

    * FragmentTransaction 클래스는 Android Jetpack Fragment 라이브러리에서 제공하는 클래스입니다.

    * 프래그먼트 관리자는 백 스택을 관리합니다. 백 스택에 프래그먼트 트랜잭션을 기록하는 이유는 '뒤로가기' 작업이 실행될 경우 되돌리기 위함입니다.

    * <img width="500" alt="25" src="https://user-images.githubusercontent.com/31889335/106852020-ad488400-66fa-11eb-8790-1a09ae32a41b.png">

* __프래그먼트 트랜잭션 인스턴스 생성하기__

    * 프래그먼트 트랜잭션 인스턴스는 프래그먼트 관리자로부터 생성할 수 있습니다.

    * FragmentManager 클래스에서 제공하는 [beginTransaction()](https://developer.android.com/reference/androidx/fragment/app/FragmentManager#beginTransaction()) 함수 호출을 통해 프래그먼트 트랜잭션 인스턴스가 생성됩니다.

    *   ~~~kotlin
        // 프래그먼트 트랜잭션 인스턴스 생성 예시
        val fragmentManager = supportFragmentManager
            val fragmentTransaction = supportFragmentManager.beginTransaction()
        ~~~

* __프래그먼트 트랜잭션 사용 시 반드시 마지막에는 커밋하기__

    * 프래그먼트 트랜잭션 인스턴스를 생성하여 프래그먼트 추가/교체/삭제 작업을 명시한 후에는 반드시 마지막에 커밋(commit)을 해줘야 합니다.

    * 즉, 프래그먼트 트랜잭션을 사용하는 모든 경우의 마지막에는 커밋을 해야 합니다.

    * 커밋은 FragmentTransaction 클래스에서 제공하는 [commit()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#commit()) 함수 호출을 통해 실행합니다.

    * commit() 함수 호출의 의미는 프래그먼트 관리자에게 해당 프래그먼트 트랜잭션에 비로소 모든 작업이 추가되었음을 알리는 신호입니다.

    * <img width="494" alt="14" src="https://user-images.githubusercontent.com/31889335/106717735-74010d00-6643-11eb-83a8-5dd199efab1d.png">

    * (위 코드 참고) fragment [ktx 모듈](https://developer.android.com/kotlin/ktx?hl=ko)을 사용하면 FragmentManager로부터 바로 commit { } 블록을 사용할 수 있습니다. commit { } 블록은 내부적으로 FragmentManager.beginTransaction()을 호출하기 때문에 따로 프래그먼트 트랜잭션 인스턴스를 생성하지 않아도 됩니다.

* __프래그먼트 상태 변화 재정렬(reordering) 허용하기__

    * 모든 프래그먼트 트랜잭션 단일 단위에서는 반드시 [setReorderingAllowed(true)](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#setReorderingAllowed(boolean)) 함수를 호출해야 합니다.

    *   ~~~kotlin
        // 예시
        supportFragmentManager.commit {
            ...
            setReorderingAllowed(true)
        }
        ~~~

    * behavior 일치성을 보장하기 위해 사용하는 setReorderingAllowed(true)는 내부 동작 상 default로 동작하지 않습니다.

    * 하지만 behavior 일치성 보장 작업은 프래그먼트 관리자가 프래그먼트 트랜잭션을 정확히 수행하도록 하려면 반드시 필요합니다.

    * behavior 일치성 보장 작업을 수행하지 않는다면 여러 개의 프래그먼트 트랜잭션이 동시에 실행될 경우 백 스택에 존재하는 어느 프래그먼트(예 - 컨테이너에 추가되자마자 교체된 프래그먼트)가 수명 주기를 통과하지 않거나 ~~~~

* __프래그먼트 추가/삭제하기__

    * 프래그먼트 컨테이너에 새로운 프래그먼트(기존에 단 한 번도 추가하지 않은 프래그먼트)를 추가하려면 프래그먼트 트랜잭션 단일 단위 내부에서 [add()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#add(int,%20java.lang.Class%3C?%20extends%20androidx.fragment.app.Fragment%3E,%20android.os.Bundle)) 함수를 호출하면 됩니다.

    * add() 함수는 FragmentTransaction 클래스가 제공하는 함수입니다.

    * add() 함수는 인자로 추가할 프래그먼트 클래스와 프래그먼트 컨테이너의 ID를 전달합니다.

    *   ~~~kotlin
        // 예시 코드
        fragmentManager.commit {
                setReorderingAllowed(true)
                add(R.id.fragment_container_view, ExampleFragment())
            }
        ~~~
    
    * 추가된 프래그먼트는 RESUMED 상태를 갖게 됩니다.(프래그먼트 수명 주기와 관련된 내용으로 이 포스팅과 이어지는 다음 포스팅에서 다룰 예정입니다)

    * 프래그먼트를 호스트로부터 제거하려면 프래그먼트 트랜잭션 단일 단위 내부에서 [remove()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#remove(androidx.fragment.app.Fragment)) 함수를 호출하면 됩니다.

    * remove() 함수는 FragmentTransaction 클래스가 제공하는 함수입니다.

    * 제거된 프래그먼트는 DESTORYED 상태가 됩니다.

    * 제거 왜 안되냐??? 어???

* __프래그먼트 교체하기__

    * 프래그먼트 컨테이너에 이미 존재하는 프래그먼트를 새로운 프래그먼트(기존에 추가하지 않은 프래그먼트)로 교체하고 싶다면 [replace()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#replace(int,%20java.lang.Class%3C?%20extends%20androidx.fragment.app.Fragment%3E,%20android.os.Bundle)) 함수를 호출하면 됩니다.

    * replace() 함수는 FragmentTransaction 클래스가 제공하는 함수입니다.

    * replace() 함수는 오버로딩되어 여러 모양으로 존재하므로 적합한 함수를 사용해야 합니다.

    * <img width="711" alt="15" src="https://user-images.githubusercontent.com/31889335/106726788-20e08780-664e-11eb-8280-23c24e6ccbb0.png">

    * (위 코드 참고) 호스트 Activity가 처음 실행될 때 ExampleFragment를 컨테이너에 추가하고, 텍스트뷰를 클릭하면 Example2Fragment로 교체하는 코드입니다.

    * (위 코드 참고) 프래그먼트 트랜잭션 commit 블록 내에서 모두 addToBackStack() 함수를 호출하지 않았으므로 백 스택에 기록되지 않습니다. 따라서 '뒤로' 버튼을 누를 경우 이전 작업으로 되돌아가지 않습니다.

    * ![16](https://user-images.githubusercontent.com/31889335/106727848-37d3a980-664f-11eb-84ed-ace6896f304a.gif)

* __백 스택 기록 테스트__

    * addToBackStack() 함수를 호출하여 트랜잭션을 백 스택에 기록할 경우와 addToBackStack() 함수를 호출하지 않아 트랜잭션을 백 스택에 기록하지 않을 경우 차이점 테스트입니다.

    * 백 스택에 저장된 트랜잭션 중 최상단 트랜잭션이 항상 사용자의 눈에 보이게 됩니다.(??? 이거 맞나..)

    * '뒤로' 버튼을 누르면 [FragmentManager.popBackStack()](https://developer.android.com/reference/androidx/fragment/app/FragmentManager#popBackStack()) 함수가 호출된 것과 같은 동작이 실행됩니다.(백 스택에서 최상위 트랜잭션을 pop 합니다)

    * <img width="747" alt="17" src="https://user-images.githubusercontent.com/31889335/106728486-d829ce00-664f-11eb-82db-f749329991a8.png">

    * (위 코드 참고) 먼저 프래그먼트 추가 작업이 포함된 트랜잭션과 교체 작업이 포함된 트랜잭션 모두에서 addToBackStack() 함수를 호출해봤습니다.

    * ![18](https://user-images.githubusercontent.com/31889335/106729098-833a8780-6650-11eb-8e89-47a5cf2f4095.gif)

    * (위 영상 참고) 첫 번째 addToBackStack()에 의해 프래그먼트 추가 관련 트랜잭션이 백 스택에 push 됩니다. 이 순간의 백 스택 최상단은 방금 push한 프래그먼트 추가 관련 트랜잭션이므로 사용자의 눈에는 보라색 프래그먼트가 보이게 됩니다. 두 번째 addToBackStack()에 의해 프래그먼트 교체 관련 트랜잭션이 백 스택에 push 됩니다. 이 순간의 백 스택 최상단은 방금 push한 프래그먼트 교체 관련 트랜잭션이므로 사용자의 눈에는 초록색 프래그먼트가 보이게 됩니다. 이 상태에서 '뒤로' 버튼을 누르면 백 스택의 최상단 트랜잭션이 pop 됩니다. 따라서 최상단 트랜잭션은 보라색 프래그먼트 추가 관련된 트랜잭션이 되고 보라색 프래그먼트가 사용자의 눈에 보이게 됩니다. 다시 한 번 '뒤로' 버튼을 누르면 최상위 트랜잭션이 pop 되어 백 스택은 비어지게 됩니다. 따라서 사용자의 눈에는 호스트 Activity가 보이게 됩니다. 또 다시 '뒤로' 버튼을 누르면 비로소 앱이 종료됩니다.

    * <img width="721" alt="19" src="https://user-images.githubusercontent.com/31889335/106773814-d4fd0500-6684-11eb-98af-7c5222114e2a.png">

    * (위 코드 참고) 이번에는 프래그먼트 추가 작업이 명시되어 있는 트랜잭션에서만 addToBackStack() 함수를 호출해봤습니다.

    * ![20](https://user-images.githubusercontent.com/31889335/106777525-691c9b80-6688-11eb-8185-736b539446b9.gif)

    * (위 영상 참고) 첫 번째 addToBackStack()에 의해 프래그먼트 추가 관련 트랜잭션이 백 스택에 push 됩니다. 이 순간의 백 스택 최상단은 방금 push한 프래그먼트 추가 관련 트랜잭션이므로 사용자의 눈에는 보라색 프래그먼트가 보이게 됩니다. 텍스트뷰 클릭 시 백 스택에 트랜잭션을 push 하지 않고 프래그먼트만 교체됩니다. 따라서 이 순간의 백 스택 최상단은 그대로 프래그먼트 추가 관련 트랜잭션입니다. 이 상태에서 '뒤로' 버튼을 누르면 백 스택의 최상단 트랜잭션이 pop 됩니다. 따라서 이 순간의 백 스택은 비어지게 됩니다. 사용자의 눈에는 호스트 Activity가 보일 것이라고 예상되지만 백 스택에 저장되지 않고 교체된 초록색 프래그먼트가 프래그먼트 컨테이너에 계속 남아있어 사용자의 눈에는 초록색 프래그먼트가 계속 보이게 됩니다. 하지만 초록색 프래그먼트 뒤에서는 Activity가 보이고 있는 상황입니다. 다시 '뒤로' 버튼을 누르면 비로소 앱이 종료됩니다.(초록색 프래그먼트가 Activity에 계속 남아있던 말던 종료됩니다)

    * 따라서 프래그먼트 트랜잭션을 백 스택에 push하지 않은 채 여러 개의 프래그먼트를 추가/교체한 상태에서 '뒤로' 버튼을 한 번이라도 누르면 앱이 종료되버리는 상황이 발생합니다.(백 스택에 아무것도 없기 때문)

    * 이런 상황을 방지하기 위해 프래그먼트 트랜잭션을 백 스택에 push하는 addToBackStack() 함수를 반드시 호출해야 합니다.

    * <img width="695" alt="21" src="https://user-images.githubusercontent.com/31889335/106779130-0a582180-668a-11eb-8013-010bc9632c0f.png">

    * (위 코드 참고) 또 다른 테스트로, 프래그먼트 교체 관련 트랜잭션에서만 addToBackStack()을 호출해봤습니다.

    * ![22](https://user-images.githubusercontent.com/31889335/106782368-6bcdbf80-668d-11eb-9621-72dd9920646f.gif)

    * (위 영상 참고) 첫 번째 프래그먼트 추가 관련 트랜잭션은 백 스택에 push 되지 않고 프래그먼트 컨테이너에 추가되어 사용자의 눈에는 보라색 프래그먼트가 보입니다. 텍스트뷰 클릭 시 백 스택에 프래그먼트 교체 관련 트랜잭션이 push 되고 백 스택 최상단 트랜잭션은 방금 push한 프래그먼트 교체 관련 트랜잭션입니다. 따라서 사용자의 눈에는 초록색 프래그먼트가 보입니다. '뒤로' 버튼을 누르면 백 스택의 최상단 트랜잭션이 pop 됩니다. 따라서 이 순간의 백 스택은 빈 스택이 되어 사용자의 눈에는 Activity가 보일 것이라고 예상되지만 백 스택에 push 되지 않고 컨테이너에 추가된 보라색 프래그먼트가 Activity에 남아있어 사용자의 눈에는 보라색 프래그먼트가 보입니다. 다시 '뒤로' 버튼을 누르면 비로소 앱이 종료됩니다.

    * <img width="732" alt="23" src="https://user-images.githubusercontent.com/31889335/106784242-7721ea80-668f-11eb-8a40-70064382404a.png">

    * (위 코드 참고) 마지막 테스트는 두 트랜잭션 모두 addToBackStack() 함수를 호출하지 않도록 했습니다.

    * ![24](https://user-images.githubusercontent.com/31889335/106785886-45aa1e80-6691-11eb-8d23-5e6cdfc4ee43.gif)

    * (위 영상 참고) 첫 번째 프래그먼트 추가 관련 트랜잭션은 백 스택에 push 되지 않고 프래그먼트 컨테이너에 추가되기만 합니다. 이 때 사용자의 눈에는 보라색 프래그먼트가 보입니다. 텍스트뷰 클릭 시 프래그먼트 교체 관련 트랜잭션도 백 스택에 push 되지 않고 프래그먼트 컨테이너에서 교체되기만 합니다. 이 때 사용자의 눈에는 초록색 프래그먼트가 보입니다. '뒤로' 버튼을 누르면 백 스택 자체가 없기 때문에 바로 앱이 종료됩니다.

    * 프래그먼트 수명 주기 관점에서 보면, 백 스택에 push된 프래그먼트는 STOPPED 상태를 띄게 됩니다.

* __commit에 대해서__

    * 트랜잭션 마지막에 반드시 해줘야 하는 커밋(commit())은 __비동기 처리__ 됩니다.

    * 즉, [commit()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#commit()) 함수를 호출한 순간에 해당 트랜잭션이 즉시 수행되는 것이 아니라는 의미입니다.

    * 즉시 수행되는 것이 아니라 메인 쓰레드(UI 쓰레드)에 해당 트랜잭션이 예약됩니다.(예약된 트랜잭션 수행이 가능한 시점이 되어야만 비로소 수행됩니다)

    * 하지만 만약 해당 트랜잭션이 비동기 처리되면 안되는 불가피한 상황이 존재하여 메인 쓰레드에서 즉시 수행하고 싶다면 [commitNow()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#commitNow()) 함수를 호출하면 됩니다.(~~ㅋㅋㅋ함수 이름 잘 지었네~~)

    * commitNow() 함수를 호출한 시점에 즉시 해당 프래그먼트 트랜잭션이 __동기적으로__ 실행됩니다.

    * 그러나 commitNow() 함수를 호출하여 프래그먼트 트랜잭션을 커밋할 때 주의할 점은 addToBackStack() 함수가 동작하지 않을 수 있다는 점입니다.

    * 즉, commitNow() 함수를 호출하면 프래그먼트 백 스택에 트랜잭션이 push 되지 않을 수 있습니다. 따라서 백 스택에 트랜잭션을 push하는 작업을 해야한다면 commitNow()를 사용하면 안됩니다.

    * 상황을 가정하여, 백 스택에 추가하는 작업이 포함된 트랜잭션(트랜잭션1)에 관해 commit() 함수를 호출한 뒤, 이어서 백 스택에 추가하는 작업이 포함된 다른 트랜잭션(트랜잭션2)에 관해 commitNow() 함수를 호출한 상황을 생각해봅시다.

    * 만약 commit() 함수를 호출한 시점에 바로 메인 쓰레드 준비가 완료되어 트랜잭션1이 즉시 실행된다면 백 스택에 저장되는 트랜잭션의 순서(bottom -> top 순서)는 트랜잭션1, 트랜잭션2 일 것입니다.

    * 그러나 만약 commit() 함수를 호출한 시점에 메인 쓰레드 준비가 되지 않아 예약만 될 경우, 트랜잭션1보다 트랜잭션2가 먼저 실행될 것입니다. 그럼 백 스택에 저장되는 트랜잭션 순서(bottom -> top 순서)는 트랜잭션2, 트랜잭션 1일 것입니다.

    * 결론적으로, addToBackStack() 함수를 포함하는 여러 트랜잭션이 존재하고 이를 commit() 과 commitNow() 함수를 혼용하여 커밋한다면 개발자가 의도한 백 스택 저장 순서를 100% 보장할 수 없습니다.

    * 따라서 commitNow() 함수를 호출하여 프래그먼트 트랜잭션을 즉시 실행해야 할 경우에는 백 스택에 이 트랜잭션을 push하는 작업을 해서는 안됩니다.

    * commit() 함수와 commitNow() 함수는 FragmentTransaction 클래스에서 제공하는 함수입니다.

* __프래그먼트 트랜잭션 내부에 명시하는 명령들의 순서 중요성__

    * 만약 프래그먼트 트랜잭션 내부에 setCustomAnimations() 함수를 사용하여 프래그먼트 애니메이션 설정에 관한 코드를 작성해야 한다면 코드의 순서가 중요합니다.(프래그먼트 애니메이션에 관한 내용은 이 포스팅에서 이어지는 다음 포스팅에서 다룰 예정입니다)

    *   ~~~kotlin
        // 예시 코드
        supportFragmentManager.commit {
            setCustomAnimations(enter1, exit1, popEnter1, popExit1)
            add<ExampleFragment>(R.id.container) // gets the first animations
            setCustomAnimations(enter2, exit2, popEnter2, popExit2)
            add<ExampleFragment>(R.id.container) // gets the second animations
        }
        ~~~

    * (위 코드 참고) setCustomAnimations() 함수는 자기 자신 아래에 작성된 모든 프래그먼트 추가/교체/삭제 작업에 애니메이션을 적용시키는 함수입니다.(위 코드의 주석을 보면 이해가 쉽습니다)

* __프래그먼트 수명 주기에 제한주기__

    * 프래그먼트 트랜잭션은 해당 트랜잭션 단일 단위 범위 내에 추가된 각 프래그먼트의 수명 주기에 영향을 미칠 수 있습니다.

    * 프래그먼트 트랜잭션을 생성할 때 [setMaxLifecycle()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#setMaxLifecycle(androidx.fragment.app.Fragment,%20androidx.lifecycle.Lifecycle.State)) 함수를 호출하면 해당 프래그먼트가 보일 수 있는 상태의 최댓값을 지정할 수 있습니다.

    * 예를 들어, ViewPager2(스와이프 뷰)는 setMaxLifecycle()를 내부적으로 호출하여 화면에 당장 보이고 있지 않은 프래그먼트의 상태를 STARTED 로 제한합니다.

* __프래그먼트의 자체 UI를 보이게하기(show) & 숨기기(hide)__

    * FragmentTransaction 클래스가 제공하는 함수 중 [show()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#show(androidx.fragment.app.Fragment)) 함수와 [hide()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#hide(androidx.fragment.app.Fragment)) 함수를 사용하면 프래그먼트 컨테이너에 이미 추가되어 있는 프래그먼트에 한에서 프래그먼트의 자체 UI를 보이게 하거나 숨길 수 있습니다.

    * 이 두 함수는 프래그먼트의 수명 주기에 영향을 주지 않고 프래그먼트 자체 UI의 visibility를 설정합니다.

    * 따라서 이 두 함수를 사용하면 프래그먼트 트랜잭션을 사용하지 않고도 쉽게 프래그먼트 자체 UI를 보이기/숨기기(=toggle) 기능을 구현할 수 있지만 이 함수는 이미 프래그먼트 백 스택에 push되어 있는 트랜잭션과 관련된 프래그먼트의 보임 여부만 조작할 수 있습니다.

* __프래그먼트를 Attach하기 & Detach하기__

    * FragmentTransaction 클래스가 제공하는 함수 중 [detach()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#detach(androidx.fragment.app.Fragment)) 함수를 호출하면 해당 프래그먼트가 자체 UI로부터 떼지고(=inflate되어 있던 프래그먼트 클래스와 자체 UI가 deflate된다는 의미) 자체 UI의 뷰 계층은 파괴(destroying)됩니다. 프래그먼트(=프래그먼트 클래스)가 자체 UI로부터는 떼어졌지만 그래도 여전히 프래그먼트 관리자로부터 관리됩니다.

    * FragmentTransaction 클래스가 제공하는 함수 중 [attach()](https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#attach(androidx.fragment.app.Fragment)) 함수를 호출하면 자체 UI와 deflate되어 있던 프래그먼트를 다시 자체 UI와 inflate 시킵니다. detach()에 의해 파괴되었던 자체 UI는 다시 재생성(recreate)되고 사용자의 눈에 보이게 됩니다.

    * 하나의 프래그먼트 트랜잭션 안에서 동일한 프래그먼트에 detach()하고 attach() 하는 작업을 이어서 실행하면 detach(), attach() 작업이 실제로 동작하지 않고 작업 취소가 됩니다.(detach(), attach()를 이어서 실행하면 결국 원상태가 되기 때문에 아예 UI를 deflate 했다가 다시 inflate 하는 작업을 실행 조차 하지 않음)

    * 주의할 점은 FragmentTransaction 클래스에서 제공하는 detach()/attach() 함수는 프래그먼트 수명 주기의 onAttach()/onDetach()와는 전혀 다른 작업이라는 점입니다.

* 의문점

    * BackStack에 넣지 않으면 화면 구성은 어떻게 되는거지???(백 스택이랑 컨테이너와의 관계)

    * addToBackStack()에 null이랑 Tag 문자열 넣는거랑 차이점 무엇???

    * add(), remove() 등 더 자세히 알아봐야함    

    * BackStack이 메모리랑 어떻게 관련되어 있는지 알아봐야함

    * 프래그먼트 = 프래그먼트 클래스???

---
layout: post
title:  "[알고리즘] 👨‍🦳 에라토스테네스의 체"
date:   2020-04-03 18:34:10 +0700
categories: [알고리즘]
---

> [동빈나 유튜브](https://www.youtube.com/watch?v=5ypkoEgFdH8&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=24) 영상을 참고하여 공부한 내용!

<br>

# 👨‍🦳 에라토스테네스의 체란?

에라토스테네스의 체는 소수(Prime Number)를 판별해주는 알고리즘이다.

## __소수__ 란?

소수는 '양의 약수를 두 개만 가지는 자연수' 를 의미하는데 이 때, 모든 수의 공통적으로 포함되는 양의 약수는 1이 존재하므로 

'양의 약수를 두 개만 가지는 자연수' 라는 말은 1과 자기 자신만이 약수인 수를 의미한다고 보면 된다!

소수에는 2, 3, 5, 7, 11 ... 등이 존재한다.

## 이러한 소수를 아주 많이 구해야하고, 빠르게 구해야 할 때 사용되는 알고리즘이 __에라토스테네스의 체__ 이다.

사실 소수를 찾는 알고리즘은 에라토스테네스의 체를 사용하지 않고도 아래와 같이 작성할 수 있다.

~~~c++
#include<iostream>
using namespace std;

// 소수를 판별하는 함수 
bool isPrimeNumber(int a){
	for(int i = 2 ; i < a ; i++){
		if(a % i == 0){
			return false;
		}
	}	
	return true;	// 소수일경우  
}

int main(){
	int n;
	cin>>n;
	
	if(isPrimeNumber(n) == true){
		cout<<"소수입니다";
	}else{
		cout<<"소수가 아닙니다"; 
	}
}
~~~

이렇게 소수를 구할 수는 있지만 위 코드의 시간복잡도는 O(N) 이다. 

![시간복잡도2](https://user-images.githubusercontent.com/31889335/78375858-62f10500-7608-11ea-9fe5-5915694f84c6.PNG)

모든 경우의 수를 다 돌면서 약수인지 아닌지를 판별하기 때문에 N의 크기가 커질수록 비효율적일 수 있다!

<br>

## 그렇다면 대량의 소수를 한꺼번에 판별하고자 할 때 효율적인 알고리즘은?

이 때 사용하는 것이 에라토스테네스의 체 라는 알고리즘이다.

<br>

# 👨‍🦳 에라토스테네스의 체 작동 원리

예를 들어, 1부터 25까지의 수 중에서 소수인 수는 어떤 수들인지를 판별해야 한다고 가정하자.

그러면 일단 1부터 25를 배열에 모두 넣는다.

![01](https://user-images.githubusercontent.com/31889335/78376835-d3e4ec80-7609-11ea-97df-dc3356f16c32.PNG)

위와 같이 2차원 배열을 만들어서 배열의 각 원소에 1부터 25까지의 수를 저장하였다.

그렇다면 이제부터 __2부터 시작해서 특정 숫자의 배수에 해당하는 숫자들을 모두 지우면 된다.__ (1은 항상 소수가 아니기 때문에 1은 생각하지 않아도 된다.)

먼저 2의 배수를 지워보자. (이 때, 자기 자신은 지우지 않는다!)

![02](https://user-images.githubusercontent.com/31889335/78377169-3a6a0a80-760a-11ea-884a-c8fc583e4c10.PNG)

그 다음으로는 3의 배수를 지워보자.

![03](https://user-images.githubusercontent.com/31889335/78377350-77360180-760a-11ea-979b-49c265a3a6f4.PNG)

그 다음으로는 4의 배수를 지워야 하지만 이미 4가 지워져 있으므로 5의 배수를 지우면 된다.

이런식으로 모든 숫자에 대해서 그 수의 배수를 지우면 다음과 같이 지워지지 않고 남아있는 숫자들이 있을 것이다.

![04](https://user-images.githubusercontent.com/31889335/78378056-676aed00-760b-11ea-9e90-428b99cef90b.PNG)

남아있는 수들만이 "소수" 이다.

<br>

# 👨‍🦳 에라토스테네스의 체 코드 작성해보기

~~~c++
#include<iostream>
using namespace std;

// 총 십만까지의 수 중에서 소수인 수 판별하기  
int arr[100001]; // 인덱스 0은 사용하지 않음  

// '소수를 판별하는 체' 라는 함수  
void primeNumberSieve(){
	// 배열 초기화  
	for(int i = 2 ; i <= 100000 ; i++){
		arr[i] = i;
	}
	
	// 지우기  
	for(int i = 2 ; i <= 100000 ; i++){
		// 이미 지워진 경우  
		if(arr[i] == 0) continue;
		
		// 지워지지 않은 경우 자기자신을 제외한 수부터 배수 지우기  
		for(int j = i + i ; j <= 100000 ; j = j + i){
			if(arr[j] == 0) continue;
			else arr[j] = 0;	// 지우기 (0으로 저장) 
		} 
	}
	
	// 소수 출력하기 
	for(int i = 2 ; i <= 100000 ; i++){
		if(arr[i] != 0){
			cout<<arr[i]<<' ';
		}
	} 
}

int main(){
	primeNumberSieve();
} 
~~~

위 코드를 실행시켜보면

![05](https://user-images.githubusercontent.com/31889335/78379468-6044de80-760d-11ea-958e-64eb8bd1a411.PNG)

이와 같이 십만까지의 수 중에 소수인 수들이 출력된다!

<br>


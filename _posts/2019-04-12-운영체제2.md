---
layout: post
title:  "[OS] 운영체제2"
date:   2019-04-12 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>
> _2강 - Operating System Structures_
>
> 🙋 2강에서 설명할 수 있어야 하는 것들 🙋
>
> - 다양한 인터페이스
> - 운영체제의 구조
> - 운영체제가 부트되는 과정 


<br>

##  👮 운영체제의 서비스
---

- _운영체제는 아래의 여러 서비스들을 제공한다_

	- 유저 인터페이스를 제공한다.

		CLI = Command Line Interface

		GUI = Graphics User Interface

	- 프로그램을 실행시켜준다.

		프로그램을 메모리에 올려서 실행시키고, 종료한다.

	- 입출력을 동작시킨다.

		키보드와 마우스로부터 입력을 받고, 모니터와 프린터로 출력을 해준다.

	- 파일 시스템을 조작한다.

		파일이나 디렉토리를 읽고 쓰며, 파일들을 생성하고 삭제하고 검색한다.

	- 프로세스간에 정보를 교환하여 소통하게 해준다.

	- 에러를 감지해준다.

		하드웨어 에러나 입출력 에러, 유저가 사용중인 프로그램 에러를 감지한다.

		메모리 에러, 네트워크 연결 에러, 용지 부족 에러, 사용자의 불법적인 메모리 접근 감지 등등

	<br>

- _운영체제는 자신의 효율적인 작동을 위해 아래와 같은 작동을 한다_

	- 효율적으로 리소스를 할당한다.

		주로 멀티 유저 경우나 멀티태스킹 경우에 효율적인 리소스 할당은 중요하다.

		어떤 프로세스에게 얼만큼의 리소스를 할당해야 효율적인지 계산하여 할당한다.	

	- 어떤 유저가 어떤 리소스를 얼만큼 사용하고 있는지 체크한다.

	- 보호 및 보안 기능을 작동한다.

		보호 = 시스템 리소스에 아무나 접근할 수 없도록 통제한다.

		보안 = 유저 인증 기능(사용자 비밀번호 확인 등)을 제공하고, 유저의 잘못된 접근 시도를 방어한다.

	<br>

## 📺 운영체제의 유저 인터페이스
---

- _CLI_

	__Command Line Interface__ 의 약자이다.

	키보드를 사용해서 사용자와 컴퓨터가 상호 작용하는 방식이다.

	![운영체제8](https://user-images.githubusercontent.com/31889335/56050388-bc707c00-5d86-11e9-9338-8cc417a5186e.PNG)

	위와 같이 키보드로 명령어를 입력하여 컴퓨터 시스템을 다루는 것이다.	

	사용자들이 명령어들을 외워야 한다.

	이 때, __쉘(shell)__ 이라는 것이 등장하는데 쉘은 CLI 방식에서 사용되는 명령을 해석하고 관리하는 프로그램이다. 커맨드 interpreter(해석자)라고도 불린다. 

	쉘의 종류 중 bash 라는 쉘이 있다.

	<br>

- _GUI_

	__Graphics User Interface__ 의 약자이다.

	마우스를 사용해서 사용자와 컴퓨터가 상호 작용하는 방식이다.

	현대의 유저들에게 가장 친근한 컴퓨터 조작 방식이다.

	운영체제 중 하나인 리눅스와 유닉스는 CLI 기반이긴 하지만 유저에게 친숙한 GUI도 제공한다.

	요즘의 운영체제들은 위 두 가지 인터페이스 방식을 모두 제공한다.

	<br>

- _시스템 콜(System Call)_

	시스템 콜이라는 것도 인터페이스 중 하나인데 운영체제와 어플리케이션 사이에서 작동되는 인터페이스이다.

	프로그램들은 이 인터페이스를 통해 운영체제에게 서비스를 요청한다.

	프로그램은 운영체제에게 서비스를 제공해 달라는 요청( 예를 들어, 하드웨어를 엑세스 해달라는 요청)을 해야만 한다. 컴퓨터 시스템은 유저가 직접 하드웨어에 접근할 수 없는 구조이기 때문이다.

	 ![운영체제9](https://user-images.githubusercontent.com/31889335/56051039-6f8da500-5d88-11e9-842e-3186bc0a3076.PNG)

	위 그림을 보면 새로운 프로세스를 생성하거나 종료할 때도 시스템 콜을 통해서 수행됨을 볼 수 있다. (프로세스 매니저가 시스템 콜에 요청 및 응답하는 구조)

	하드디스크에 접근해야 할 때도 시스템 콜을 통해 요청하고 응답받는 것도 볼 수 있다.

	즉, 정리해보면 운영체제 커널과 유저레벨 사이에 시스템 콜이 위치한다.

	위 그림을 통해 시스템 콜 밑에서 동작하는 것들에 대해 알아보자!

	- 프로세스 관리자 = 프로세스를 생성하고 종료시키는 일을 한다. 

	- 파일 관리자 = 파일들을 생성하고 삭제하고, 열고 닫으며 읽고 쓰는 일을 한다.

	- 메모리 관리자 = 메모리를 할당해주는 역할을 한다.

	- 데이터 유지자 = 타이머나 달력 정보를 세팅하거나 가져온다.

	- Communications = 네트워크 연결을 생성하고 삭제하며, 메시지를 보내거나 받는일을 한다.
	 
	<br>

- _파일의 내용을 다른 파일에 복사하는 작업에서 시스템 콜의 동작 과정_

	![운영체제25](https://user-images.githubusercontent.com/31889335/56145709-c17c3800-5fdf-11e9-9ccd-fc58e67e253a.PNG)
	
	위 코드는 파일 이름이 infile인 파일을 outfile 이라는 파일로 복사하는 작업에서 실행되는 시스템의 흐름이다.

	위 그림을 통해 우리가 cmd 창에 CLI 명령어인 __cp infile outfile__ 이라고 작성하면 시스템 콜에서는 위와 같은 과정이 일어난다는 것을 알게되었다.

	<br>

- _시스템 콜과 API의 차이점_

	일단! __API__ 란 뭘까?

	__Application Program Interface__ 의 약자이다.

	풀어서 설명하면 어플리케이션을 개발하는 프로그래머들이 사용할 수 있도록 제공하는 __함수__ 들을 모아놓은 것을 말한다!

	프로그래머들이 API를 사용하는 이유는 OS 내부적으로 돌아가는 시스템 콜이 API에 의해 숨겨져 있기 때문에 시스템 콜의 동작을 알 필요가 없기 때문이다.

	>그런데 그럼 __라이브러리__ 랑 __API__ 의 차이점은 뭘까?

	__라이브러리__ = 특정 목적을 위해 별도로 제공되는 함수들의 모임으로 외부로 노출될 수도 있고, 내부에서도 돌아가는 형태이다.

	__API__ = 외부로 노출되는( = 인터페이스 역할을 하는) 함수들의 모음이다. 결국, API를 통해 라이브러리가 사용되는 것이다.

	> 흠,,, 아직 잘 모르겠다 하하

	<br>

- _가장 유명한 API들_

	- 윈도우 프로그래밍을 위한 Win32 API
	- 자바 가상 머신을 위한 Java API

	<br>

- _시스템 콜 vs API_

	![운영체제10](https://user-images.githubusercontent.com/31889335/56053046-f1340180-5d8d-11e9-8d6b-227206026929.PNG)

	일단 위 그림을 보자~

	유저가 프로그램에서 printf() 라는 함수를 호출했다. printf() 함수는 사실 라이브러리이다. 

	라이브러리의 printf() 함수를 보면 write() 라는 함수를 호출하는 것을 확인할 수 있는데 이 write()가 시스템 콜(유저가 커널에 간접적으로 접근할 수 있게 하는 인터페이스)이다!

	여기서는 printf() 가 라이브러리 or API 역할을 한다고 보면 된다.

	write()는 시스템 콜이기 때문에 유저가 프로그램 단계에서 직접 호출할 수도 있다.

	<br>

## 📢 시스템 콜이 매개변수를 넘기는 과정(Passing)
---

- _시스템 콜은 어떤식으로 운영체제에게 자신의 매개변수를 넘겨줄까?_

	예를 들어, open() 이라는 시스템 콜을 호출하려면 open("/etc/passwd", O_RDONLY); 와 같은 코드를 작성해야 하는데 이 때 open() 의 매개변수들인 "/etc/passwd" 와 O_RDONLY를 어떻게 운영체제에게 넘겨주는 것일까?

	(시스템 콜의 종류와 운영체제에 따라서 시스템 콜의 매개변수로 요구되는 변수의 타입과 개수가 다양하다.)

	<br>

- _운영체제에게 매개변수(Parameter)를 넘겨주기 위한 3가지 방법!_

	- 파라미터를 레지스터에게 넘겨주기!

	- 매개변수들을 메모리 위의 테이블안에 저장해 놓았다가 레지스터에게 이 테이블의 주소를 넘겨주기!

	- 매개변수들을 프로그램의 스택에 push 해 놓고, 운영체제 스택으로 pop off 하기!

	<br>

## 🏬 운영체제의 구조
---

- _단순 구조_

	옛날 운영체제(MS-DOS 또는 초창기 UNIX)가 사용했던 구조이다.

	인터페이스와 기능을 담당하는 부분이 분리되어 있지 않은 구조였다.

	또, 어플리케이션은 I/O routine에 직접 접근이 가능했고, 따라서 어플리케이션이 죽어버리면 시스템 전체가 깨져버렸다.

	<br>

 - _계층 구조_

	![운영체제26](https://user-images.githubusercontent.com/31889335/56147082-8596a200-5fe2-11e9-9ca4-fc243620fe61.PNG)

	위 그림과 같이 운영체제 전체가 여러 계층으로 나누어져 있는 구조이다.

	맨 처음 계층(level 0)은 hardware 층이고, 가장 바깥 계층은 user interface 층이다.

	이러한 구조는 디버그가 쉽지만 계층을 정의하기가 어려웠다.

	<br>

- _마이크로커널(Microkernel) 구조_

	이 구조는 많은 것들이 커널 공간으로부터 유저 공간으로 옮겨진 구조이다.

	이 구조에서는 메시지를 통해 유저와 커널의 커뮤니케이션이 가능했지만 많은 메시지 전달로 인해 성능이 떨어지는 단점이 있었다.

	보안성은 좋았다.

	Window NT가 이 구조를 사용한 운영체제였다.

	<br>

- _모듈(Module) 구조_

	모듈 구조는 대부분의 현대 운영체제가 가지는 구조이다.

	객체지향적 접근을 사용하는 구조이며 각각의 요소들이 분리되어 있다.

	인터페이스를 통해 각 요소들간에 소통을 하고, 필요한 요소들만 운영체제를 통해 호출되는 방식이다.

	정확하게는 아래와 같은 구조이다.

	![운영체제27](https://user-images.githubusercontent.com/31889335/56147588-8b40b780-5fe3-11e9-9326-52efc971dd9e.PNG)

	<br>

## 🚀 시스템 부트(System boot)
---

__boot__ = 기억 장치로 스타트하다.

- _운영체제는 어떻게 로드(load)되는 걸까?_

	__부트 로더(bootloader)__ 라는 것에 의해 시스템이 초기화 되고, 실행(run)된다.

	부트 로더는 운영체제를 메모리에 올리고 실행시킨다.

	__Small system__ 이라는 것을 통해 ROM에 부트 로더와 운영체제를 저장한다.

	__Large system__ 이라는 것을 통하면 ROM에는 부트 로더를 저장시키고, 디스크에는 운영체제를 저장시킨다. 

	![운영체제28](https://user-images.githubusercontent.com/31889335/56148043-6e58b400-5fe4-11e9-8b99-e008ab7ce7fd.PNG)

	위 그림은 리눅스 운영체제가 부팅되는 과정을 나타낸 그림이다.

	이 때, __BIOS__ 는 운영체제 중 가장 기본적인 컴퓨터의 입출력을 처리하는 소프트웨어이다.

	![운영체제29](https://user-images.githubusercontent.com/31889335/56148177-b4ae1300-5fe4-11e9-8b3c-a3dfbef2a4ae.PNG)

	위와 같은 입출력창이 바로 bios이다.

	다시 돌아가서, 먼저 ROM에 저장된 바이오스가 실행된다.

	그 다음 Bootloader가 실행되어 Disk에 있는 운영체제 요소들(쉘, 운영체제, 초기화)을 메모리에 올린다.

	<br>

	



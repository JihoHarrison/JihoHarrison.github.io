---
layout: post
title:  "[알고리즘] 😎 Dynamic Programming"
date:   2020-05-01 18:34:10 +0700
categories: [algorithm]
---

> [동빈나 Dynamic Programming](https://www.youtube.com/watch?v=FmXZG7D8nS4&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=21) 과 [동빈나 다이나믹 프로그래밍 타일링 문제](https://www.youtube.com/watch?v=YHZiWaL49HY&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=22) 을 보고 공부한 내용입니다.
>
> 2020/10/26 - 백준 알고리즘 강의를 듣고, 추가로 내용을 수정하였습니다.

<br>

## 1️⃣ 다이나믹 프로그래밍이란??

다이나믹 프로그래밍(Dynamic Programming)은 줄여서 __DP__ 라고도 하고 한글로는 __동적 계획법__ 이라고도 한다.

다이나믹 프로그래밍이라는 용어에서 "다이나믹" 은 __"다단계적"__ 이라는 의믜를 가지고 있다.

> --> [다이나믹 프로그래밍의 역사](https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95) 에 대한 위키피디아 문서 참고!

먼저 개념적으로 다이나믹 프로그래밍은 __큰 문제를 작은 문제로 쪼개서 풀어 나가는 알고리즘__ 이다. 일단은 이렇게만 알아두고 계속 읽어보자.

* __큰 문제를 작은 문제로 쪼개서 풀어 나가는 알고리즘은 두 가지 방법이 존재한다!__

	__다이나믹 프로그래밍__ 과 __분할 정복 알고리즘__ 둘 다 큰 문제를 작은 문제로 쪼개서 풀어 나가는 알고리즘이다.

	다만 __문제를 쪼개는 방식에 차이점__ 이 존재한다.

	* __다이나믹 프로그래밍__ : 큰 문제를 작은 문제로 쪼갰을 때 각 작은 문제들을 __중복으로 사용해도 답이 구해진다!__

		예 ) 어떤 장소에 40명이 존재하는데 이를 10명과 30명으로 나눌 수 있다. 또 이 30명을 다시 10명과 20명으로 나눌 수 있고, 다시 이 20명을 10명과 10명으로 나눌 수 있을 것이다.

		다시 말해 가장 큰 문제를 기호로 __D[N]__ 이라고 하고 위 예시에서 N은 40명이 된다고 생각해보자. = D[40]

		위 예시에서 나누었던 것처럼 D[40]은 D[30] + D[10]으로 표현할 수 있다. 

		이 때, D[30] + D[10] 에서의 D[30]은 다시 또 D[20] + D[10] 으로 표현할 수 있다.

		똑같이 D[20]은 다시 D[10] + D[10] 으로 표현할 수 있다.

		여기서 D[10]의 값이 10 이라고 가정한다면 D[20]은 10 + 10으로 20이라는 것을 알게 된다.

		이 때, D[10] = 10 이고 D[20] = 20임을 어딘가에 저장해두면 D[30] 을 구할 때는 이 저장된 데이터를 보고 20 + 10임을 바로 알 수 있게 된다. 따라서 D[30] = 30 임을 추가로 어딘가에 저장해두자.

		그럼 최종적으로 D[40] 은 저장된 데이터를 보고 30 + 10 이라는 것을 바로 알 수 있게 되어 답을 구할 수 있게 된다.

		위 예시에서는 결국 작은 문제 D[10]이 D[20] 을 구하는데에도 사용되고, D[30]을 구하는 데에도 사용됨을 알 수 있다.
		
		즉, 작은 문제들을 중복으로 사용했다.

		이 과정에서 한 가지 알 수 있는 DP의 장점은 작은 문제들의 값이 구해지면 바로 어딘가에 저장해두어 해당 작은 문제를 또 사용해야 할 때 다시 계산하지 않고, 저장해둔 값을 가져다 사용하면 된다는 것이다! --> 효율성이 높다!

	* __분할 정복 알고리즘__ : 큰 문제를 작은 문제로 쪼갰을 때 각 작은 문제들은 __중복이 불가능하다!__

		예 ) 어떤 직사각형 모양의 장소(면적)이 존재하는데 이를 왼쪽과 오른쪽으로 나눈다고 해보자. 이제 왼쪽으로 나뉘어진 장소 내부에서 다시 위쪽과 아래쪽으로 나누고, 오른쪽으로 나뉘어진 장소 내부에서 다시 위쪽과 아래쪽으로 나눌 수 있을 것이다.

		<img width="983" alt="08" src="https://user-images.githubusercontent.com/31889335/97188027-6804e400-17e6-11eb-968e-42ff90640426.png">

		이 경우에 나뉘어진 각각의 작은 문제들을 서로 중복되는 면적이 아니므로 중복이 존재하지 않는다고 볼 수 있다.

## 2️⃣ 다이나믹 프로그래밍을 사용하여 풀 수 있는 문제의 특징

다이나믹 프로그래밍을 사용하여 풀 수 있는 문제는 두 가지 특징이 있다. 

1. __작은 문제들이 중복되는 경우__

	위에서 언급한 것과 같이 작은 문제로 쪼개었을 때 각 작은 문제들이 중복되는 경우에는 다이나믹 프로그래밍을 사용할 수 있다.

2. __문제의 정답을 쪼갠 작은 문제를 통해서 구할 수 있는 경우__

	예를 들어, 서울에서 부산을 가는 가장 빠른 경로는 __서울 -> 대전 -> 대구 -> 부산__ 이라고 가정해보자.

	그렇다면 대전에서 부산을 가는 가장 빠른 경로는 __대전 -> 대구 -> 부산__ 이라는 것을 알아낼 수 있다.

	만약 대전에서 부산을 가는 가장 빠른 경로가 __대전 -> 울산 -> 부산__ 으로 변경되었다면 서울에서 부산을 가는 가장 빠른 경로의 답도 __서울 -> 대전 -> 울산 -> 부산__ 으로 바뀔 것이다.

	이 예시를 문제의 정답을 쪼갠 작은 문제를 통해서 구할 수 있는 경우라고 할 수 있다.

## 3️⃣ 대표적인 DP 문제 - 피보나치 수열 구하기

대표적인 DP 문제의 첫 번째 문제는 __피보나치 수열 구하기__ 문제이다.

피보나치 수열에 대해서는 [이 블로그의 다른 포스팅 - 피보나치 수열](https://choheeis.github.io/newblog//articles/2019-06/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EC%88%98%EC%97%B4) 을 봐보자.

피보나치 수열 문제를 DP 문제라고 하는 이유는 무엇일까?

피보나치 수열 문제는 __큰 문제를 작은 문제로 쪼개서 풀 수 있기 때문이다.__

이 때 큰 문제는 무엇이고 작은 문제는 무엇일까?

피보나치 수열은 __F(N) = F(N-1) + F(N-2)__ 를 만족하는 수열이다.

이 때, F(N) 이 큰 문제가 되고, F(N-1)과 F(N-2)가 작은 문제들이다!

그럼 피보나치 수열 구하기 문제에 DP의 특징 중 하나인 작은 문제들이 중복되는 경우가 존재할까?

만약 N이 5라고 한다면 큰 문제인 F(5)는 작은 문제들인 F(4) + F(3) 으로 구할 수 있다. 이 때 작은 문제인 F(4)는 F(3) + F(2)로 다시 나눌 수 있고, 이 때 작은 문제 F(3)이 중복되게 된다.

또 피보나치 수열 문제는 DP의 특징인 __문제의 정답을 쪼갠 작은 문제를 통해서 구할 수 있다__ 는 특징도 가지고 있다.

피보나치 수열의 10번째 원소를 구하기 위해서는 4번째 원소가 필요하고, 9번째 원소를 구하기 위해서도 4번째 원소가 필요하기 때문이다.

마찬가지로 8, 7, 6, 5번째 원소를 구하기 위해서도 모두 4번째 원소가 필요하다.

즉, 10번째 원소는 작은 문제들 중에 하나인 4번째 원소를 통해 구해진다.

## 4️⃣ 다이나믹 프로그래밍에서 꼭 사용되는 메모이제이션

위에서 언급한 피보나치 수열 문제를 푼다고 가정해보자.

10번째 원소를 구하기 위해서 9번째 원소와 8번째 원소를 구해야 한다.

9번째 원소를 구하기 위해 8번째 원소와 7번째 원소를 구하게 될 것이고, 8번째 원소를 구하기 위해 7번째 원소와 6번째 원소를 구하게 될 것이다.

즉, 7번째 원소를 구하는 과정은 중복하여 실행되게 되므로 효율성이 떨어지게 된다.

다이나믹 프로그래밍에서 효율성이 떨어지는 것을 막기 위해 꼭 사용해야 하는 것이 __메모이제이션(Memoization)__ 이다.

위 예시에서 7번째 원소를 구해서 __어딘가에 저장(메모)__ 해 두고, 8번째 원소를 구할 때 가져다가 사용하면 된다.

이렇게 작은 문제들인 1번째, 2번째, 3번째... 원소들을 구해서 어딘가에 저장해두고 필요할 때 가져다가 사용하는 방식을 "메모이제이션" 이라고 한다.

보통 메모이제이션에서 __"어딘가에"__ 에 해당하는 장소는 __배열__ 이다.

아래 코드는 피보나치 수열 구하기 문제를 메모이제이션을 사용한 DP 로 푼 코드이다.

~~~c++
// 아래 코드에 사용된 프로그래밍 언어 : c++
int memo[100]; // 메모이제이션을 위한 배열 

int fibonaci(int n) {
	if (n <= 1) {
		return n;
	} else {
		// DP는 보통 메모이제이션 + 재귀함수 호출로 푼다
		memo[n] = fibonaci(n-1) + fibonaci(n-2);
		return memo[n];
	}
}
~~~

## 5️⃣ 다이나믹 프로그래밍을 구현하는 두 가지 과정

다이나믹 프로그래밍을 구현할 때는 주로 두 가지 과정 중 하나로 구현한다.

1. __top-down__ 과정

	큰 문제에서 출발하며 큰 문제를 작은 문제들로 쪼개고, 쪼개진 작은 문제들을 다시 합쳐가며 큰 문제의 답을 구해내는 과정

	주로 __재귀 함수 호출__ 을 사용하여 풀어간다.

	위에서 보여준 피보나치 수열 구하기 코드가 top-down 과정으로 풀어나간 것이다.

2. __bottom-up__ 과정

	작은 문제들을 모아서 어떠한 큰 문제(정답 문제에 비해 상대적으로 작은 문제임)를 구하고, 또 이 작은 문제들을 모아서 큰 문제를 구해가는 과정 (= 쌓아올리는 듯한 과정)

	주로 __반복문__ 을 사용하여 풀어간다.

	~~~c++
	int memo[100]; // 메모이제이션을 위한 배열 

	int fibonaci(int n) {
		memo[0] = 0;
		memo[1] = 1;
		
		for(int i = 2 ; i <=n ; i++) {
			memo[i] = memo[i-1] + memo[i-2]
		}
		
		return memo[n];
	}
	~~~

	위 코드가 bottom-up 과정으로 풀어나간 것이다.

## 6️⃣ 문제 풀이

다이나믹 프로그래밍은 문제를 많이 풀어보고 익숙해지는 것이 중요하다.

다이나믹 프로그래밍과 관련된 문제 풀이는 [이 블로그의 다른 포스팅 - Dynamic Programming 문제풀이]() 에서 공부할 수 있다!

# 끝!

이 포스팅을 통해 다이나믹 프로그래밍의 대략적인 개념이 이해되었다면 반은 했다!

시작이 반이기 때문..ㅎㅎ!😁

<!-- 
## 😎 다이나믹 프로그래밍을 사용하여 타일링 문제 풀어보기
---

[백준 11726번 - 2 x n 타일링](https://www.acmicpc.net/problem/11726) 문제를 풀어보자.

다이나믹 프로그래밍을 푸는 방법은 문제의 규칙을 찾고 점화식(일반식)을 이끌어내는 것이다.

타일링 문제에서 N을 하나씩 늘려가며 답을 구해보자.

![06](https://user-images.githubusercontent.com/31889335/80909464-a2278880-8d63-11ea-8bb2-74bbd5cbbfb7.PNG)

N을 4까지 구했을 때는 위와 같이 결과값이 나올 것이다.

![07](https://user-images.githubusercontent.com/31889335/80909538-1b26e000-8d64-11ea-8693-cf70937fcff7.PNG)

조금 더 생각해보면 N 번째 답은 N-1번째 답에 1개를 세로로 붙이는 방법과 N-2번째 답에 가로로 2개를 붙이는 방법이 있음을 알 수 있다.

즉, 점화식을 구해보면 F(N) = F(N-2) + F(N-1) 인 것이다!

~~~c++
#include<iostream>
using namespace std;

// 2 X i(배열 인덱스) 크기의 직사각형을 채우는 방법의 수 저장
int results[1001]; 

int dp(int a){
	if(a == 1){
		return 1;
	}else if(a == 2){
		return 2;
	}else if(results[a] != 0){
		return results[a];
	}else{
		return results[a] = (dp(a - 2) + dp(a - 1)) % 10007;
	}
} 

int main(){
	int n;
	cin>>n;
		
	cout<<dp(n);		
}
~~~

이와 같이 타일링 문제를 풀 수 있다.

<br>

 -->

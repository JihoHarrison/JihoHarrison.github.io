---
layout: post
title:  "[자료구조] 1. Array(배열)"
date:   2020-12-09 18:34:10 +0700
categories: [자료구조]
---

자료구조의 개념과 간략한 설명에 대해서는 [이 블로그의 다른 포스팅 - 꼭 알아두어야 할 자료구조](https://choheeis.github.io/newblog//articles/2019-07/BasicDataStructure) 에서 볼 수 있다.

✍🏻 [버킹독 실전 알고리즘 강의 - 3강 배열편](https://blog.encrypted.gg/927?category=773649) 을 참고하여 작성합니다.

## 1️⃣ Array(배열)의 형태

배열은 __메모리 상에 데이터(원소)를 연속하게 배치한 자료구조__ 이다.

따라서 아래 그림과 같은 모습을 하고 있다고 생각하면 된다.

<img width="670" alt="01" src="https://user-images.githubusercontent.com/31889335/101599223-c5728e80-3a3c-11eb-8c28-15b8351a465d.png">

배열의 종류에는 직선형(1차원 배열), 직사각형형(2차원 배열), 직육면체형(3차원 배열) 등이 있다.

## 2️⃣ Array(배열)의 특징

Array(배열) 자료구조만이 가지는 특징들을 살펴보자.

1. __추가적으로 소모되는 메모리 양(=overhead)이 거의 없다.__

2. __Cache hit rate가 높다.__

3. __배열을 생성하려면 메모리 상에 연속한 구간을 할당해야 해서 할당에 제약이 걸릴 수 있다.__

> 각 특징들은 나중에 더 찾아보고 보충하자.

## 3️⃣ Array(배열)에서 사용할 수 있는 연산들

총 5개의 연산을 Array 자료구조에 적용할 수 있다.

1. __임의의 위치에 있는 원소를 확인하거나 변경하는 연산 : O(1)이 걸림__

    메모리 상에 일렬로 나열되어 있으니 배열의 __시작 주소에서 k칸 만큼 더하면 k번째 원소를 찾을 수 있다.__

    k번째 원소의 위치 = 시작주소 + (1칸이 차지하는 주소 X k)

    이므로 단순 사칙연산 계산에 의해 O(1)만에 k번째 원소를 찾을 수 있다.

    k번째 원소 위치를 찾았다면 원소를 확인하거나 변경해주면 된다.

    <img width="821" alt="02" src="https://user-images.githubusercontent.com/31889335/101600634-f3f16900-3a3e-11eb-9fda-56fa6d462b90.png">

2. __배열의 가장 끝에 원소 추가하기 : O(1)이 걸림__

    배열의 끝 주소 = 시작 주소 + (1칸이 차지하는 주소 X 배열 길이)

    위 수식을 통해 배열의 끝 주소를 찾고, 배열의 길이를 1 증가시킨 후, 추가할 원소 데이터를 저장하면 된다.

    이것도 시간복잡도는 O(1)이다.

    <img width="766" alt="03" src="https://user-images.githubusercontent.com/31889335/101601133-a6c1c700-3a3f-11eb-8686-0b5504c5c688.png">

3. __배열의 가장 끝 원소 삭제하기 : O(1)이 걸림__

    위에서 알아본 배열의 가장 끝에 원소 추가하기와 비슷하게 배열의 끝 주소를 찾고, 배열의 길이를 1만큼 줄이면 되므로 시간복잡도는 O(1)이다.

    <img width="735" alt="04" src="https://user-images.githubusercontent.com/31889335/101601362-f43e3400-3a3f-11eb-8872-297939e14430.png">

4. __임의의 위치에 원소를 추가하기 : O(N)이 걸림__

    임의의 위치에 원소를 새로 추가해서 끼워넣으려면 그 뒤에 존재하는 모든 원소들을 한 칸씩 뒤로 밀어야 한다.

    <img width="748" alt="05" src="https://user-images.githubusercontent.com/31889335/101602113-ef2db480-3a40-11eb-81d1-1dbbd73fe914.png">

    뒤로 미는 연산이 한 번 일어날 때 O(1)이 걸린다. 만약 N개의 원소를 한 칸씩 밀어야 한다면 O(1XN) = O(N)이 걸리게 된다.

    추가하려는 위치가 배열의 끝과 가까울수록 그 뒤에 존재하는 원소의 개수가 적어져 뒤로 밀어내는 연산의 수도 줄어든다.

    추가하려는 위치가 배열의 처음과 가까울수록 그 뒤에 존재하는 원소의 개수가 많아져 뒤로 밀어내는 연산의 수도 늘어난다.

    하지만 __평균으로 계산해보면 N/2 개의 원소를 뒤로 밀어내야 하므로 시간복잡도는 O(N/2) = O(N)이 걸린다.__

5. __임의의 위치에 있는 원소를 제거하기 : O(N)이 걸림__

    이 연산도 임의의 위치에 원소를 추가하는 것과 비슷하게 수행된다.

    임의의 위치에 있는 원소를 삭제하면 그 뒤에 존재하는 모든 원소들을 한 칸씩 앞으로 당겨와야 한다.

    왜 굳이 앞으로 당겨와야 할까?

    배열의 정의 상 배열은 메모리 상에 데이터(원소)를 연속하게 배치한 자료구조이기 때문이다.

    <img width="684" alt="06" src="https://user-images.githubusercontent.com/31889335/101602831-0ae58a80-3a42-11eb-8078-b38fa93ba806.png">

    앞으로 당기는 연산이 한 번 일어날 때 O(1)이 걸린다. 만약 N개의 원소를 한 칸씩 앞으로 당겨야 한다면 O(1XN) = O(N)이 걸리게 된다.

    제거하려는 원소의 위치가 배열의 끝과 가까울수록 그 뒤에 존재하는 원소의 개수가 적어져 앞으로 당기는 연산의 수도 줄어든다.

    제거하려는 위치가 배열의 처음과 가까울수록 그 뒤에 존재하는 원소의 개수가 많아져 앞으로 당기는 연산의 수도 늘어난다.

    하지만 __평균으로 계산해보면 N/2 개의 원소를 앞으로 당겨야 하므로 시간복잡도는 O(N/2) = O(N)이 걸린다.__

배열에서는 위와 같이 총 5개의 연산을 할 수 있다. 

만약 프로그래밍 언어 자체에 위 5가지 연산을 해주는 함수가 존재한다 해도 각 함수는 위와 같은 원리로 동작하며 위와 같은 시간복잡도를 가질 것이다.

# 끝!
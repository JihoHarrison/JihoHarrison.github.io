---
layout: post
title:  "[OS] 운영체제3"
date:   2019-04-13 18:34:10 +0700
categories: [operating system]
---


> 서울과학기술대학교 3학년 교과과정으로 배운 "운영체제" 시험 공부 및 정리용 포스팅 😆
>
> _3강 - Processes_
>
> - 프로세스란
> - address공간
> - 프로세스의 5가지 상태
> - PCB란
> - CPU 스케줄러
> - context switch
> - 프로세스가 생성되는 방식
> - 생산자-소비자 문제
> - 동기화

<br>

##  🚿 프로세스(Process)
---

- _프로세스란?_

	프로그램들 중 __실행되고 있는 프로그램__ 을 프로세스라고 한다!

	종종 task 라는 용어를 들을 수 있는데 이 task도 프로세스를 말하는 것이다.

	<br>

	![운영체제11](https://user-images.githubusercontent.com/31889335/56074981-1a887800-5df6-11e9-8626-e35ffdf7bd41.PNG)

	위 그림은 프로세스가 실행될 때 a메모리에 생기는 Address(주소) 공간이다. 

	- __text 부분__ = 해당 프로그램의 코드가 들어가는 부분

	- __data 부분__ = 전역변수, static 변수들이 들어가는 부분

	- __Stack 부분__ = 일시적인 데이터가 들어가는 부분( 함수, 함수의 매개변수, 지역변수, 리턴되야하는 주소값 등)

		스택은 용량이 늘어나고 줄어드는 것이 가능하기 때문에 함수가 호출되면 스택이 늘어나고, 함수가 끝나면 스택이 줄어든다!

	- __Heap 부분__ = 런타임동안 동적으로 할당되는 메모리가 들어가는 부분 ( 힙 영역도 늘어나기도 하고 줄어들기도 한다. )

	이때, 텍스트와 데이터 영역은 크기가 변하지 않고 고정되어있다.

	<br>

## 😐 프로세스 상태
---

- _프로세스가 실행되면 프로세스의 상태가 바뀐다!_

	총 5개의 프로세스의 상태가 존재한다.

	__New__ 상태 (프로세스가 생성될 때의 상태)

	__Running__ 상태 (프로세스가 실행되고 있는 상태)

	__Waiting__ 상태 (running 상태는 아닌데 어떤 이벤트가 발생하기를 기다리는 상태이다. 즉, cpu가 할당되기 전에 이벤트를 기다리고 있는 상태이다. 이벤트를 받아야 CPU 할당을 받을 수 있다.)

	blocked 상태 또는 sleep 상태 라고도 한다.

	__Ready__ 상태 (CPU가 할당되기를 기다리고 있는 상태)

	__Terminated__ 상태 (프로세스가 종료된 상태)

	![운영체제12](https://user-images.githubusercontent.com/31889335/56075083-c7172980-5df7-11e9-92c5-d24fa5dcaefd.PNG)

	위 그림은 프로세스의 상태가 변하는 모습을 다이어그램으로 나타낸 그림이다.

	새로운 프로세스가 생성(new 상태)되면 ready 상태로 바뀐다. 

	ready 상태에서 __스케줄러 디스패치(scheduler dispatch)__ 에 의해 선택된 프로세스에 CPU가 할당된다. 즉, running 상태로 바뀌는 것이다.

	프로세스는 cpu를 할당받아서 running 하는데 이 때 혼자만 계속 cpu를 사용할 수는 없다.  __타임 슬라이스(time slice)__ 라고 하는 정해진 시간 만큼 cpu를 쓰다가 다시 ready 상태 줄의 맨 뒤로 돌아간다. 

	만약 프로세스가 입출력을 수행해야 하는 프로세스라면 I/O 이벤트를 기다리는 상태인 waiting 상태가 된다. I/O 이벤트가 완료되면 다시 ready 상태의 줄 뒤로 이동하고, 스케줄러에 의해 cpu를 다시 할당 받아서 프로세스 작업을 이어서 한다.

	이 과정을 반복한 후 유저가 프로그램을 종료하면 프로세스가 종료된다.

	<br>

## ♒️ 프로세스 Control 블록
---

- _프로세스 Control 블록이란?_

	Process Control Block의 줄임말인 PCB라고 명칭하기도 한다.
	
	PCB는 프로세스에 관한 데이터(메타데이터)가 저장된 공간이다.

	![운영체제13](https://user-images.githubusercontent.com/31889335/56075245-51f92380-5dfa-11e9-9dbd-934414e1a788.PNG)

	PCB는 위와 같은 모습으로 되어있다. 커널 안에 현재 실행중인 프로세스 별 PCB들이 존재하는 모습이다.

	![운영체제14](https://user-images.githubusercontent.com/31889335/56075258-8a006680-5dfa-11e9-8e77-25b6936d2bbc.PNG)

	PCB의 구조를 자세히 살펴보면 위와 같다.
	
	해당 프로세스의 ID, 프로세스 상태, 프로그램 counter, 레지스터, 우선순위 등의 정보가 담겨있다.

	__program counter__ 은 프로그램 계수기라고 하며 이 프로세스가 다음에 실행할 명령어가 있는 주소를 가리킨다.

	__priority(우선순위)__ 에는 이 프로세스가 중요한 프로세스여서 CPU할당을 빨리 받아야 하는지 아닌지에 대한 정보가 저장된다.

	리눅스 운영체제에서는 PCB를 __task_struct__ 라고 한다.

	<br>

## 📜 프로세스 스케줄링 큐(Queue)
---

-  프로세스 스케줄링 큐에는 __레디(ready) 큐__ 와 __디바이스(device) 큐__ 가 있다.

- _레디 큐_

	메인 메모리에 올라가 있으면서 수행을 기다리고 있는 모든 프로세스들의 집합을 말한다.

	큐에 있다고 하는 것은 순서를 지켜 한 줄로 기다리고 있음을 의미한다.

	<br>

- _디바이스 큐_

	어떤 I/O 디바이스의 이벤트를 기다리고 있는 프로세스들의 집합이다.

	프로세스들은 레디 큐와  디바이스 큐 사이에 왔다갔다 하는데 즉, 디바이스 큐에서 나와서 레디 큐로 들어갈 수도 있고, 레디 큐에서 나와서 디바이스 큐로 들어갈 수도 있다는 것이다.

	<br>

## 📝 스케줄러(Scheduler)	
---

- _CPU 스케줄러_

	스케줄러는 CPU 스케줄러를 말한다.

	CPU 스케줄러는 현재 수행되고 있는 프로세스가 타임 슬라이스에 의해 중단되면 이 다음으로 어떤 프로세스를 선택하여 CPU를 할당해 주어야 하는지 결정하는 일을 한다.

	일반적으로 CPU 스케줄러는 레디 큐에 있는 것 중 제일 앞에 있는 것을 선택한다.(선착순) 

	하지만 맨 앞에 있는 프로세스에게 CPU를 할당해주는 것이 항상 좋은 방법일까? 아니다!

	CPU 스케줄러가 다음에 수행될 프로세스를 선택하는 기준은 __프로세스의 종류가 어떤 것이냐__ 이다.

	프로세스는 2가지로 분류될 수 있다.

	__I/O bound 프로세스__ = CPU 연산보다는 I/O 작업을 하는데 시간을 더 많이 사용하는 프로세스

	__CPU bound 프로세스__ = I/O 연산보다는 CPU 연산을 하는데 시간을 더 많이 사용하는 프로세스

	이 두 종류의 프로세스들이 레디 큐에서 CPU 할당을 기다리고 있다면 이들 중 CPU 스케줄러는 어떤 프로세스를 먼저 선택해야 할까?

	I/O bound 프로세스를 먼저 선택하여 CPU를 먼저 할당해 주는 것이 좋다.

	왜냐하면 I/O 작업은 CPU의 처리가 오래 걸리지 않고 오히려 I/O 자체 작업 시간이 더 오래 걸린다. 

	따라서 I/O bound 프로세스가 CPU를 요구하는 것을 얼른 들어주고 I/O 자체 작업을 하도록 넘겨주는 것이 좋다.

	만약 CPU 사용시간이 긴 CPU bound 프로세스를 먼저 선택하면 I/O bound 프로세스는 잠깐의 CPU 연산을 하기 위해 CPU bound 프로세스가 끝날 때까지 오래 기다려야 하는 불상사가 발생한다.

	<br>


## 🚁 Context Switch 
---

- 여러 프로세스들이 CPU 할당을 받아서 실행되다가 타임 슬라이스에 의해 중단된 시점에는 막 마쳐진 이 프로세스의 마지막 상태를 저장해야 한다.

또, 이 프로세스가 CPU 스케줄러에게 다시 선택되어졌을 때는 전에 저장해 놓은 프로세스 상태를 불러와야 한다.

위 과정을 __Context Switch__ 라고 한다.

Context Switch 가 행해지는 동안은 어떤 작업도 효율적으로 잘 동작되지 않다. 즉, Context Switch를 하는데 있어서 비용(손해)이 많이 든다는 뜻이다.

이 비용은 운영체제가 올려진 하드웨어의 성능에 따라 달라진다.

![운영체제30](https://user-images.githubusercontent.com/31889335/56150649-453b2200-5fea-11e9-873f-d494320ea637.PNG)

위 그림은 프로세스 P0과 P1 사이에서 Context Switch가 일어나는 과정을 보여준다.

일단, 처음에는 P0가 CPU의 할당을 받아 실행 중인 모습이다. 하지만 타임 슬라이스에 의해 P0은 중단된다.

P0이 중단되면 P0의 PCB에 P0가 중단되기 전 마지막 상태를 저장하고, 다음에 실행될 P1의 상태를 불러온다.

이 과정을 거쳐야 P1이 실행되기 때문에 P0이 중단되고 바로 P1이 실행되는 것이 아니라 약간의 시간지연(PCB저장과 P1상태 load를 위한 시간)이 생길 수 밖에 없다.

바로 이 시간 지연이 운영체제가 올려진 하드웨어 성능에 따라 달라진다는 것이다.

<br>

## 👍 👎 프로세스의 생성과 종료에 대해서
---

- _프로세스의 생성_

	그럼 프로세스는 처음에 어떤 방식으로 생성될까?

	바로 부모 프로세스가 자식 프로세스를 생성하는 구조로 생성된다. 
	
	![운영체제31](https://user-images.githubusercontent.com/31889335/56260278-97c32e00-6111-11e9-8d28-7e9b98b43e3f.PNG)

	부모 프로세스에서 자식 프로세스가 생성되어 뻗어나오는 구조로, 프로세스의 탄생 구조는 __트리 구조__ 임을 확인할 수 있다.

	<br>

- _자식 프로세스는 자원을 필요로 한다_

	자식 프로세스는 자신의 수행을 위해 CPU 같은 리소스를 필요로 하는데 이와 같은 리소스를 운영체제가 직접 할당해 줄 수도 있고, 부모 프로세스가 공유해 줄 수도 있다.

	<br>

- _부모와 자식 프로세스 간의 리소스 공유_

	부모 프로세스가 자식 프로세스에게 자신의 리소스를 공유해 주는 경우에는 부모가 자식 프로세스에게 __모든__ 리소스를 공유해 줄수도 있고, __부분__ 만을 공유해 줄수도 있으며 공유하지 __않을__ 수도 있다.

	<br>

- _프로세스 실행_

	부모와 자식 프로세스가 동시에 실행될 수도 있고, 자식 프로세스가 먼저 종료될 때까지 부모 프로세스가 기다리고 있을수도 있다.

	<br>

- _주소 공간_

	앞에서 프로세스가 실행되면 주소 공간이 생성된다고 설명했다. 

	자식 프로세스의 주소 공간은 부모의 주소 공간을 복사함으로써 생성된다. 이 때, 복사한다는 것이 주소 공간의 내용까지 모두 복사하는 것이 아니라 주소 공간의 구조만 복사한다는 것이다. 그러면 크기가 똑같은 주소 공간이 생성되는데 자식 프로세스가 이 곳을 자신의 주소 공간으로 사용한다.

	<br>

- _프로세스 실행 과정_

	프로세스가 하나 생성되면 처음에는 운영체제 커널이 PCB를 하나 만들어 준다. 또, 주소 공간도 할당해 준다. 그 후 바이너리 프로그램(실행프로그램)을 그 위에 로드하고(PCB상에 프로그램 코드를 올림) 프로그램이 실행될 수 있도록 준비시킨다.

	<br>

- _유닉스 운영체제가 프로세스를 생성하는 방법_

	유닉스 운영체제는 fork 라는 것으로 새로운 프로세스를 생성한다. 

	유닉스에서는 fork가 새로운 프로세스를 만드는 유일한 방법이다. 프로세스를 fork 하면 부모의 PCB가 복사되고 메모리가 할당된다.

	fork가 실행된 후, execve 라는 시스템 콜을 호출하여 디스크에 바이너리 프로그램(실행 프로그램)을 올리고 실행시킨다.

	<br>

- _프로세스 종료_

	부모 프로세스로 부터 생성된 자식 프로세스는 자신이 해야할 일을 끝마친 후, 운영체제에게 자신이 종료되어도 되는지 물어본다.

	종료 허가를 받은 자식 프로세스는 종료되면서 자신이 종료되기를 기다리고 있는 부모 프로세스에세 자신의 상태값을 return(반환)한다.

	이 상태값은 0 부터 255 까지 숫자 중 하나이다.

	wait()라는 시스템 콜에 의해 자식의 종료만을 기다리고 있는 부모 프로세스는 이 상태값(pid라는 변수로 표현)을 받는다.(wait() 함수가 받음)

	만약 어떤 부모 프로세스가 종료된 자신의 자식 프로세스의 상태값을 회수하지 못했을 경우, 이 자식 프로세스를 __좀비 프로세스__ 라고 한다. 
	
	또, 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 이 부모의 자식 프로세스를 __orphan(고아) 프로세스__ 라고 부른다.

	부모 프로세스는 wait( )를 통해 자식 프로세스의 종료를 기다려야만 하고 그 결과로 받은 자식의 상태값에 따라 부모 프로세스가 뒤처리를 해야한다.
	
	좀비 프로세스는 정상적이지 않은 프로세스이다. 하지만 결국 이 좀비 프로세스도 메모리 위에 올라가 있기 때문에 좀비 상태가 많아지면 비정상 프로세스에게 자원을 낭비하는 것이다. 따라서 좀비 상태가 된 프로세스는 어느 정도 시간이 지나면 사라진다.

	부모 프로세스가 자식 프로세스를 직접 종료시키는 경우도 있다. 만약 자식 프로세스가 할당받은 자원을 초과하여 실행되는 경우, 부모 프로세스는 자식 프로세스를 종료시킨다.

	또, 자식 프로세스에게 할당된 일이 더이상 요구되지 않을 경우 자식 프로세스를 종료시킨다.

	어떤 운영체제에서는 부모 프로세스가 종료되면 해당 자식 프로세스들의 존재를 허용하지 않기도 한다. 즉, 부모 프로세스가 종료되면 모든 자식 프로세스도 함께 종료시켜버린다.

	<br>

- _fork과정을 c로 작성하기_

	![운영체제32](https://user-images.githubusercontent.com/31889335/56282346-e7255080-6149-11e9-8d76-8d75988da3db.PNG)

	위 코드는 fork() 를 통해 자식 프로세스가 생성되는 과정을 c언어로 구현한 코드이다.

	코드의 흐름을 살펴보면, 

	일단 pid_t 타입의 변수인 pid를 선언한다.(pid_t 는 Process Id 를 저장하는 Type의 약자이다.)

	그 다음 fork()를 호출하고 반환값을 pid에 저장한다. 

	이 때, fork()를 통해 부모 프로세스의 PCB가 복사되어 자식 프로세스가 생성되고 실행된다. 

	fork()의 반환값은 -1 또는 0인데 -1일 경우에는 에러로 인해 자식 프로세스가 생성되지 못한 것을 의미하고, 0일 경우 자식 프로세스가 정상적으로 생성됨을 의미한다.

	따라서, 위 코드에서는 pid가 음수(-1을 의미)이면 실패 메시지를 띄우고, pid가 0이면 if문 안에 자식 프로세스가 할 일을 작성하였다.

	execlp() 함수는 프로세스를 실행시키는 함수이다. 첫번째 인자는 실행시킬 프로그램의 경로이고, 두번째 인자는 실행시킬 프로그램의 이름이다. 세번째 인자는 옵션인데 특별한 경우가 아닌 이상 NULL로 채운다.

	마지막 else문은 pid가 양수인 경우를 의미한다. fork의 반환값 중 양수는 부모프로세스를 의미한다. 따라서 마지막 else문 안에는 부모 프로세스가 할 일을 작성하면 된다.

	부모 프로세스는 wait() 을 통해 자식 프로세스가 종료되기를 기다린다.

	![운영체제16](https://user-images.githubusercontent.com/31889335/56077311-96de8380-5e15-11e9-81ee-fbecf9d08f70.PNG)

	위 그림을 보고 앞에서 보여준 코드의 흐름을 다시 한번 파악할 수 있을 것이다.

	<br>

## 👬 프로세스들의 협력	
---

- 프로세스 중에는 __Cooperate Process__ 라고 하는 프로세스들 간에 서로 영향을 주고 받아 협력하는 프로세스들이 있는 반면, 서로에게 영향을 주지 않는 독립적인 프로세스도 있다.

- _프로세스들끼리 협력하면 좋은 점_

	서로 정보를 공유할 수 있다.

	계산 속도를 증가시킬 수 있다.

	시스템 함수들을 분리하여 모듈화해서 사용할 수 있다.

	<br>

## 💸  생산자-소비자 문제
---

- _생산자-소비자 문제란?(Producer-Consumer Problem)_

	프로세스에는 생산자 프로세스와 소비자 프로세스가 존재한다는 점을 알아두자.
	
	생산자-소비자 문제란 생산자가 데이터를 생산하면 소비자가 그것을 소비하는 형태에서 발생하는 문제를 말한다.

	이 문제는 생산 속도와 소비 속도의 차이에 의해 발생하는데 생산되는 속도가 소비되는 속도보다 빠를 경우, 생산된 데이터가 바로 소비되지 못한다.

	그래서 __버퍼__ 라는 데이터 임시 저장 공간이 존재하는 것이다. 생산자가 생산한 데이터를 버퍼에 보관하고 소비자는 데이터를 버퍼에서 빼간다.

	하지만 버퍼는 대부분 크기가 정해져 있다. 이렇게 크기가 정해져있는 버퍼를 __Bounded Buffer__ 라고 부른다.(크기가 정해져 있지 않은 버퍼는 __Unbounded Buffer__ 라고 한다.)

	즉, 만약 버퍼가 가득차면 생산자 프로세스는 더 이상 버퍼에 생산한 데이터를 저장할 수 없게 된다. 또 버퍼가 비어있다면 소비자가 데이터를 뺄 수 없게 된다.(이것이 생산자-소비자 문제의 핵심이다)
	
	
	<br>

- _생산자-소비자간의 버퍼 사용 과정_

	생산자와 소비자가 데이터를 공유하는 공간인 버퍼에 대해 자세히 알아보자.

	![버퍼](https://user-images.githubusercontent.com/31889335/56287536-9288d200-6157-11e9-8212-07fbe889ac80.jpg)

	위 그림은 공간이 한정적인 버퍼를 원형으로 설명한 그림이다.

	위 그림은 아래 코드(생산자와 소비자의 버퍼 사용 과정)를 설명한 것이다.

	![운영체제33](https://user-images.githubusercontent.com/31889335/56287619-d2e85000-6157-11e9-903c-0fe3b0672741.PNG)

	<br>

- _두 프로세스의 Communication_

	프로세스들은 서로의 주소 공간을 공유하지 않기 때문에 메시지를 주고 받음으로써 서로 소통해야 한다.

	메시지를 주고 받기 위한 두 가지 메소드가 존재한다.

	__send(message)__

	__receive(message)__

	만약, 두 개의 프로세스가 서로 소통하기를 원한다면 그들 사이에 __communication 링크__ 를 만들어야 한다. 또, send/receive 메소드를 이용하여 메시지를 교환해야 한다.

	communication 링크는 물리적 또는 논리적으로 만들어진다. (물리적 = 하드웨어 버스, 네트워크 / 논리적 = Direct/Indirect Communication, 동기화)
	
	<br>

- _논리적인 Communication 링크의 종류_

	__1. Direct Communication__

	프로세스는 서로에게 명시적인 이름을 붙인다.

	예를 들어, __send__ (P, message) 는 P라는 프로세스에게 메시지를 보낸다는 것이고, __receive__ (Q, message)라는 것은 Q라는 프로세스로부터 메시지를 받는다는 것이다.

	__2. Indirect Communication__

	메시지가 __mailbox__ 라고 하는 곳으로 보내지고 받아지는 방식의 커뮤니케이션이다.

	mailbox는 메시지가 보내지고 받아지는 객체(Object)이다.

	각각의 mailbox는 자신만의 id를 갖는다.

	소통하고자 하는 두 프로세스가 한 mailbox를 공유하는 경우에만 커뮤니케이션이 가능해진다. 그리고 소통이 끝나면 mailbox는 파괴된다.

	__send__ (A, message) 는 A라는 mailbox로 메시지를 보내라는 것이고, __receive__ (A, message) 는 A라는 mailbox로부터 메시지를 받으라는 것이다.

	__3. 동기화(Synchronization)__

	두 프로세스가 메시지를 주고 받음으로써 소통하는 방식으로 __Blocking방식__ 또는 __non-Blocking방식__ 을 사용한다.

	__Blocking방식__ 은 __동기적__ 인 방식이다. 

	무슨 말이냐면 blocking 방식으로 메시지를 주고 받는 경우에는 만약 메시지 receiver가 메시지를 받고 있다면 그 메시지를 다 받을 때까지 메시지 sender을 block(막음=중단)한다. 

	하지만 __Non-blocking__ 은 __비동기적__ 이다.

	즉, Non-blockin 방식에서는 receiver가 메시지를 받고 있어도 메시지 sender는 계속 메시지를 보낼 수 있다. 

 



---
layout: post
title:  "[C] 😂 C언어 기억을 살리자!"
date:   2019-03-03 18:34:10 +0700
categories: [c]
---

> 포스팅 제목 그대로 기억에서 잊혀져가는 c언어를 되살리기 위한 포스팅이다!
> 
> 🙋‍ 이 포스팅에서 알 수 있는 것들 🙋‍
>
> - scanf 함수
> - 서식문자
> - 배열
> - 암시적 형변환
> - 강제적 형변환
> - 자료형별 메모리크기
> - 실수
> - 연산자
> - 정수와 소수를 함께 연산하기
> - 문자열
> - 전역변수 vs 지역변수
> - 변수명 짓기 법칙
> - 변수에 변수 대입하기
> - 2차원 배열

<br>

## scanf 함수
---
- _scanf라는 용어의 뜻이 뭐지?_

	__scan__ + __formatted__ = 스캔(읽다) + 형식(형식을 정해서)

	즉, 사용자의 입력을 읽는데 입력 값의 형식을 지정해 줘야 한다는 것!

	<br>

- _scanf 함수 사용법_

	__scanf("형식", 메모리 주소);__

	형식 부분의 큰따옴표 안에 입력할 데이터의 형식을 지정해줘야 한다.

	메모리 주소는 입력받은 데이터를 메인 메모리의 어디에 저장할지 정해준다.

	즉, 정해준 형식에 맞는 데이터를 입력받아서 지정해 준 메모리 주소에 저장하라는 뜻이다.

	scanf의 메모리 주소 부분은 특별한 경우가 아닌 이상 변수명 앞에 &(앰퍼샌드)를 붙이면 된다.

	> 즉, c언어에서는 변수 이름 앞에 & 기호를 붙이면 해당 변수의 메모리 주소를 뜻함을 알 수 있다.
	>
	> ~~~c 
	> // printf 함수에 &를 붙여서 출력해보면 변수의 값이 나오지 않고 변수 메모리 주소가 출력됨을 확인할 수 있다.
	> printf("%d", &n);
	> ~~~

	입력 받을 데이터가 __문자열(형식이 %s)이라면 메모리 주소부분에 &를 붙이지 않는다.__ --> 붙이면 컴파일 에러가 난다!

	<br>

- _scanf함수는 스페이스 공백을 입력받지 않는다?_

	scanf 함수는 원래 스페이스 공백을 입력받지 않는다. 따라서 스페이스 공백을 입력받고 싶다면 

	~~~c
	// 엔터가 입력될 때까지 그 전의 모든 문자를 입력받는다.
	scanf("%[^\n]c", str);
	~~~ 
	이렇게 작성해야 한다.

	<br>

- _scanf함수로 여러개의 입력 받기_

	scanf 함수 한번으로 여러개의 변수를 입력받기 위해서

	~~~c
	// 변수 a, b, c에 입력을 하되 스페이스나 엔터로 구분하여 입력된다.
	scanf("%d%d%d", &a, &b, &c);


	//이것도 가능하다.
	scanf("%d %d %d", &a, &b, &c);
	~~~

	<br>

- _scanf 함수로 배열의 원소가 int 형인 배열에 입력하기_

	> scanf 함수로 입력한다는 것은 사용자 입력을 받겠다는 것!

	__for문을 사용하여 입력해야 한다!__

	~~~c
	// 배열의 원소가 int 형인 배열의 메모리 주소를 나타낼 때는 &를 꼭 붙여야 한다.
	// 아래 코드로 스페이스 공백으로 입력을 구분할 수도 있고 엔터로도 입력을 구분할 수 있다.
	int isArr[10];
	for(int i = 0 ; i < 10 ; i++){
		scanf("%d", &isArr[i]);
	}
	~~~

- _다른 언어보다 c언어가 빠른 이유?_

	위의 scanf 함수를 사용하기 위해서 우리는 입력 데이터의 형식을 지정해줘야 하고 &기호도 붙여줘야 하고 해야할 것들이 참 많다.

	하지만 파이썬 같은 다른 프로그래밍 언어에서는 입력 형식을 지정해줄 필요가 없다. 이 뿐만 아니라 c언어에서는 프로그래머가 해줘야 하는 문법적인 일이 많은 반면 대부분의 다른 언어들은 c언어보다 해줘야 할 일들이 적다.

	즉, 개발자들은 아주 편하다!

	하지만 c언어는 사람이 컴퓨터에게 어느정도 알려주는 방식이기 때문에 컴퓨터가 자체적으로 해야하는 일이 줄어든다는 장점이 있다. 따라서 c언어는 매우 빠르지만 파이썬은 매우 느리다.

	<br>

## 서식문자
---

- _서식문자란?_

	scanf 함수나 printf 함수에서 입력 or 출력 데이터의 형식을 지정해줄 때 사용하는 문자.

	<br>

- _서식문자의 종류_

	__%f__ : 입력 및 출력할 데이터가 float 자료형 변수일 때 사용

	__%lf__ : 입력 및 출력할 데이터가 double 자료형 변수일 때 사용

	> 💁‍ 더 알아둘 것!
	>
	> %.9f : printf 함수의 서식문자로 사용하면 출력시 소수점 뒤로 아홉번째 자리까지 출력해준다.

	<br>

## 배열
---

- _배열 선언 및 초기화 하기_

	~~~c
	// int 자료형 배열 선언하기
	// 배열 크기가 10이다.
	int arr[10];


	// 배열을 선언과 동시에 초기화하기
	// 10이 출력됨
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
	printf("%d", arr[9]);


	// 배열을 선언과 동시에 초기화 할 경우에는 배열 크기를 지정해 주지 않아도 된다.
	// 배열 크기를 초기화된 원소의 개수라고 판단하기 때문.
	int isArr[] = {1,2,3};


	// 단, 초기화 없이 선언만 할 경우에는 반드시 배열 크기를 명시해줘야 한다.
	// 아래와 같은 코드는 컴파일 에러.
	char isArr[];
	~~~

	<br>

- _배열의 모든 원소를 0으로 초기화 하기_

	~~~c
	int isArr[10] = {};

	~~~

	<br>

- _배열의 특정 인덱스 뒤에 위치한 원소들을 0으로 초기화 하기_

	~~~c
	// isArr 배열의 각 원소들에는  1,4,0,0,0,0,0,0,0,0 이 저장된다.
	// 무조건 인덱스 0부터 명시된 수가 저장되며 나머지 인덱스에는 무조건 0이 저장된다. 
	// 즉, 이 코드는 0,0,0,1,4,0,0,0,0,0 이 아니다.
	int isArr[10] = {1,4};


	// 위와 동작이 같은 코드이다.
	int isArr[10] = {1,4,}

	~~~

	<br>

- _배열을 초기화 하지 않거나 특정 값을 저장해주지 않는다면?_

	특정한 값도 들어가 있지 않고 초기화 되어 있지도 않은 배열의 원소에는 쓰레기 값이 들어간다.

	~~~c

	// 10개 쓰레기 값이 출력되는 것을 볼 수 있다.
	int isArr[10];

	for(int i = 0 ; i < 10 ; i++){
		printf("%d\n", isArr[i]);
	}

	
	~~~

	<br>

## 암시적 형변환
---

__형 변환__ 이라는 것은 변수의 자료형을 다른 자료형으로 바꾸는 행위를 말한다.

영어로는 __casting(캐스팅)__ 이라고 불리기도 한다.

c언어 컴파일러는 어떤 변수에 잘못된 자료형의 데이터가 저장될 경우 그 데이터를 변수 자료형에 맞게 자동으로 변형시킨다. 
	
이것을 __암시적 형변환__ 이라고 한다.

암시적 형 변환의 예를 보면

~~~c
// float 자료형으로 선언된 변수에 int 데이터가 저장된 경우이다.
float isFloat = 3;

// 위 경우에 c 컴파일러는 isFloat 에 3.0이 저장되도록 3 --> 3.0 으로 자동 변형한다.
~~~
	
<br>

## 강제적 형변환
---

- _강제적 형변환이란?_

	위에서 설명한 암시적 형변환은 컴파일러가 자동적으로 변수의 자료형을 바꿔주어 프로그래머가 신경쓰지 않아도 된다.

	하지만 프로그래머가 인위적으로 변수의 자료형을 바꿔주는 행위를 __강제적 형변환__ 이라고 한다.

	<br>

- _강제적 형변환시 주의할 점_

	char 자료형 변수를 int 자료형 변수로 강제 형변환할 경우, 변환된 int 자료형 변수에는 문자의 아스키코드 값(정수)으로 바뀌어 저장된다.

	~~~c
	// int 자료형 변수 isInt 에는 'A'의 아스키코드 값인 65이 저장된다.
	char isChar = 'A';
	int isInt = (int)isChar;


	// int 자료형 변수 a 에는 '5'(숫자 5 아님)의 아스키코드 값인 53이 저장된다.
	// a에 5가 저장되는 것이 아님! 
	char isChar5 = '5';
	int a = (int)isChar5;
	~~~

	<br>

## 자료형별 메모리 크기
---

- _int형 변수의 메모리 크기_

	__4바이트 = 32비트__

	즉, int형 변수에 할당되는 메모리는 32비트이고, 0과 1이 들어갈 수 있는 자리가 32개라는 것!

	따라서 int형 변수에 저장할 수 있는 정수의 범위가 정해져있다는 의미이다.

	<br>

- _float형 변수의 메모리 크기_

	__4바이트 = 32비트__

	<br>

- _double형 변수의 메모리 크기_

	__8바이트 = 64비트__

	> float형 변수를 사용하는 것이 double 형 변수를 사용하는 것 보다 메모리면에서 절약된다.
	>
	> 하지만 소수점 뒤 자리수가 많은 수(정밀한 수)를 표현해야 하는 경우에는 double형 변수를 사용해야 한다.

	<br>

## 실수
---

- _실수란?_

	숫자 중 소수점이 있는 수를 말한다.

	> 😇 float 의 어원
	>
	> float = 떠다니다 = 고정되어 있지 않다.
	>
	> __소수를 표현하는 방식__ 에는 두 가지 방식이 있다.
	> 
	> - __고정 소수점 방식__ : 175.3, 12.6 과 같이 소수점의 위치가 고정되어 있도록 표현하는 방식
	>
	> - __부동 소수점 방식__ : 6.02 X 10^23은 60.2 X 10^22 과 같다. 이와 같이 소수점의 위치가 고정되어 있지 않아도 되도록 표현하는 방식 = 소수점이 고정되어 있지 않다. = __소수점이 떠다닌다.__
	>
	> 위 두 가지 소수 표현 방법 중 컴퓨터는 __부동 소수점 방식__ 을 사용하기 때문에 float 라는 용어를 사용하는 것이다.

	<br>

## 연산자
---

- _+= 연산자_

	\+ 연산자와 = 연산자를 한번에 쓰는 경우 = 를 무조건 뒤에 쓴다.

	~~~c
	sum += num;
	~~~

	<br>

## 정수와 소수를 함께 연산하기
---

- _int / int_

	결과값은 정수로 나온다.

	<br>

- _(double)(int/int)_

	결과값이 소수로 나온다. = 강제 형 변환

	~~~c
	// 3.000000이 출력됨
	int a = 10;
	int b = 3;
	printf("%lf", (double)(a / b));
	~~~

	![01](https://user-images.githubusercontent.com/31889335/57830509-4e87fc00-77ed-11e9-8138-8444782cb377.PNG)

	<br>

- _(double) int / int_

	~~~c
	// 3.333333이 출력됨
	int a = 10;
	int b = 3;
	printf("%lf", (double)a / b);
	~~~

	![02](https://user-images.githubusercontent.com/31889335/57830766-1af9a180-77ee-11e9-9fa8-8b3b90de7c77.PNG)

	<br>

- _ int / (double) int_

	~~~c
	// 3.333333이 출력됨
	int a = 10;
	int b = 3;
	printf("%lf", a / (double) b );
	~~~

	이것도 10 / 3.000000 을 계산해보면 3.333333이 나온다.

	<br>

## 문자열
---

- _문자 vs 문자열_

	__문자__ : 단 한개의 문자
	
	__문자열__ : 문자들의 배열

	> 💔 문자에 대한 편견!
	>
	> 실질적으로 char 형 변수의 메모리에는 문자 'A' 가 들어가는 것이 아니라 A의 아스키코드 값인 65가 들어간다!
	>
	> 문자 자체가 들어간다는 편견을 버리자~! 

	<br>

- _c언어 문자열에 대한 중요한 것!_

	c언어에는 문자 자료형인 char은 존재하지만 문자열 자료형은 따로 존재하지 않는다!!

	따라서 c언어에서 문자열을 표현하고 싶다면 문자들의 배열을 문자열이라고 표현해야 한다.

	~~~c
	char isArr[10];


	// 입력 서식문자는 %c가 아니라 %s 이다.
	// 문자열 형식으로 입력하겠다는 의미이다.
	// 문자열 형식으로 입력할 때는 & 를 붙이지 않는다.
	// chohee를 입력했다고 가정.
	// 첫 번째 출력 : chohee
	// 두 번째 출력 : c
	// 즉, %s 로 입력해도 문자열 인덱스 각각에 'c' 'h' 'o' 'h' 'e' 'e' 가 입력되는 것이다.
	scanf("%s", isArr);
	printf("%s", isArr);
	printf("%c", isArr[0]);
	~~~

	<br>

	> 🤠 문자 vs 문자열의 서식문자
	> 
	> 문자를 나타내는 서식문자 : __%c__
	>
	> 문자열을 나타내는 서식문자 : __%s__
	> 
	> c++ 에는 string 이라는 문자열 자료형이 따로 존재한다.

	<br>

- _cstring 헤더파일_

	char 형 문자들의 배열로 취급되는 c언어 문자열에 적용시킬 수 있는 다양한 함수들이 있다. 이 함수들이 모여있는 파일이 cstring 헤더파일이다.

	__string.h__ 라고도 한다.

	cstring 헤더파일에 존재하는 함수들에는 

	- 두 문자열을 합치는 함수

	- 두 문자열 비교 함수

	- 문자열에서 특정 문자 찾는 함수

	- 문자열의 길이를 재는 함수

	등등이 존재한다.

	> https://modoocode.com/76 참고

	<br>

- _문자열 끝에는 Null문자가 있다구?_

	c언어를 개발하던 개발자들은 __문자열을 사용할 때 문자 배열의 끝에 null 문자가 들어가야 한다!__ 라는 개념을 도입했다!

	이게 무슨 말인지 알아보기 전에 왜 도입을 해야만 했는지를 알면 null 문자가 도입된 이유를 바로 이해할 수 있을 것이다.

	우리가 c언어에서 문자열을 사용할 때는 문자들의 배열을 문자열로 사용하는데 이 배열에 문자열을 저장할 경우, 특정 길이의 문자만 저장할 수 있는 것이 아니라 다양한 길이의 문자들을 저장할 수 있도록 하기 위해서 null 문자를 도입했다.

	아래 코드를 보면서 더 자세히 설명해보자!

	아래 코드는 똑같은 isString 이라는 배열을 "chohee" 라는 문자열로 초기화 할 수도 있고, "kimchohee is chunjea." 라는 문자열로 초기화할 수도 있다는 것을 보여준다.

	~~~c
	char isString[100] = "chohee";


	// 또는
	char isString[100] = "kimchohee is chunjea."
	~~~ 

	<br>

	위 배열에서 첫 번째 경우는 배열의 인덱스 6 부터 인덱스 99까지에는 Null 문자가 들어간다.

	두 번째 경우는 배열의 인덱스 21 부터 인덱스 99까지에 Null 문자가 들어간다.

	즉, 우리가 char 형 배열로 문자열을 선언할 경우 배열의 길이를 100으로 선언해 놓으면 해당 배열에는 길이가 100이 넘지 않는 선에서 문자열을 마음껏 저장할 수 있고, 사용하지 않는 남은 배열 원소들에 Null 문자를 저장하는 것이다. 

	> "chohee" 를 저장할 수도 있고, "kimchohee is chunjea." 를 저장할 수도 있다.

	<br>

	하지만 만약 배열 길이를 5로 선언해놓으면 "chohee" 와 "kimchohee is chunjea." 는 이 배열에 저장할 수 없다.

	즉, 배열의 길이를 크게 잡아 놓고, 배열에 저장할 수 있는 문자열의 길이에 제한을 두지 않기 위해 Null 문자를 도입한 것이다.
	
	__따라서!!!__ 
	
	c언어에서는 __문자열의 끝에는 반드시 Null 문자가 들어가야 한다!__ 라는 규칙이 있다.

	그러므로 배열 길이를 저장할 문자 길이에 딱 맞춰서 선언하고 싶다면 __문자 길이 + 1(Null 문자)__ 크기 만큼 배열 길이를 선언해야 한다.

	> 🎿 Null 문자
	>
	> Null 문자는 아스키코드 값으로 0을 갖는다. 
	> 또, '\0' 이라고 나타내기도 한다.
	>
	> ~~~c
	> char isNull = 0;
	>
	> // 위 코드와 아래 코드는 모두 Null 문자를 가리킨다.
	> char isNull = '\0';
	> ~~~

	또, 컴퓨터에게 문자열을 출력해달라고 하면 컴퓨터는 알아서 Null 문자를 만나기 전 까지에 저장되어 있는 문자열을 출력해준다. 따라서 문자가 저장되어 있는 부분의 끝을 나타내기 위해서도 Null 이 사용된다.

	<br>
	
## 전역변수 vs 지역변수
---

- _전역변수 와 지역변수란?_

	C언어에서는 변수가 선언되어 메모리에 자리잡는 위치에 따라서 크게 __전역변수__ 와 __지역변수__ 로 나뉜다!

	<br>

- _지역변수 메모리 위치_

	지역변수는 __스택(stack)__ 이라는 메모리 영역에 자리를 잡는다.

	> 🤯 프로그램이 실행된다는 것은 메인 메모리에 프로그램이 올라간다는 것이다!
	> 
	> 이 때, 실행되는 프로그램마다 메모리 공간이 주어지는데 이 메모리 공간은 또 다시 data 공간, heap 공간, stack 공간 등으로 나뉜다.
	>
	> data, heap, stack 이라는 공간 중 지역변수는 stack 이라는 공간에 할당된다는 의미이다!

	<br>

- _그럼 어떤 변수들이 stack 에 할당되는 지역변수일까?_

	중괄호 안에서 선언된 변수들을 지역변수라고 한다!

	즉, for문 안에서 선언된 변수가 있다면 그 변수는 지역변수이고, stack 공간에 위치한다.

	<br>

- _지역 변수의 중요한 특징_

	지역 변수는 선언된 중괄호 안에서만 사용가능하고 중괄호 밖에서는 사용 불가능하다!

	즉, for문에 선언된 변수는 for문 안에서만 접근가능하고 for문 밖에서는 접근 불가능하다. (for 문 밖에서 for문 안의 변수의 값을 바꾸거나 할 수 없다!)

	<br>

- _전역 변수는 코드상 어디에 있을까?_

	지역 변수는 중괄호 안에서 선언된 변수들인 반면 전역변수는 중괄호 밖에서 선언된 변수들이다. 

	따라서 main함수 안이나 for문 안에서 사용되는 모든 변수들은 지역변수이고, main 함수 밖에서 사용되는 모든 변수들은 전역변수이다.
	
	아래 코드를 보면 쉽게 알 수 있을 것이다.

	~~~c
	#include<stdio.h>

	// 전역변수
	int num = 1;

	int main(){

		// 지역변수
		int sum = 2;
	}
	~~~

	<br>

## c언어 변수 선언 tip
---

- 한 줄에 콤마로 여러 변수를 선언할 수 있다!

	~~~c
	int a, b, c; 
	a = 1, b = 2, c = 3;

	//또는
	int f[3];
	f[0] = 0, f[1] = 1; 
	~~~

	<br>

## 변수명 짓기 법칙
---

-	변수명은 숫자 사용하거나 숫자로 시작할 수 없다.

	<br>

## 변수에 변수 대입하기
---

- 변수에 변수를 대입하는 것은 값을 복사하여 대입하는 것이다.

	~~~c
	int A = 1, B = 2;

	// B의 값인 2가 복사되어 A 에 대입된다.
	// 즉, B의 값이 사라지는 것이 아니라 그래도 남아있다.
	A = B;
	~~~

	<br>

## 2차원 배열
---

- _2차원 배열은 가로세로 빈틈없는 직사각형 모양의 배열이다_

	우리는 보통 1차원 배열인 선형 배열을 자주 사용하지만 문제에 따라 가로세로 빈틈없는 직사각형 모양의 배열인 2차원 배열을 사용해야 할 경우도 많이 있다.

	<br>

	![2차원 배열](https://user-images.githubusercontent.com/31889335/61298500-482bf580-a819-11e9-912a-1ebf3f011050.PNG)

	<br>

	2차원 배열에 속하는 각 변수에 접근하기 위해서는 __배열명 [행 번호] [열 번호]__  라는 표현식을 사용해야 한다.

	> 행 부터 시작함을 기억하자!  

	따라서 3차원 배열은 자연스럽게 직육면체 모양의 배열임을 예상할 수 있을 것이다.